/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@semicolondsm/ui/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@semicolondsm/ui/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js\nvar require_react_is_development = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 60103;\n        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 60106;\n        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 60107;\n        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 60108;\n        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 60114;\n        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 60109;\n        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 60110;\n        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 60111;\n        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 60111;\n        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 60112;\n        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 60113;\n        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 60120;\n        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 60115;\n        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 60116;\n        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 60121;\n        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 60117;\n        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 60118;\n        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 60119;\n        function isValidElementType(type) {\n          return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n        }\n        function typeOf(object) {\n          if (typeof object === \"object\" && object !== null) {\n            var $$typeof = object.$$typeof;\n            switch ($$typeof) {\n              case REACT_ELEMENT_TYPE:\n                var type = object.type;\n                switch (type) {\n                  case REACT_ASYNC_MODE_TYPE:\n                  case REACT_CONCURRENT_MODE_TYPE:\n                  case REACT_FRAGMENT_TYPE:\n                  case REACT_PROFILER_TYPE:\n                  case REACT_STRICT_MODE_TYPE:\n                  case REACT_SUSPENSE_TYPE:\n                    return type;\n                  default:\n                    var $$typeofType = type && type.$$typeof;\n                    switch ($$typeofType) {\n                      case REACT_CONTEXT_TYPE:\n                      case REACT_FORWARD_REF_TYPE:\n                      case REACT_LAZY_TYPE:\n                      case REACT_MEMO_TYPE:\n                      case REACT_PROVIDER_TYPE:\n                        return $$typeofType;\n                      default:\n                        return $$typeof;\n                    }\n                }\n              case REACT_PORTAL_TYPE:\n                return $$typeof;\n            }\n          }\n          return void 0;\n        }\n        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element2 = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false;\n        function isAsyncMode(object) {\n          {\n            if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n              hasWarnedAboutDeprecatedIsAsyncMode = true;\n              console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n            }\n          }\n          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n        }\n        function isConcurrentMode(object) {\n          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n        }\n        function isContextConsumer(object) {\n          return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n          return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement(object) {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef(object) {\n          return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n          return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n          return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n          return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n          return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n          return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n          return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n          return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        exports.AsyncMode = AsyncMode;\n        exports.ConcurrentMode = ConcurrentMode;\n        exports.ContextConsumer = ContextConsumer;\n        exports.ContextProvider = ContextProvider;\n        exports.Element = Element2;\n        exports.ForwardRef = ForwardRef;\n        exports.Fragment = Fragment;\n        exports.Lazy = Lazy;\n        exports.Memo = Memo;\n        exports.Portal = Portal;\n        exports.Profiler = Profiler;\n        exports.StrictMode = StrictMode;\n        exports.Suspense = Suspense;\n        exports.isAsyncMode = isAsyncMode;\n        exports.isConcurrentMode = isConcurrentMode;\n        exports.isContextConsumer = isContextConsumer;\n        exports.isContextProvider = isContextProvider;\n        exports.isElement = isElement;\n        exports.isForwardRef = isForwardRef;\n        exports.isFragment = isFragment;\n        exports.isLazy = isLazy;\n        exports.isMemo = isMemo;\n        exports.isPortal = isPortal;\n        exports.isProfiler = isProfiler;\n        exports.isStrictMode = isStrictMode;\n        exports.isSuspense = isSuspense;\n        exports.isValidElementType = isValidElementType;\n        exports.typeOf = typeOf;\n      })();\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js\nvar require_react_is = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js\"(exports, module2) {\n    \"use strict\";\n    if (false) {} else {\n      module2.exports = require_react_is_development();\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-assign-npm-4.1.1-1004ad6dec-fcc6e4ea8c.zip/node_modules/object-assign/index.js\nvar require_object_assign = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-assign-npm-4.1.1-1004ad6dec-fcc6e4ea8c.zip/node_modules/object-assign/index.js\"(exports, module2) {\n    \"use strict\";\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    function toObject(val) {\n      if (val === null || val === void 0) {\n        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n      }\n      return Object(val);\n    }\n    function shouldUseNative() {\n      try {\n        if (!Object.assign) {\n          return false;\n        }\n        var test1 = new String(\"abc\");\n        test1[5] = \"de\";\n        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n          return false;\n        }\n        var test2 = {};\n        for (var i = 0; i < 10; i++) {\n          test2[\"_\" + String.fromCharCode(i)] = i;\n        }\n        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n          return test2[n];\n        });\n        if (order2.join(\"\") !== \"0123456789\") {\n          return false;\n        }\n        var test3 = {};\n        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n          test3[letter] = letter;\n        });\n        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n          return false;\n        }\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {\n      var from;\n      var to = toObject(target);\n      var symbols;\n      for (var s = 1; s < arguments.length; s++) {\n        from = Object(arguments[s]);\n        for (var key in from) {\n          if (hasOwnProperty.call(from, key)) {\n            to[key] = from[key];\n          }\n        }\n        if (getOwnPropertySymbols) {\n          symbols = getOwnPropertySymbols(from);\n          for (var i = 0; i < symbols.length; i++) {\n            if (propIsEnumerable.call(from, symbols[i])) {\n              to[symbols[i]] = from[symbols[i]];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/lib/ReactPropTypesSecret.js\nvar require_ReactPropTypesSecret = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/lib/ReactPropTypesSecret.js\"(exports, module2) {\n    \"use strict\";\n    var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n    module2.exports = ReactPropTypesSecret;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/lib/has.js\nvar require_has = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/lib/has.js\"(exports, module2) {\n    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/checkPropTypes.js\nvar require_checkPropTypes = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/checkPropTypes.js\"(exports, module2) {\n    \"use strict\";\n    var printWarning = function() {\n    };\n    if (true) {\n      ReactPropTypesSecret = require_ReactPropTypesSecret();\n      loggedTypeFailures = {};\n      has = require_has();\n      printWarning = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n          console.error(message);\n        }\n        try {\n          throw new Error(message);\n        } catch (x) {\n        }\n      };\n    }\n    var ReactPropTypesSecret;\n    var loggedTypeFailures;\n    var has;\n    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n      if (true) {\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error;\n            try {\n              if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                err.name = \"Invariant Violation\";\n                throw err;\n              }\n              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n            } catch (ex) {\n              error = ex;\n            }\n            if (error && !(error instanceof Error)) {\n              printWarning((componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof error + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\");\n            }\n            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n              loggedTypeFailures[error.message] = true;\n              var stack = getStack ? getStack() : \"\";\n              printWarning(\"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\"));\n            }\n          }\n        }\n      }\n    }\n    checkPropTypes.resetWarningCache = function() {\n      if (true) {\n        loggedTypeFailures = {};\n      }\n    };\n    module2.exports = checkPropTypes;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/factoryWithTypeCheckers.js\nvar require_factoryWithTypeCheckers = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/factoryWithTypeCheckers.js\"(exports, module2) {\n    \"use strict\";\n    var ReactIs = require_react_is();\n    var assign = require_object_assign();\n    var ReactPropTypesSecret = require_ReactPropTypesSecret();\n    var has = require_has();\n    var checkPropTypes = require_checkPropTypes();\n    var printWarning = function() {\n    };\n    if (true) {\n      printWarning = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n          console.error(message);\n        }\n        try {\n          throw new Error(message);\n        } catch (x) {\n        }\n      };\n    }\n    function emptyFunctionThatReturnsNull() {\n      return null;\n    }\n    module2.exports = function(isValidElement, throwOnDirectAccess) {\n      var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n      function getIteratorFn(maybeIterable) {\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n        if (typeof iteratorFn === \"function\") {\n          return iteratorFn;\n        }\n      }\n      var ANONYMOUS = \"<<anonymous>>\";\n      var ReactPropTypes = {\n        array: createPrimitiveTypeChecker(\"array\"),\n        bigint: createPrimitiveTypeChecker(\"bigint\"),\n        bool: createPrimitiveTypeChecker(\"boolean\"),\n        func: createPrimitiveTypeChecker(\"function\"),\n        number: createPrimitiveTypeChecker(\"number\"),\n        object: createPrimitiveTypeChecker(\"object\"),\n        string: createPrimitiveTypeChecker(\"string\"),\n        symbol: createPrimitiveTypeChecker(\"symbol\"),\n        any: createAnyTypeChecker(),\n        arrayOf: createArrayOfTypeChecker,\n        element: createElementTypeChecker(),\n        elementType: createElementTypeTypeChecker(),\n        instanceOf: createInstanceTypeChecker,\n        node: createNodeChecker(),\n        objectOf: createObjectOfTypeChecker,\n        oneOf: createEnumTypeChecker,\n        oneOfType: createUnionTypeChecker,\n        shape: createShapeTypeChecker,\n        exact: createStrictShapeTypeChecker\n      };\n      function is(x, y) {\n        if (x === y) {\n          return x !== 0 || 1 / x === 1 / y;\n        } else {\n          return x !== x && y !== y;\n        }\n      }\n      function PropTypeError(message, data) {\n        this.message = message;\n        this.data = data && typeof data === \"object\" ? data : {};\n        this.stack = \"\";\n      }\n      PropTypeError.prototype = Error.prototype;\n      function createChainableTypeChecker(validate) {\n        if (true) {\n          var manualPropTypeCallCache = {};\n          var manualPropTypeWarningCount = 0;\n        }\n        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n          componentName = componentName || ANONYMOUS;\n          propFullName = propFullName || propName;\n          if (secret !== ReactPropTypesSecret) {\n            if (throwOnDirectAccess) {\n              var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\");\n              err.name = \"Invariant Violation\";\n              throw err;\n            } else if (typeof console !== \"undefined\") {\n              var cacheKey = componentName + \":\" + propName;\n              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {\n                printWarning(\"You are manually calling a React.PropTypes validation function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\");\n                manualPropTypeCallCache[cacheKey] = true;\n                manualPropTypeWarningCount++;\n              }\n            }\n          }\n          if (props[propName] == null) {\n            if (isRequired) {\n              if (props[propName] === null) {\n                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n              }\n              return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n            }\n            return null;\n          } else {\n            return validate(props, propName, componentName, location, propFullName);\n          }\n        }\n        var chainedCheckType = checkType.bind(null, false);\n        chainedCheckType.isRequired = checkType.bind(null, true);\n        return chainedCheckType;\n      }\n      function createPrimitiveTypeChecker(expectedType) {\n        function validate(props, propName, componentName, location, propFullName, secret) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== expectedType) {\n            var preciseType = getPreciseType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"), { expectedType });\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createAnyTypeChecker() {\n        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n      }\n      function createArrayOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (typeof typeChecker !== \"function\") {\n            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n          }\n          var propValue = props[propName];\n          if (!Array.isArray(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n          }\n          for (var i = 0; i < propValue.length; i++) {\n            var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n            if (error instanceof Error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createElementTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          if (!isValidElement(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createElementTypeTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          if (!ReactIs.isValidElementType(propValue)) {\n            var propType = getPropType(propValue);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createInstanceTypeChecker(expectedClass) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (!(props[propName] instanceof expectedClass)) {\n            var expectedClassName = expectedClass.name || ANONYMOUS;\n            var actualClassName = getClassName(props[propName]);\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createEnumTypeChecker(expectedValues) {\n        if (!Array.isArray(expectedValues)) {\n          if (true) {\n            if (arguments.length > 1) {\n              printWarning(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\");\n            } else {\n              printWarning(\"Invalid argument supplied to oneOf, expected an array.\");\n            }\n          }\n          return emptyFunctionThatReturnsNull;\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          for (var i = 0; i < expectedValues.length; i++) {\n            if (is(propValue, expectedValues[i])) {\n              return null;\n            }\n          }\n          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n            var type = getPreciseType(value);\n            if (type === \"symbol\") {\n              return String(value);\n            }\n            return value;\n          });\n          return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createObjectOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (typeof typeChecker !== \"function\") {\n            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n          }\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n          }\n          for (var key in propValue) {\n            if (has(propValue, key)) {\n              var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n              if (error instanceof Error) {\n                return error;\n              }\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createUnionTypeChecker(arrayOfTypeCheckers) {\n        if (!Array.isArray(arrayOfTypeCheckers)) {\n           true ? printWarning(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n          return emptyFunctionThatReturnsNull;\n        }\n        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n          var checker = arrayOfTypeCheckers[i];\n          if (typeof checker !== \"function\") {\n            printWarning(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + getPostfixForTypeWarning(checker) + \" at index \" + i + \".\");\n            return emptyFunctionThatReturnsNull;\n          }\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n          var expectedTypes = [];\n          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {\n            var checker2 = arrayOfTypeCheckers[i2];\n            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n            if (checkerResult == null) {\n              return null;\n            }\n            if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n              expectedTypes.push(checkerResult.data.expectedType);\n            }\n          }\n          var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n          return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createNodeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n          if (!isNode(props[propName])) {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function invalidValidatorError(componentName, location, propFullName, key, type) {\n        return new PropTypeError((componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\");\n      }\n      function createShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n          }\n          for (var key in shapeTypes) {\n            var checker = shapeTypes[key];\n            if (typeof checker !== \"function\") {\n              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n            }\n            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n            if (error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function createStrictShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n          var propValue = props[propName];\n          var propType = getPropType(propValue);\n          if (propType !== \"object\") {\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n          }\n          var allKeys = assign({}, props[propName], shapeTypes);\n          for (var key in allKeys) {\n            var checker = shapeTypes[key];\n            if (has(shapeTypes, key) && typeof checker !== \"function\") {\n              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n            }\n            if (!checker) {\n              return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n            }\n            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n            if (error) {\n              return error;\n            }\n          }\n          return null;\n        }\n        return createChainableTypeChecker(validate);\n      }\n      function isNode(propValue) {\n        switch (typeof propValue) {\n          case \"number\":\n          case \"string\":\n          case \"undefined\":\n            return true;\n          case \"boolean\":\n            return !propValue;\n          case \"object\":\n            if (Array.isArray(propValue)) {\n              return propValue.every(isNode);\n            }\n            if (propValue === null || isValidElement(propValue)) {\n              return true;\n            }\n            var iteratorFn = getIteratorFn(propValue);\n            if (iteratorFn) {\n              var iterator = iteratorFn.call(propValue);\n              var step;\n              if (iteratorFn !== propValue.entries) {\n                while (!(step = iterator.next()).done) {\n                  if (!isNode(step.value)) {\n                    return false;\n                  }\n                }\n              } else {\n                while (!(step = iterator.next()).done) {\n                  var entry = step.value;\n                  if (entry) {\n                    if (!isNode(entry[1])) {\n                      return false;\n                    }\n                  }\n                }\n              }\n            } else {\n              return false;\n            }\n            return true;\n          default:\n            return false;\n        }\n      }\n      function isSymbol(propType, propValue) {\n        if (propType === \"symbol\") {\n          return true;\n        }\n        if (!propValue) {\n          return false;\n        }\n        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n          return true;\n        }\n        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n          return true;\n        }\n        return false;\n      }\n      function getPropType(propValue) {\n        var propType = typeof propValue;\n        if (Array.isArray(propValue)) {\n          return \"array\";\n        }\n        if (propValue instanceof RegExp) {\n          return \"object\";\n        }\n        if (isSymbol(propType, propValue)) {\n          return \"symbol\";\n        }\n        return propType;\n      }\n      function getPreciseType(propValue) {\n        if (typeof propValue === \"undefined\" || propValue === null) {\n          return \"\" + propValue;\n        }\n        var propType = getPropType(propValue);\n        if (propType === \"object\") {\n          if (propValue instanceof Date) {\n            return \"date\";\n          } else if (propValue instanceof RegExp) {\n            return \"regexp\";\n          }\n        }\n        return propType;\n      }\n      function getPostfixForTypeWarning(value) {\n        var type = getPreciseType(value);\n        switch (type) {\n          case \"array\":\n          case \"object\":\n            return \"an \" + type;\n          case \"boolean\":\n          case \"date\":\n          case \"regexp\":\n            return \"a \" + type;\n          default:\n            return type;\n        }\n      }\n      function getClassName(propValue) {\n        if (!propValue.constructor || !propValue.constructor.name) {\n          return ANONYMOUS;\n        }\n        return propValue.constructor.name;\n      }\n      ReactPropTypes.checkPropTypes = checkPropTypes;\n      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n      ReactPropTypes.PropTypes = ReactPropTypes;\n      return ReactPropTypes;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/index.js\nvar require_prop_types = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-npm-15.8.1-17c71ee7ee-c056d3f1c0.zip/node_modules/prop-types/index.js\"(exports, module2) {\n    if (true) {\n      ReactIs = require_react_is();\n      throwOnDirectAccess = true;\n      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);\n    } else {}\n    var ReactIs;\n    var throwOnDirectAccess;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-keys-npm-1.1.1-1bf2f1be93-b363c5e764.zip/node_modules/object-keys/isArguments.js\nvar require_isArguments = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-keys-npm-1.1.1-1bf2f1be93-b363c5e764.zip/node_modules/object-keys/isArguments.js\"(exports, module2) {\n    \"use strict\";\n    var toStr = Object.prototype.toString;\n    module2.exports = function isArguments(value) {\n      var str = toStr.call(value);\n      var isArgs = str === \"[object Arguments]\";\n      if (!isArgs) {\n        isArgs = str !== \"[object Array]\" && value !== null && typeof value === \"object\" && typeof value.length === \"number\" && value.length >= 0 && toStr.call(value.callee) === \"[object Function]\";\n      }\n      return isArgs;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-keys-npm-1.1.1-1bf2f1be93-b363c5e764.zip/node_modules/object-keys/implementation.js\nvar require_implementation = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-keys-npm-1.1.1-1bf2f1be93-b363c5e764.zip/node_modules/object-keys/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var keysShim;\n    if (!Object.keys) {\n      has = Object.prototype.hasOwnProperty;\n      toStr = Object.prototype.toString;\n      isArgs = require_isArguments();\n      isEnumerable = Object.prototype.propertyIsEnumerable;\n      hasDontEnumBug = !isEnumerable.call({ toString: null }, \"toString\");\n      hasProtoEnumBug = isEnumerable.call(function() {\n      }, \"prototype\");\n      dontEnums = [\n        \"toString\",\n        \"toLocaleString\",\n        \"valueOf\",\n        \"hasOwnProperty\",\n        \"isPrototypeOf\",\n        \"propertyIsEnumerable\",\n        \"constructor\"\n      ];\n      equalsConstructorPrototype = function(o) {\n        var ctor = o.constructor;\n        return ctor && ctor.prototype === o;\n      };\n      excludedKeys = {\n        $applicationCache: true,\n        $console: true,\n        $external: true,\n        $frame: true,\n        $frameElement: true,\n        $frames: true,\n        $innerHeight: true,\n        $innerWidth: true,\n        $onmozfullscreenchange: true,\n        $onmozfullscreenerror: true,\n        $outerHeight: true,\n        $outerWidth: true,\n        $pageXOffset: true,\n        $pageYOffset: true,\n        $parent: true,\n        $scrollLeft: true,\n        $scrollTop: true,\n        $scrollX: true,\n        $scrollY: true,\n        $self: true,\n        $webkitIndexedDB: true,\n        $webkitStorageInfo: true,\n        $window: true\n      };\n      hasAutomationEqualityBug = function() {\n        if (typeof window === \"undefined\") {\n          return false;\n        }\n        for (var k in window) {\n          try {\n            if (!excludedKeys[\"$\" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === \"object\") {\n              try {\n                equalsConstructorPrototype(window[k]);\n              } catch (e) {\n                return true;\n              }\n            }\n          } catch (e) {\n            return true;\n          }\n        }\n        return false;\n      }();\n      equalsConstructorPrototypeIfNotBuggy = function(o) {\n        if (typeof window === \"undefined\" || !hasAutomationEqualityBug) {\n          return equalsConstructorPrototype(o);\n        }\n        try {\n          return equalsConstructorPrototype(o);\n        } catch (e) {\n          return false;\n        }\n      };\n      keysShim = function keys(object) {\n        var isObject = object !== null && typeof object === \"object\";\n        var isFunction = toStr.call(object) === \"[object Function]\";\n        var isArguments = isArgs(object);\n        var isString = isObject && toStr.call(object) === \"[object String]\";\n        var theKeys = [];\n        if (!isObject && !isFunction && !isArguments) {\n          throw new TypeError(\"Object.keys called on a non-object\");\n        }\n        var skipProto = hasProtoEnumBug && isFunction;\n        if (isString && object.length > 0 && !has.call(object, 0)) {\n          for (var i = 0; i < object.length; ++i) {\n            theKeys.push(String(i));\n          }\n        }\n        if (isArguments && object.length > 0) {\n          for (var j = 0; j < object.length; ++j) {\n            theKeys.push(String(j));\n          }\n        } else {\n          for (var name in object) {\n            if (!(skipProto && name === \"prototype\") && has.call(object, name)) {\n              theKeys.push(String(name));\n            }\n          }\n        }\n        if (hasDontEnumBug) {\n          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n          for (var k = 0; k < dontEnums.length; ++k) {\n            if (!(skipConstructor && dontEnums[k] === \"constructor\") && has.call(object, dontEnums[k])) {\n              theKeys.push(dontEnums[k]);\n            }\n          }\n        }\n        return theKeys;\n      };\n    }\n    var has;\n    var toStr;\n    var isArgs;\n    var isEnumerable;\n    var hasDontEnumBug;\n    var hasProtoEnumBug;\n    var dontEnums;\n    var equalsConstructorPrototype;\n    var excludedKeys;\n    var hasAutomationEqualityBug;\n    var equalsConstructorPrototypeIfNotBuggy;\n    module2.exports = keysShim;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-keys-npm-1.1.1-1bf2f1be93-b363c5e764.zip/node_modules/object-keys/index.js\nvar require_object_keys = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-keys-npm-1.1.1-1bf2f1be93-b363c5e764.zip/node_modules/object-keys/index.js\"(exports, module2) {\n    \"use strict\";\n    var slice = Array.prototype.slice;\n    var isArgs = require_isArguments();\n    var origKeys = Object.keys;\n    var keysShim = origKeys ? function keys(o) {\n      return origKeys(o);\n    } : require_implementation();\n    var originalKeys = Object.keys;\n    keysShim.shim = function shimObjectKeys() {\n      if (Object.keys) {\n        var keysWorksWithArguments = function() {\n          var args = Object.keys(arguments);\n          return args && args.length === arguments.length;\n        }(1, 2);\n        if (!keysWorksWithArguments) {\n          Object.keys = function keys(object) {\n            if (isArgs(object)) {\n              return originalKeys(slice.call(object));\n            }\n            return originalKeys(object);\n          };\n        }\n      } else {\n        Object.keys = keysShim;\n      }\n      return Object.keys || keysShim;\n    };\n    module2.exports = keysShim;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-symbols-npm-1.0.3-1986bff2c4-a054c40c63.zip/node_modules/has-symbols/shams.js\nvar require_shams = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-symbols-npm-1.0.3-1986bff2c4-a054c40c63.zip/node_modules/has-symbols/shams.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function hasSymbols() {\n      if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n        return false;\n      }\n      if (typeof Symbol.iterator === \"symbol\") {\n        return true;\n      }\n      var obj = {};\n      var sym = Symbol(\"test\");\n      var symObj = Object(sym);\n      if (typeof sym === \"string\") {\n        return false;\n      }\n      if (Object.prototype.toString.call(sym) !== \"[object Symbol]\") {\n        return false;\n      }\n      if (Object.prototype.toString.call(symObj) !== \"[object Symbol]\") {\n        return false;\n      }\n      var symVal = 42;\n      obj[sym] = symVal;\n      for (sym in obj) {\n        return false;\n      }\n      if (typeof Object.keys === \"function\" && Object.keys(obj).length !== 0) {\n        return false;\n      }\n      if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(obj).length !== 0) {\n        return false;\n      }\n      var syms = Object.getOwnPropertySymbols(obj);\n      if (syms.length !== 1 || syms[0] !== sym) {\n        return false;\n      }\n      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {\n        return false;\n      }\n      if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n        if (descriptor.value !== symVal || descriptor.enumerable !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-symbols-npm-1.0.3-1986bff2c4-a054c40c63.zip/node_modules/has-symbols/index.js\nvar require_has_symbols = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-symbols-npm-1.0.3-1986bff2c4-a054c40c63.zip/node_modules/has-symbols/index.js\"(exports, module2) {\n    \"use strict\";\n    var origSymbol = typeof Symbol !== \"undefined\" && Symbol;\n    var hasSymbolSham = require_shams();\n    module2.exports = function hasNativeSymbols() {\n      if (typeof origSymbol !== \"function\") {\n        return false;\n      }\n      if (typeof Symbol !== \"function\") {\n        return false;\n      }\n      if (typeof origSymbol(\"foo\") !== \"symbol\") {\n        return false;\n      }\n      if (typeof Symbol(\"bar\") !== \"symbol\") {\n        return false;\n      }\n      return hasSymbolSham();\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function-bind-npm-1.1.1-b56b322ae9-b32fbaebb3.zip/node_modules/function-bind/implementation.js\nvar require_implementation2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function-bind-npm-1.1.1-b56b322ae9-b32fbaebb3.zip/node_modules/function-bind/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var ERROR_MESSAGE = \"Function.prototype.bind called on incompatible \";\n    var slice = Array.prototype.slice;\n    var toStr = Object.prototype.toString;\n    var funcType = \"[object Function]\";\n    module2.exports = function bind(that) {\n      var target = this;\n      if (typeof target !== \"function\" || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n      }\n      var args = slice.call(arguments, 1);\n      var bound;\n      var binder = function() {\n        if (this instanceof bound) {\n          var result = target.apply(this, args.concat(slice.call(arguments)));\n          if (Object(result) === result) {\n            return result;\n          }\n          return this;\n        } else {\n          return target.apply(that, args.concat(slice.call(arguments)));\n        }\n      };\n      var boundLength = Math.max(0, target.length - args.length);\n      var boundArgs = [];\n      for (var i = 0; i < boundLength; i++) {\n        boundArgs.push(\"$\" + i);\n      }\n      bound = Function(\"binder\", \"return function (\" + boundArgs.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n      if (target.prototype) {\n        var Empty = function Empty2() {\n        };\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n      }\n      return bound;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function-bind-npm-1.1.1-b56b322ae9-b32fbaebb3.zip/node_modules/function-bind/index.js\nvar require_function_bind = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function-bind-npm-1.1.1-b56b322ae9-b32fbaebb3.zip/node_modules/function-bind/index.js\"(exports, module2) {\n    \"use strict\";\n    var implementation = require_implementation2();\n    module2.exports = Function.prototype.bind || implementation;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-npm-1.0.3-b7f00631c1-b9ad53d53b.zip/node_modules/has/src/index.js\nvar require_src = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-npm-1.0.3-b7f00631c1-b9ad53d53b.zip/node_modules/has/src/index.js\"(exports, module2) {\n    \"use strict\";\n    var bind = require_function_bind();\n    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/get-intrinsic-npm-1.1.1-7e868745da-a9fe2ca8fa.zip/node_modules/get-intrinsic/index.js\nvar require_get_intrinsic = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/get-intrinsic-npm-1.1.1-7e868745da-a9fe2ca8fa.zip/node_modules/get-intrinsic/index.js\"(exports, module2) {\n    \"use strict\";\n    var undefined2;\n    var $SyntaxError = SyntaxError;\n    var $Function = Function;\n    var $TypeError = TypeError;\n    var getEvalledConstructor = function(expressionSyntax) {\n      try {\n        return $Function('\"use strict\"; return (' + expressionSyntax + \").constructor;\")();\n      } catch (e) {\n      }\n    };\n    var $gOPD = Object.getOwnPropertyDescriptor;\n    if ($gOPD) {\n      try {\n        $gOPD({}, \"\");\n      } catch (e) {\n        $gOPD = null;\n      }\n    }\n    var throwTypeError = function() {\n      throw new $TypeError();\n    };\n    var ThrowTypeError = $gOPD ? function() {\n      try {\n        arguments.callee;\n        return throwTypeError;\n      } catch (calleeThrows) {\n        try {\n          return $gOPD(arguments, \"callee\").get;\n        } catch (gOPDthrows) {\n          return throwTypeError;\n        }\n      }\n    }() : throwTypeError;\n    var hasSymbols = require_has_symbols()();\n    var getProto = Object.getPrototypeOf || function(x) {\n      return x.__proto__;\n    };\n    var needsEval = {};\n    var TypedArray = typeof Uint8Array === \"undefined\" ? undefined2 : getProto(Uint8Array);\n    var INTRINSICS = {\n      \"%AggregateError%\": typeof AggregateError === \"undefined\" ? undefined2 : AggregateError,\n      \"%Array%\": Array,\n      \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? undefined2 : ArrayBuffer,\n      \"%ArrayIteratorPrototype%\": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,\n      \"%AsyncFromSyncIteratorPrototype%\": undefined2,\n      \"%AsyncFunction%\": needsEval,\n      \"%AsyncGenerator%\": needsEval,\n      \"%AsyncGeneratorFunction%\": needsEval,\n      \"%AsyncIteratorPrototype%\": needsEval,\n      \"%Atomics%\": typeof Atomics === \"undefined\" ? undefined2 : Atomics,\n      \"%BigInt%\": typeof BigInt === \"undefined\" ? undefined2 : BigInt,\n      \"%Boolean%\": Boolean,\n      \"%DataView%\": typeof DataView === \"undefined\" ? undefined2 : DataView,\n      \"%Date%\": Date,\n      \"%decodeURI%\": decodeURI,\n      \"%decodeURIComponent%\": decodeURIComponent,\n      \"%encodeURI%\": encodeURI,\n      \"%encodeURIComponent%\": encodeURIComponent,\n      \"%Error%\": Error,\n      \"%eval%\": eval,\n      \"%EvalError%\": EvalError,\n      \"%Float32Array%\": typeof Float32Array === \"undefined\" ? undefined2 : Float32Array,\n      \"%Float64Array%\": typeof Float64Array === \"undefined\" ? undefined2 : Float64Array,\n      \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? undefined2 : FinalizationRegistry,\n      \"%Function%\": $Function,\n      \"%GeneratorFunction%\": needsEval,\n      \"%Int8Array%\": typeof Int8Array === \"undefined\" ? undefined2 : Int8Array,\n      \"%Int16Array%\": typeof Int16Array === \"undefined\" ? undefined2 : Int16Array,\n      \"%Int32Array%\": typeof Int32Array === \"undefined\" ? undefined2 : Int32Array,\n      \"%isFinite%\": isFinite,\n      \"%isNaN%\": isNaN,\n      \"%IteratorPrototype%\": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,\n      \"%JSON%\": typeof JSON === \"object\" ? JSON : undefined2,\n      \"%Map%\": typeof Map === \"undefined\" ? undefined2 : Map,\n      \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),\n      \"%Math%\": Math,\n      \"%Number%\": Number,\n      \"%Object%\": Object,\n      \"%parseFloat%\": parseFloat,\n      \"%parseInt%\": parseInt,\n      \"%Promise%\": typeof Promise === \"undefined\" ? undefined2 : Promise,\n      \"%Proxy%\": typeof Proxy === \"undefined\" ? undefined2 : Proxy,\n      \"%RangeError%\": RangeError,\n      \"%ReferenceError%\": ReferenceError,\n      \"%Reflect%\": typeof Reflect === \"undefined\" ? undefined2 : Reflect,\n      \"%RegExp%\": RegExp,\n      \"%Set%\": typeof Set === \"undefined\" ? undefined2 : Set,\n      \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),\n      \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? undefined2 : SharedArrayBuffer,\n      \"%String%\": String,\n      \"%StringIteratorPrototype%\": hasSymbols ? getProto(\"\"[Symbol.iterator]()) : undefined2,\n      \"%Symbol%\": hasSymbols ? Symbol : undefined2,\n      \"%SyntaxError%\": $SyntaxError,\n      \"%ThrowTypeError%\": ThrowTypeError,\n      \"%TypedArray%\": TypedArray,\n      \"%TypeError%\": $TypeError,\n      \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? undefined2 : Uint8Array,\n      \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? undefined2 : Uint8ClampedArray,\n      \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? undefined2 : Uint16Array,\n      \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? undefined2 : Uint32Array,\n      \"%URIError%\": URIError,\n      \"%WeakMap%\": typeof WeakMap === \"undefined\" ? undefined2 : WeakMap,\n      \"%WeakRef%\": typeof WeakRef === \"undefined\" ? undefined2 : WeakRef,\n      \"%WeakSet%\": typeof WeakSet === \"undefined\" ? undefined2 : WeakSet\n    };\n    var doEval = function doEval2(name) {\n      var value;\n      if (name === \"%AsyncFunction%\") {\n        value = getEvalledConstructor(\"async function () {}\");\n      } else if (name === \"%GeneratorFunction%\") {\n        value = getEvalledConstructor(\"function* () {}\");\n      } else if (name === \"%AsyncGeneratorFunction%\") {\n        value = getEvalledConstructor(\"async function* () {}\");\n      } else if (name === \"%AsyncGenerator%\") {\n        var fn = doEval2(\"%AsyncGeneratorFunction%\");\n        if (fn) {\n          value = fn.prototype;\n        }\n      } else if (name === \"%AsyncIteratorPrototype%\") {\n        var gen = doEval2(\"%AsyncGenerator%\");\n        if (gen) {\n          value = getProto(gen.prototype);\n        }\n      }\n      INTRINSICS[name] = value;\n      return value;\n    };\n    var LEGACY_ALIASES = {\n      \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n      \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n      \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n      \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n      \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n      \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n      \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n      \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n      \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n      \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n      \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n      \"%DatePrototype%\": [\"Date\", \"prototype\"],\n      \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n      \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n      \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n      \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n      \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n      \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n      \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n      \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n      \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n      \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n      \"%JSONParse%\": [\"JSON\", \"parse\"],\n      \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n      \"%MapPrototype%\": [\"Map\", \"prototype\"],\n      \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n      \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n      \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n      \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n      \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n      \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n      \"%Promise_all%\": [\"Promise\", \"all\"],\n      \"%Promise_reject%\": [\"Promise\", \"reject\"],\n      \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n      \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n      \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n      \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n      \"%SetPrototype%\": [\"Set\", \"prototype\"],\n      \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n      \"%StringPrototype%\": [\"String\", \"prototype\"],\n      \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n      \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n      \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n      \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n      \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n      \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n      \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n      \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n      \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n      \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n      \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n    };\n    var bind = require_function_bind();\n    var hasOwn = require_src();\n    var $concat = bind.call(Function.call, Array.prototype.concat);\n    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);\n    var $replace = bind.call(Function.call, String.prototype.replace);\n    var $strSlice = bind.call(Function.call, String.prototype.slice);\n    var rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n    var reEscapeChar = /\\\\(\\\\)?/g;\n    var stringToPath = function stringToPath2(string) {\n      var first = $strSlice(string, 0, 1);\n      var last = $strSlice(string, -1);\n      if (first === \"%\" && last !== \"%\") {\n        throw new $SyntaxError(\"invalid intrinsic syntax, expected closing `%`\");\n      } else if (last === \"%\" && first !== \"%\") {\n        throw new $SyntaxError(\"invalid intrinsic syntax, expected opening `%`\");\n      }\n      var result = [];\n      $replace(string, rePropName, function(match, number, quote, subString) {\n        result[result.length] = quote ? $replace(subString, reEscapeChar, \"$1\") : number || match;\n      });\n      return result;\n    };\n    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {\n      var intrinsicName = name;\n      var alias;\n      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n        alias = LEGACY_ALIASES[intrinsicName];\n        intrinsicName = \"%\" + alias[0] + \"%\";\n      }\n      if (hasOwn(INTRINSICS, intrinsicName)) {\n        var value = INTRINSICS[intrinsicName];\n        if (value === needsEval) {\n          value = doEval(intrinsicName);\n        }\n        if (typeof value === \"undefined\" && !allowMissing) {\n          throw new $TypeError(\"intrinsic \" + name + \" exists, but is not available. Please file an issue!\");\n        }\n        return {\n          alias,\n          name: intrinsicName,\n          value\n        };\n      }\n      throw new $SyntaxError(\"intrinsic \" + name + \" does not exist!\");\n    };\n    module2.exports = function GetIntrinsic(name, allowMissing) {\n      if (typeof name !== \"string\" || name.length === 0) {\n        throw new $TypeError(\"intrinsic name must be a non-empty string\");\n      }\n      if (arguments.length > 1 && typeof allowMissing !== \"boolean\") {\n        throw new $TypeError('\"allowMissing\" argument must be a boolean');\n      }\n      var parts = stringToPath(name);\n      var intrinsicBaseName = parts.length > 0 ? parts[0] : \"\";\n      var intrinsic = getBaseIntrinsic(\"%\" + intrinsicBaseName + \"%\", allowMissing);\n      var intrinsicRealName = intrinsic.name;\n      var value = intrinsic.value;\n      var skipFurtherCaching = false;\n      var alias = intrinsic.alias;\n      if (alias) {\n        intrinsicBaseName = alias[0];\n        $spliceApply(parts, $concat([0, 1], alias));\n      }\n      for (var i = 1, isOwn = true; i < parts.length; i += 1) {\n        var part = parts[i];\n        var first = $strSlice(part, 0, 1);\n        var last = $strSlice(part, -1);\n        if ((first === '\"' || first === \"'\" || first === \"`\" || (last === '\"' || last === \"'\" || last === \"`\")) && first !== last) {\n          throw new $SyntaxError(\"property names with quotes must have matching quotes\");\n        }\n        if (part === \"constructor\" || !isOwn) {\n          skipFurtherCaching = true;\n        }\n        intrinsicBaseName += \".\" + part;\n        intrinsicRealName = \"%\" + intrinsicBaseName + \"%\";\n        if (hasOwn(INTRINSICS, intrinsicRealName)) {\n          value = INTRINSICS[intrinsicRealName];\n        } else if (value != null) {\n          if (!(part in value)) {\n            if (!allowMissing) {\n              throw new $TypeError(\"base intrinsic for \" + name + \" exists, but the property is not available.\");\n            }\n            return void 0;\n          }\n          if ($gOPD && i + 1 >= parts.length) {\n            var desc = $gOPD(value, part);\n            isOwn = !!desc;\n            if (isOwn && \"get\" in desc && !(\"originalValue\" in desc.get)) {\n              value = desc.get;\n            } else {\n              value = value[part];\n            }\n          } else {\n            isOwn = hasOwn(value, part);\n            value = value[part];\n          }\n          if (isOwn && !skipFurtherCaching) {\n            INTRINSICS[intrinsicRealName] = value;\n          }\n        }\n      }\n      return value;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-property-descriptors-npm-1.0.0-56289b918d-a6d3f0a266.zip/node_modules/has-property-descriptors/index.js\nvar require_has_property_descriptors = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-property-descriptors-npm-1.0.0-56289b918d-a6d3f0a266.zip/node_modules/has-property-descriptors/index.js\"(exports, module2) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $defineProperty = GetIntrinsic(\"%Object.defineProperty%\", true);\n    var hasPropertyDescriptors = function hasPropertyDescriptors2() {\n      if ($defineProperty) {\n        try {\n          $defineProperty({}, \"a\", { value: 1 });\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n      return false;\n    };\n    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n      if (!hasPropertyDescriptors()) {\n        return null;\n      }\n      try {\n        return $defineProperty([], \"length\", { value: 1 }).length !== 1;\n      } catch (e) {\n        return true;\n      }\n    };\n    module2.exports = hasPropertyDescriptors;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/define-properties-npm-1.1.4-85ee575655-ce0aef3f9e.zip/node_modules/define-properties/index.js\nvar require_define_properties = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/define-properties-npm-1.1.4-85ee575655-ce0aef3f9e.zip/node_modules/define-properties/index.js\"(exports, module2) {\n    \"use strict\";\n    var keys = require_object_keys();\n    var hasSymbols = typeof Symbol === \"function\" && typeof Symbol(\"foo\") === \"symbol\";\n    var toStr = Object.prototype.toString;\n    var concat = Array.prototype.concat;\n    var origDefineProperty = Object.defineProperty;\n    var isFunction = function(fn) {\n      return typeof fn === \"function\" && toStr.call(fn) === \"[object Function]\";\n    };\n    var hasPropertyDescriptors = require_has_property_descriptors()();\n    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;\n    var defineProperty = function(object, name, value, predicate) {\n      if (name in object && (!isFunction(predicate) || !predicate())) {\n        return;\n      }\n      if (supportsDescriptors) {\n        origDefineProperty(object, name, {\n          configurable: true,\n          enumerable: false,\n          value,\n          writable: true\n        });\n      } else {\n        object[name] = value;\n      }\n    };\n    var defineProperties = function(object, map) {\n      var predicates = arguments.length > 2 ? arguments[2] : {};\n      var props = keys(map);\n      if (hasSymbols) {\n        props = concat.call(props, Object.getOwnPropertySymbols(map));\n      }\n      for (var i = 0; i < props.length; i += 1) {\n        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n      }\n    };\n    defineProperties.supportsDescriptors = !!supportsDescriptors;\n    module2.exports = defineProperties;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/call-bind-npm-1.0.2-c957124861-f8e31de9d1.zip/node_modules/call-bind/index.js\nvar require_call_bind = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/call-bind-npm-1.0.2-c957124861-f8e31de9d1.zip/node_modules/call-bind/index.js\"(exports, module2) {\n    \"use strict\";\n    var bind = require_function_bind();\n    var GetIntrinsic = require_get_intrinsic();\n    var $apply = GetIntrinsic(\"%Function.prototype.apply%\");\n    var $call = GetIntrinsic(\"%Function.prototype.call%\");\n    var $reflectApply = GetIntrinsic(\"%Reflect.apply%\", true) || bind.call($call, $apply);\n    var $gOPD = GetIntrinsic(\"%Object.getOwnPropertyDescriptor%\", true);\n    var $defineProperty = GetIntrinsic(\"%Object.defineProperty%\", true);\n    var $max = GetIntrinsic(\"%Math.max%\");\n    if ($defineProperty) {\n      try {\n        $defineProperty({}, \"a\", { value: 1 });\n      } catch (e) {\n        $defineProperty = null;\n      }\n    }\n    module2.exports = function callBind(originalFunction) {\n      var func = $reflectApply(bind, $call, arguments);\n      if ($gOPD && $defineProperty) {\n        var desc = $gOPD(func, \"length\");\n        if (desc.configurable) {\n          $defineProperty(func, \"length\", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });\n        }\n      }\n      return func;\n    };\n    var applyBind = function applyBind2() {\n      return $reflectApply(bind, $apply, arguments);\n    };\n    if ($defineProperty) {\n      $defineProperty(module2.exports, \"apply\", { value: applyBind });\n    } else {\n      module2.exports.apply = applyBind;\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/call-bind-npm-1.0.2-c957124861-f8e31de9d1.zip/node_modules/call-bind/callBound.js\nvar require_callBound = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/call-bind-npm-1.0.2-c957124861-f8e31de9d1.zip/node_modules/call-bind/callBound.js\"(exports, module2) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var callBind = require_call_bind();\n    var $indexOf = callBind(GetIntrinsic(\"String.prototype.indexOf\"));\n    module2.exports = function callBoundIntrinsic(name, allowMissing) {\n      var intrinsic = GetIntrinsic(name, !!allowMissing);\n      if (typeof intrinsic === \"function\" && $indexOf(name, \".prototype.\") > -1) {\n        return callBind(intrinsic);\n      }\n      return intrinsic;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/implementation.js\nvar require_implementation3 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var keys = require_object_keys();\n    var canBeObject = function(obj) {\n      return typeof obj !== \"undefined\" && obj !== null;\n    };\n    var hasSymbols = require_shams()();\n    var callBound = require_callBound();\n    var toObject = Object;\n    var $push = callBound(\"Array.prototype.push\");\n    var $propIsEnumerable = callBound(\"Object.prototype.propertyIsEnumerable\");\n    var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;\n    module2.exports = function assign(target, source1) {\n      if (!canBeObject(target)) {\n        throw new TypeError(\"target must be an object\");\n      }\n      var objTarget = toObject(target);\n      var s, source, i, props, syms, value, key;\n      for (s = 1; s < arguments.length; ++s) {\n        source = toObject(arguments[s]);\n        props = keys(source);\n        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);\n        if (getSymbols) {\n          syms = getSymbols(source);\n          for (i = 0; i < syms.length; ++i) {\n            key = syms[i];\n            if ($propIsEnumerable(source, key)) {\n              $push(props, key);\n            }\n          }\n        }\n        for (i = 0; i < props.length; ++i) {\n          key = props[i];\n          value = source[key];\n          if ($propIsEnumerable(source, key)) {\n            objTarget[key] = value;\n          }\n        }\n      }\n      return objTarget;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/polyfill.js\nvar require_polyfill = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/polyfill.js\"(exports, module2) {\n    \"use strict\";\n    var implementation = require_implementation3();\n    var lacksProperEnumerationOrder = function() {\n      if (!Object.assign) {\n        return false;\n      }\n      var str = \"abcdefghijklmnopqrst\";\n      var letters = str.split(\"\");\n      var map = {};\n      for (var i = 0; i < letters.length; ++i) {\n        map[letters[i]] = letters[i];\n      }\n      var obj = Object.assign({}, map);\n      var actual = \"\";\n      for (var k in obj) {\n        actual += k;\n      }\n      return str !== actual;\n    };\n    var assignHasPendingExceptions = function() {\n      if (!Object.assign || !Object.preventExtensions) {\n        return false;\n      }\n      var thrower = Object.preventExtensions({ 1: 2 });\n      try {\n        Object.assign(thrower, \"xy\");\n      } catch (e) {\n        return thrower[1] === \"y\";\n      }\n      return false;\n    };\n    module2.exports = function getPolyfill() {\n      if (!Object.assign) {\n        return implementation;\n      }\n      if (lacksProperEnumerationOrder()) {\n        return implementation;\n      }\n      if (assignHasPendingExceptions()) {\n        return implementation;\n      }\n      return Object.assign;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/shim.js\nvar require_shim = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/shim.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var getPolyfill = require_polyfill();\n    module2.exports = function shimAssign() {\n      var polyfill = getPolyfill();\n      define(Object, { assign: polyfill }, { assign: function() {\n        return Object.assign !== polyfill;\n      } });\n      return polyfill;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/index.js\nvar require_object = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.assign-npm-4.1.2-d52edada1c-d621d832ed.zip/node_modules/object.assign/index.js\"(exports, module2) {\n    \"use strict\";\n    var defineProperties = require_define_properties();\n    var callBind = require_call_bind();\n    var implementation = require_implementation3();\n    var getPolyfill = require_polyfill();\n    var shim = require_shim();\n    var polyfill = callBind.apply(getPolyfill());\n    var bound = function assign(target, source1) {\n      return polyfill(Object, arguments);\n    };\n    defineProperties(bound, {\n      getPolyfill,\n      implementation,\n      shim\n    });\n    module2.exports = bound;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-exact-npm-1.2.0-4664209648-21676a16d5.zip/node_modules/prop-types-exact/build/helpers/isPlainObject.js\nvar require_isPlainObject = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-exact-npm-1.2.0-4664209648-21676a16d5.zip/node_modules/prop-types-exact/build/helpers/isPlainObject.js\"(exports, module2) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n      return typeof obj;\n    } : function(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n    exports[\"default\"] = isPlainObject;\n    function isPlainObject(x) {\n      return x && (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && !Array.isArray(x);\n    }\n    module2.exports = exports[\"default\"];\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-exact-npm-1.2.0-4664209648-21676a16d5.zip/node_modules/prop-types-exact/build/index.js\nvar require_build = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/prop-types-exact-npm-1.2.0-4664209648-21676a16d5.zip/node_modules/prop-types-exact/build/index.js\"(exports, module2) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = forbidExtraProps;\n    var _object = require_object();\n    var _object2 = _interopRequireDefault(_object);\n    var _has = require_src();\n    var _has2 = _interopRequireDefault(_has);\n    var _isPlainObject = require_isPlainObject();\n    var _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var zeroWidthSpace = \"\\u200B\";\n    var specialProperty = \"prop-types-exact: \" + zeroWidthSpace;\n    var semaphore = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](specialProperty) : specialProperty;\n    function brand(fn) {\n      return (0, _object2[\"default\"])(fn, _defineProperty({}, specialProperty, semaphore));\n    }\n    function isBranded(value) {\n      return value && value[specialProperty] === semaphore;\n    }\n    function forbidExtraProps(propTypes) {\n      if (!(0, _isPlainObject2[\"default\"])(propTypes)) {\n        throw new TypeError(\"given propTypes must be an object\");\n      }\n      if ((0, _has2[\"default\"])(propTypes, specialProperty) && !isBranded(propTypes[specialProperty])) {\n        throw new TypeError(\"Against all odds, you created a propType for a prop that uses both the zero-width space and our custom string - which, sadly, conflicts with `prop-types-exact`\");\n      }\n      return (0, _object2[\"default\"])({}, propTypes, _defineProperty({}, specialProperty, brand(function() {\n        function forbidUnknownProps(props, _, componentName) {\n          var unknownProps = Object.keys(props).filter(function(prop) {\n            return !(0, _has2[\"default\"])(propTypes, prop);\n          });\n          if (unknownProps.length > 0) {\n            return new TypeError(String(componentName) + \": unknown props found: \" + String(unknownProps.join(\", \")));\n          }\n          return null;\n        }\n        return forbidUnknownProps;\n      }())));\n    }\n    module2.exports = exports[\"default\"];\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/wrapValidator.js\nvar require_wrapValidator = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/wrapValidator.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = wrapValidator;\n    var _object = _interopRequireDefault(require_object());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function wrapValidator(validator, typeName) {\n      var typeChecker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n      return (0, _object[\"default\"])(validator.bind(), {\n        typeName,\n        typeChecker,\n        isRequired: (0, _object[\"default\"])(validator.isRequired.bind(), {\n          typeName,\n          typeChecker,\n          typeRequired: true\n        })\n      });\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/and.js\nvar require_and = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/and.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = andValidator;\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function andValidator(validators) {\n      var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"and\";\n      if (!Array.isArray(validators)) {\n        throw new TypeError(\"and: 2 or more validators are required\");\n      }\n      if (validators.length <= 1) {\n        throw new RangeError(\"and: 2 or more validators are required\");\n      }\n      var validator = function and() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var firstError = null;\n        validators.some(function(validatorFn) {\n          firstError = validatorFn.apply(void 0, args);\n          return firstError != null;\n        });\n        return firstError == null ? null : firstError;\n      };\n      validator.isRequired = function andIsRequired() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        var firstError = null;\n        validators.some(function(validatorFn) {\n          firstError = validatorFn.isRequired.apply(validatorFn, args);\n          return firstError != null;\n        });\n        return firstError == null ? null : firstError;\n      };\n      return (0, _wrapValidator[\"default\"])(validator, name, validators);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/5/CheckObjectCoercible.js\nvar require_CheckObjectCoercible = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/5/CheckObjectCoercible.js\"(exports, module2) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $TypeError = GetIntrinsic(\"%TypeError%\");\n    module2.exports = function CheckObjectCoercible(value, optMessage) {\n      if (value == null) {\n        throw new $TypeError(optMessage || \"Cannot call method on \" + value);\n      }\n      return value;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/RequireObjectCoercible.js\nvar require_RequireObjectCoercible = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/RequireObjectCoercible.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = require_CheckObjectCoercible();\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/implementation.js\nvar require_implementation4 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var RequireObjectCoercible = require_RequireObjectCoercible();\n    var callBound = require_callBound();\n    var $isEnumerable = callBound(\"Object.prototype.propertyIsEnumerable\");\n    var $push = callBound(\"Array.prototype.push\");\n    module2.exports = function entries(O) {\n      var obj = RequireObjectCoercible(O);\n      var entrys = [];\n      for (var key in obj) {\n        if ($isEnumerable(obj, key)) {\n          $push(entrys, [key, obj[key]]);\n        }\n      }\n      return entrys;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/polyfill.js\nvar require_polyfill2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/polyfill.js\"(exports, module2) {\n    \"use strict\";\n    var implementation = require_implementation4();\n    module2.exports = function getPolyfill() {\n      return typeof Object.entries === \"function\" ? Object.entries : implementation;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/shim.js\nvar require_shim2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/shim.js\"(exports, module2) {\n    \"use strict\";\n    var getPolyfill = require_polyfill2();\n    var define = require_define_properties();\n    module2.exports = function shimEntries() {\n      var polyfill = getPolyfill();\n      define(Object, { entries: polyfill }, {\n        entries: function testEntries() {\n          return Object.entries !== polyfill;\n        }\n      });\n      return polyfill;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/index.js\nvar require_object2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.entries-npm-1.1.5-7a8fcbc43e-d658696f74.zip/node_modules/object.entries/index.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var callBind = require_call_bind();\n    var implementation = require_implementation4();\n    var getPolyfill = require_polyfill2();\n    var shim = require_shim2();\n    var polyfill = callBind(getPolyfill(), Object);\n    define(polyfill, {\n      getPolyfill,\n      implementation,\n      shim\n    });\n    module2.exports = polyfill;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/isPlainObject.js\nvar require_isPlainObject2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/isPlainObject.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _isPlainObject = _interopRequireDefault(require_isPlainObject());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var _default = _isPlainObject[\"default\"];\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/shape.js\nvar require_shape = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/shape.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = shapeValidator;\n    var _isPlainObject = _interopRequireDefault(require_isPlainObject2());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function shapeValidator(shapeTypes) {\n      if (!(0, _isPlainObject[\"default\"])(shapeTypes)) {\n        throw new TypeError(\"shape must be a normal object\");\n      }\n      function shape(props, propName, componentName, location) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return null;\n        }\n        for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n          rest[_key - 4] = arguments[_key];\n        }\n        for (var key in shapeTypes) {\n          var checker = shapeTypes[key];\n          if (checker) {\n            var error = checker.apply(void 0, [propValue, key, componentName, location].concat(rest));\n            if (error) {\n              return error;\n            }\n          }\n        }\n        return null;\n      }\n      shape.isRequired = function shapeRequired(props, propName, componentName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return new TypeError(\"\".concat(componentName, \": \").concat(propName, \" is required.\"));\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return shape.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(shape, \"shape\", shapeTypes);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/isPrimitive.js\nvar require_isPrimitive = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/isPrimitive.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = isPrimitive;\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    function isPrimitive(x) {\n      return !x || _typeof(x) !== \"object\" && typeof x !== \"function\";\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/valuesOf.js\nvar require_valuesOf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/valuesOf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = valuesOfValidator;\n    var _isPrimitive = _interopRequireDefault(require_isPrimitive());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function valuesOfValidator(propType) {\n      if (typeof propType !== \"function\") {\n        throw new TypeError(\"objectOf: propType must be a function\");\n      }\n      var validator = function valuesOf(props, propName, componentName, location, propFullName) {\n        for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n          rest[_key - 5] = arguments[_key];\n        }\n        var propValue = props[propName];\n        if (propValue == null || (0, _isPrimitive[\"default\"])(propValue)) {\n          return null;\n        }\n        var firstError;\n        Object.keys(propValue).some(function(key) {\n          firstError = propType.apply(void 0, [propValue, key, componentName, location, \"\".concat(propFullName, \".\").concat(key)].concat(rest));\n          return firstError;\n        });\n        return firstError || null;\n      };\n      validator.isRequired = function valuesOfRequired(props, propName, componentName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return new TypeError(\"\".concat(componentName, \": \").concat(propName, \" is required.\"));\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return validator.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"valuesOf\", propType);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/between.js\nvar require_between = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/between.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = betweenValidator;\n    var _object = _interopRequireDefault(require_object2());\n    var _shape = _interopRequireDefault(require_shape());\n    var _valuesOf = _interopRequireDefault(require_valuesOf());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly)\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _slicedToArray(arr, i) {\n      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n    }\n    function _nonIterableRest() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o)\n        return;\n      if (typeof o === \"string\")\n        return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor)\n        n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\")\n        return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n        return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length)\n        len = arr.length;\n      for (var i = 0, arr2 = new Array(len); i < len; i++) {\n        arr2[i] = arr[i];\n      }\n      return arr2;\n    }\n    function _iterableToArrayLimit(arr, i) {\n      if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr)))\n        return;\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = void 0;\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i)\n            break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"] != null)\n            _i[\"return\"]();\n        } finally {\n          if (_d)\n            throw _e;\n        }\n      }\n      return _arr;\n    }\n    function _arrayWithHoles(arr) {\n      if (Array.isArray(arr))\n        return arr;\n    }\n    function number(props, propName, componentName) {\n      var value = props[propName];\n      if (typeof value === \"number\" && !isNaN(value)) {\n        return null;\n      }\n      return new TypeError(\"\".concat(componentName, \": \").concat(propName, \" must be a non-NaN number.\"));\n    }\n    function numberOrPropsFunc(props, propName) {\n      var value = props[propName];\n      if (typeof value === \"function\") {\n        return null;\n      }\n      if (typeof value === \"number\" && !isNaN(value)) {\n        return null;\n      }\n      return new TypeError(\"\".concat(propName, \": a function, or a non-NaN number is required\"));\n    }\n    function lowerCompare(value, _ref) {\n      var gt = _ref.gt, gte = _ref.gte;\n      if (typeof gt === \"number\") {\n        return value > gt;\n      }\n      if (typeof gte === \"number\") {\n        return value >= gte;\n      }\n      return true;\n    }\n    function upperCompare(value, _ref2) {\n      var lt = _ref2.lt, lte = _ref2.lte;\n      if (typeof lt === \"number\") {\n        return value < lt;\n      }\n      if (typeof lte === \"number\") {\n        return value <= lte;\n      }\n      return true;\n    }\n    function greaterThanError(_ref3) {\n      var gt = _ref3.gt, gte = _ref3.gte;\n      if (typeof gt === \"number\") {\n        return \"greater than \".concat(gt);\n      }\n      if (typeof gte === \"number\") {\n        return \"greater than or equal to \".concat(gte);\n      }\n      return \"\";\n    }\n    function lessThanError(_ref4) {\n      var lt = _ref4.lt, lte = _ref4.lte;\n      if (typeof lt === \"number\") {\n        return \"less than \".concat(lt);\n      }\n      if (typeof lte === \"number\") {\n        return \"less than or equal to \".concat(lte);\n      }\n      return \"\";\n    }\n    function errorMessage(componentName, propName, opts) {\n      var errors = [greaterThanError(opts), lessThanError(opts)].filter(Boolean).join(\" and \");\n      return \"\".concat(componentName, \": \").concat(propName, \" must be \").concat(errors);\n    }\n    function propsThunkify(opts) {\n      return (0, _object[\"default\"])(opts).reduce(function(acc, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2), key = _ref6[0], value = _ref6[1];\n        var numberThunk = typeof value === \"number\" ? function() {\n          return value;\n        } : value;\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, numberThunk));\n      }, {});\n    }\n    function invokeWithProps(optsThunks, props) {\n      return (0, _object[\"default\"])(optsThunks).reduce(function(acc, _ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2), key = _ref8[0], thunk = _ref8[1];\n        var value = thunk(props);\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, value));\n      }, {});\n    }\n    var argValidators = [(0, _shape[\"default\"])({\n      lt: numberOrPropsFunc,\n      gt: numberOrPropsFunc\n    }).isRequired, (0, _shape[\"default\"])({\n      lte: numberOrPropsFunc,\n      gt: numberOrPropsFunc\n    }).isRequired, (0, _shape[\"default\"])({\n      lt: numberOrPropsFunc,\n      gte: numberOrPropsFunc\n    }).isRequired, (0, _shape[\"default\"])({\n      lte: numberOrPropsFunc,\n      gte: numberOrPropsFunc\n    }).isRequired, (0, _shape[\"default\"])({\n      lt: numberOrPropsFunc\n    }).isRequired, (0, _shape[\"default\"])({\n      lte: numberOrPropsFunc\n    }).isRequired, (0, _shape[\"default\"])({\n      gt: numberOrPropsFunc\n    }).isRequired, (0, _shape[\"default\"])({\n      gte: numberOrPropsFunc\n    }).isRequired];\n    function argValidator(props, propName) {\n      return argValidators.every(function(validator) {\n        return !!validator(props, propName);\n      });\n    }\n    var thunkValueValidator = (0, _valuesOf[\"default\"])(number).isRequired;\n    function betweenValidator(options) {\n      var argError = argValidator({\n        options\n      }, \"options\");\n      if (argError) {\n        throw new TypeError(\"between: only one of the pairs of `lt`/`lte`, and `gt`/`gte`, may be supplied, and at least one pair must be provided.\");\n      }\n      var optsThunks = propsThunkify(options);\n      var validator = function between(props, propName, componentName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return null;\n        }\n        if (typeof propValue !== \"number\") {\n          return new RangeError(\"\".concat(componentName, \": \").concat(propName, ' must be a number, got \"').concat(_typeof(propValue), '\"'));\n        }\n        var opts = invokeWithProps(optsThunks, props);\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        var thunkValuesError = thunkValueValidator.apply(void 0, [_defineProperty({}, propName, opts), propName, componentName].concat(rest));\n        if (thunkValuesError) {\n          return thunkValuesError;\n        }\n        if (!lowerCompare(propValue, opts) || !upperCompare(propValue, opts)) {\n          return new RangeError(errorMessage(componentName, propName, opts));\n        }\n        return null;\n      };\n      validator.isRequired = function betweenRequired(props, propName, componentName) {\n        var propValue = props[propName];\n        if (typeof propValue !== \"number\") {\n          return new RangeError(\"\".concat(componentName, \": \").concat(propName, ' must be a number, got \"').concat(_typeof(propValue), '\"'));\n        }\n        var opts = invokeWithProps(optsThunks, props);\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        var thunkValuesError = thunkValueValidator.apply(void 0, [_defineProperty({}, propName, opts), propName, componentName].concat(rest));\n        if (thunkValuesError) {\n          return thunkValuesError;\n        }\n        if (!lowerCompare(propValue, opts) || !upperCompare(propValue, opts)) {\n          return new RangeError(errorMessage(componentName, propName, opts));\n        }\n        return null;\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"between\", options);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/booleanSome.js\nvar require_booleanSome = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/booleanSome.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = booleanSomeValidator;\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function booleanSomeValidator() {\n      for (var _len = arguments.length, notAllPropsFalse = new Array(_len), _key = 0; _key < _len; _key++) {\n        notAllPropsFalse[_key] = arguments[_key];\n      }\n      if (notAllPropsFalse.length < 1) {\n        throw new TypeError(\"at least one prop (one of which must be `true`) is required\");\n      }\n      if (!notAllPropsFalse.every(function(x) {\n        return typeof x === \"string\";\n      })) {\n        throw new TypeError(\"all booleanSome props must be strings\");\n      }\n      var propsList = notAllPropsFalse.join(\", or \");\n      var validator = function booleanSome(props, propName, componentName) {\n        var countFalse = function countFalse2(count, prop) {\n          return count + (props[prop] === false ? 1 : 0);\n        };\n        var falsePropCount = notAllPropsFalse.reduce(countFalse, 0);\n        if (falsePropCount === notAllPropsFalse.length) {\n          return new Error(\"A \".concat(componentName, \" must have at least one of these boolean props be `true`: \").concat(propsList));\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return _propTypes.bool.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      validator.isRequired = function booleanSomeRequired(props, propName, componentName) {\n        var countFalse = function countFalse2(count, prop) {\n          return count + (props[prop] === false ? 1 : 0);\n        };\n        var falsePropCount = notAllPropsFalse.reduce(countFalse, 0);\n        if (falsePropCount === notAllPropsFalse.length) {\n          return new Error(\"A \".concat(componentName, \" must have at least one of these boolean props be `true`: \").concat(propsList));\n        }\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n          rest[_key3 - 3] = arguments[_key3];\n        }\n        return _propTypes.bool.isRequired.apply(_propTypes.bool, [props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"booleanSome: \".concat(propsList), notAllPropsFalse);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenHavePropXorChildren.js\nvar require_childrenHavePropXorChildren = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenHavePropXorChildren.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = childrenHavePropXorChildren;\n    var _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    function childrenHavePropXorChildren(prop) {\n      if (typeof prop !== \"string\" && _typeof(prop) !== \"symbol\") {\n        throw new TypeError(\"invalid prop: must be string or symbol\");\n      }\n      var validator = function childrenHavePropXorChildrenWithProp(_ref, _, componentName) {\n        var children = _ref.children;\n        var truthyChildrenCount = 0;\n        var propCount = 0;\n        var grandchildrenCount = 0;\n        _react[\"default\"].Children.forEach(children, function(child) {\n          if (!child) {\n            return;\n          }\n          truthyChildrenCount += 1;\n          if (child.props[prop]) {\n            propCount += 1;\n          }\n          if (_react[\"default\"].Children.count(child.props.children)) {\n            grandchildrenCount += 1;\n          }\n        });\n        if (propCount === truthyChildrenCount && grandchildrenCount === 0 || propCount === 0 && grandchildrenCount === truthyChildrenCount || propCount === 0 && grandchildrenCount === 0) {\n          return null;\n        }\n        return new TypeError(\"`\".concat(componentName, \"` requires children to all have prop \\u201C\").concat(prop, \"\\u201D, all have children, or all have neither.\"));\n      };\n      validator.isRequired = validator;\n      return (0, _wrapValidator[\"default\"])(validator, \"childrenHavePropXorChildrenWithProp:\".concat(prop), prop);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/renderableChildren.js\nvar require_renderableChildren = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/renderableChildren.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = renderableChildren;\n    var _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function renderableChildren(childrenProp) {\n      return _react[\"default\"].Children.toArray(childrenProp).filter(function(child) {\n        return child === 0 || child;\n      });\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenOf.js\nvar require_childrenOf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenOf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = childrenOf;\n    var _renderableChildren = _interopRequireDefault(require_renderableChildren());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly)\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function validateChildren(propType, children, props) {\n      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        rest[_key - 3] = arguments[_key];\n      }\n      var error;\n      children.some(function(child) {\n        error = propType.apply(void 0, [_objectSpread(_objectSpread({}, props), {}, {\n          children: child\n        }), \"children\"].concat(rest));\n        return error;\n      });\n      return error || null;\n    }\n    function childrenOf(propType) {\n      function childrenOfPropType(props, propName, componentName) {\n        if (propName !== \"children\") {\n          return new TypeError(\"\".concat(componentName, ' is using the childrenOf validator on non-children prop \"').concat(propName, '\"'));\n        }\n        var propValue = props[propName];\n        if (propValue == null) {\n          return null;\n        }\n        var children = (0, _renderableChildren[\"default\"])(propValue);\n        if (children.length === 0) {\n          return null;\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return validateChildren.apply(void 0, [propType, children, props, componentName].concat(rest));\n      }\n      childrenOfPropType.isRequired = function(props, propName, componentName) {\n        if (propName !== \"children\") {\n          return new TypeError(\"\".concat(componentName, ' is using the childrenOf validator on non-children prop \"').concat(propName, '\"'));\n        }\n        var children = (0, _renderableChildren[\"default\"])(props[propName]);\n        if (children.length === 0) {\n          return new TypeError(\"`\".concat(componentName, \"` requires at least one node of type \").concat(propType.typeName || propType.name));\n        }\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n          rest[_key3 - 3] = arguments[_key3];\n        }\n        return validateChildren.apply(void 0, [propType, children, props, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(childrenOfPropType, \"childrenOf\", propType);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToObject.js\nvar require_ToObject = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToObject.js\"(exports, module2) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $Object = GetIntrinsic(\"%Object%\");\n    var RequireObjectCoercible = require_RequireObjectCoercible();\n    module2.exports = function ToObject(value) {\n      RequireObjectCoercible(value);\n      return $Object(value);\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/maxSafeInteger.js\nvar require_maxSafeInteger = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/maxSafeInteger.js\"(exports, module2) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $Math = GetIntrinsic(\"%Math%\");\n    var $Number = GetIntrinsic(\"%Number%\");\n    module2.exports = $Number.MAX_SAFE_INTEGER || $Math.pow(2, 53) - 1;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/abs.js\nvar require_abs = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/abs.js\"(exports, module2) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $abs = GetIntrinsic(\"%Math.abs%\");\n    module2.exports = function abs(x) {\n      return $abs(x);\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/floor.js\nvar require_floor = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/floor.js\"(exports, module2) {\n    \"use strict\";\n    var $floor = Math.floor;\n    module2.exports = function floor(x) {\n      return $floor(x);\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/regexTester.js\nvar require_regexTester = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/regexTester.js\"(exports, module2) {\n    \"use strict\";\n    var callBound = require_callBound();\n    var $exec = callBound(\"RegExp.prototype.exec\");\n    module2.exports = function regexTester(regex) {\n      return function test(s) {\n        return $exec(regex, s) !== null;\n      };\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/isPrimitive.js\nvar require_isPrimitive2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/isPrimitive.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function isPrimitive(value) {\n      return value === null || typeof value !== \"function\" && typeof value !== \"object\";\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-to-primitive-npm-1.2.1-b7a7eac6c5-4ead6671a2.zip/node_modules/es-to-primitive/helpers/isPrimitive.js\nvar require_isPrimitive3 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-to-primitive-npm-1.2.1-b7a7eac6c5-4ead6671a2.zip/node_modules/es-to-primitive/helpers/isPrimitive.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function isPrimitive(value) {\n      return value === null || typeof value !== \"function\" && typeof value !== \"object\";\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-callable-npm-1.2.4-03fc17459c-1a28d57dc4.zip/node_modules/is-callable/index.js\nvar require_is_callable = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-callable-npm-1.2.4-03fc17459c-1a28d57dc4.zip/node_modules/is-callable/index.js\"(exports, module2) {\n    \"use strict\";\n    var fnToStr = Function.prototype.toString;\n    var reflectApply = typeof Reflect === \"object\" && Reflect !== null && Reflect.apply;\n    var badArrayLike;\n    var isCallableMarker;\n    if (typeof reflectApply === \"function\" && typeof Object.defineProperty === \"function\") {\n      try {\n        badArrayLike = Object.defineProperty({}, \"length\", {\n          get: function() {\n            throw isCallableMarker;\n          }\n        });\n        isCallableMarker = {};\n        reflectApply(function() {\n          throw 42;\n        }, null, badArrayLike);\n      } catch (_) {\n        if (_ !== isCallableMarker) {\n          reflectApply = null;\n        }\n      }\n    } else {\n      reflectApply = null;\n    }\n    var constructorRegex = /^\\s*class\\b/;\n    var isES6ClassFn = function isES6ClassFunction(value) {\n      try {\n        var fnStr = fnToStr.call(value);\n        return constructorRegex.test(fnStr);\n      } catch (e) {\n        return false;\n      }\n    };\n    var tryFunctionObject = function tryFunctionToStr(value) {\n      try {\n        if (isES6ClassFn(value)) {\n          return false;\n        }\n        fnToStr.call(value);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n    var toStr = Object.prototype.toString;\n    var fnClass = \"[object Function]\";\n    var genClass = \"[object GeneratorFunction]\";\n    var hasToStringTag = typeof Symbol === \"function\" && !!Symbol.toStringTag;\n    var documentDotAll = typeof document === \"object\" && typeof document.all === \"undefined\" && document.all !== void 0 ? document.all : {};\n    module2.exports = reflectApply ? function isCallable(value) {\n      if (value === documentDotAll) {\n        return true;\n      }\n      if (!value) {\n        return false;\n      }\n      if (typeof value !== \"function\" && typeof value !== \"object\") {\n        return false;\n      }\n      if (typeof value === \"function\" && !value.prototype) {\n        return true;\n      }\n      try {\n        reflectApply(value, null, badArrayLike);\n      } catch (e) {\n        if (e !== isCallableMarker) {\n          return false;\n        }\n      }\n      return !isES6ClassFn(value);\n    } : function isCallable(value) {\n      if (value === documentDotAll) {\n        return true;\n      }\n      if (!value) {\n        return false;\n      }\n      if (typeof value !== \"function\" && typeof value !== \"object\") {\n        return false;\n      }\n      if (typeof value === \"function\" && !value.prototype) {\n        return true;\n      }\n      if (hasToStringTag) {\n        return tryFunctionObject(value);\n      }\n      if (isES6ClassFn(value)) {\n        return false;\n      }\n      var strClass = toStr.call(value);\n      return strClass === fnClass || strClass === genClass;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-tostringtag-npm-1.0.0-b1fcf3ab55-cc12eb28cb.zip/node_modules/has-tostringtag/shams.js\nvar require_shams2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/has-tostringtag-npm-1.0.0-b1fcf3ab55-cc12eb28cb.zip/node_modules/has-tostringtag/shams.js\"(exports, module2) {\n    \"use strict\";\n    var hasSymbols = require_shams();\n    module2.exports = function hasToStringTagShams() {\n      return hasSymbols() && !!Symbol.toStringTag;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-date-object-npm-1.0.5-88f3d08b5e-baa9077cdf.zip/node_modules/is-date-object/index.js\nvar require_is_date_object = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-date-object-npm-1.0.5-88f3d08b5e-baa9077cdf.zip/node_modules/is-date-object/index.js\"(exports, module2) {\n    \"use strict\";\n    var getDay = Date.prototype.getDay;\n    var tryDateObject = function tryDateGetDayCall(value) {\n      try {\n        getDay.call(value);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n    var toStr = Object.prototype.toString;\n    var dateClass = \"[object Date]\";\n    var hasToStringTag = require_shams2()();\n    module2.exports = function isDateObject(value) {\n      if (typeof value !== \"object\" || value === null) {\n        return false;\n      }\n      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-symbol-npm-1.0.4-eb9baac703-92805812ef.zip/node_modules/is-symbol/index.js\nvar require_is_symbol = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-symbol-npm-1.0.4-eb9baac703-92805812ef.zip/node_modules/is-symbol/index.js\"(exports, module2) {\n    \"use strict\";\n    var toStr = Object.prototype.toString;\n    var hasSymbols = require_has_symbols()();\n    if (hasSymbols) {\n      symToStr = Symbol.prototype.toString;\n      symStringRegex = /^Symbol\\(.*\\)$/;\n      isSymbolObject = function isRealSymbolObject(value) {\n        if (typeof value.valueOf() !== \"symbol\") {\n          return false;\n        }\n        return symStringRegex.test(symToStr.call(value));\n      };\n      module2.exports = function isSymbol(value) {\n        if (typeof value === \"symbol\") {\n          return true;\n        }\n        if (toStr.call(value) !== \"[object Symbol]\") {\n          return false;\n        }\n        try {\n          return isSymbolObject(value);\n        } catch (e) {\n          return false;\n        }\n      };\n    } else {\n      module2.exports = function isSymbol(value) {\n        return false;\n      };\n    }\n    var symToStr;\n    var symStringRegex;\n    var isSymbolObject;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-to-primitive-npm-1.2.1-b7a7eac6c5-4ead6671a2.zip/node_modules/es-to-primitive/es2015.js\nvar require_es2015 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-to-primitive-npm-1.2.1-b7a7eac6c5-4ead6671a2.zip/node_modules/es-to-primitive/es2015.js\"(exports, module2) {\n    \"use strict\";\n    var hasSymbols = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\";\n    var isPrimitive = require_isPrimitive3();\n    var isCallable = require_is_callable();\n    var isDate = require_is_date_object();\n    var isSymbol = require_is_symbol();\n    var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {\n      if (typeof O === \"undefined\" || O === null) {\n        throw new TypeError(\"Cannot call method on \" + O);\n      }\n      if (typeof hint !== \"string\" || hint !== \"number\" && hint !== \"string\") {\n        throw new TypeError('hint must be \"string\" or \"number\"');\n      }\n      var methodNames = hint === \"string\" ? [\"toString\", \"valueOf\"] : [\"valueOf\", \"toString\"];\n      var method, result, i;\n      for (i = 0; i < methodNames.length; ++i) {\n        method = O[methodNames[i]];\n        if (isCallable(method)) {\n          result = method.call(O);\n          if (isPrimitive(result)) {\n            return result;\n          }\n        }\n      }\n      throw new TypeError(\"No default value\");\n    };\n    var GetMethod = function GetMethod2(O, P) {\n      var func = O[P];\n      if (func !== null && typeof func !== \"undefined\") {\n        if (!isCallable(func)) {\n          throw new TypeError(func + \" returned for property \" + P + \" of object \" + O + \" is not a function\");\n        }\n        return func;\n      }\n      return void 0;\n    };\n    module2.exports = function ToPrimitive(input) {\n      if (isPrimitive(input)) {\n        return input;\n      }\n      var hint = \"default\";\n      if (arguments.length > 1) {\n        if (arguments[1] === String) {\n          hint = \"string\";\n        } else if (arguments[1] === Number) {\n          hint = \"number\";\n        }\n      }\n      var exoticToPrim;\n      if (hasSymbols) {\n        if (Symbol.toPrimitive) {\n          exoticToPrim = GetMethod(input, Symbol.toPrimitive);\n        } else if (isSymbol(input)) {\n          exoticToPrim = Symbol.prototype.valueOf;\n        }\n      }\n      if (typeof exoticToPrim !== \"undefined\") {\n        var result = exoticToPrim.call(input, hint);\n        if (isPrimitive(result)) {\n          return result;\n        }\n        throw new TypeError(\"unable to convert exotic object to primitive\");\n      }\n      if (hint === \"default\" && (isDate(input) || isSymbol(input))) {\n        hint = \"string\";\n      }\n      return ordinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToPrimitive.js\nvar require_ToPrimitive = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToPrimitive.js\"(exports, module2) {\n    \"use strict\";\n    var toPrimitive = require_es2015();\n    module2.exports = function ToPrimitive(input) {\n      if (arguments.length > 1) {\n        return toPrimitive(input, arguments[1]);\n      }\n      return toPrimitive(input);\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToNumber.js\nvar require_ToNumber = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToNumber.js\"(exports, module2) {\n    \"use strict\";\n    var GetIntrinsic = require_get_intrinsic();\n    var $TypeError = GetIntrinsic(\"%TypeError%\");\n    var $Number = GetIntrinsic(\"%Number%\");\n    var $RegExp = GetIntrinsic(\"%RegExp%\");\n    var $parseInteger = GetIntrinsic(\"%parseInt%\");\n    var callBound = require_callBound();\n    var regexTester = require_regexTester();\n    var isPrimitive = require_isPrimitive2();\n    var $strSlice = callBound(\"String.prototype.slice\");\n    var isBinary = regexTester(/^0b[01]+$/i);\n    var isOctal = regexTester(/^0o[0-7]+$/i);\n    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);\n    var nonWS = [\"\\x85\", \"\\u200B\", \"\\uFFFE\"].join(\"\");\n    var nonWSregex = new $RegExp(\"[\" + nonWS + \"]\", \"g\");\n    var hasNonWS = regexTester(nonWSregex);\n    var ws = [\n      \"\t\\n\\v\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\",\n      \"\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\",\n      \"\\u2029\\uFEFF\"\n    ].join(\"\");\n    var trimRegex = new RegExp(\"(^[\" + ws + \"]+)|([\" + ws + \"]+$)\", \"g\");\n    var $replace = callBound(\"String.prototype.replace\");\n    var $trim = function(value) {\n      return $replace(value, trimRegex, \"\");\n    };\n    var ToPrimitive = require_ToPrimitive();\n    module2.exports = function ToNumber(argument) {\n      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);\n      if (typeof value === \"symbol\") {\n        throw new $TypeError(\"Cannot convert a Symbol value to a number\");\n      }\n      if (typeof value === \"bigint\") {\n        throw new $TypeError(\"Conversion from 'BigInt' to 'number' is not allowed.\");\n      }\n      if (typeof value === \"string\") {\n        if (isBinary(value)) {\n          return ToNumber($parseInteger($strSlice(value, 2), 2));\n        } else if (isOctal(value)) {\n          return ToNumber($parseInteger($strSlice(value, 2), 8));\n        } else if (hasNonWS(value) || isInvalidHexLiteral(value)) {\n          return NaN;\n        }\n        var trimmed = $trim(value);\n        if (trimmed !== value) {\n          return ToNumber(trimmed);\n        }\n      }\n      return $Number(value);\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/isNaN.js\nvar require_isNaN = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/isNaN.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = Number.isNaN || function isNaN2(a) {\n      return a !== a;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/isFinite.js\nvar require_isFinite = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/isFinite.js\"(exports, module2) {\n    \"use strict\";\n    var $isNaN = Number.isNaN || function(a) {\n      return a !== a;\n    };\n    module2.exports = Number.isFinite || function(x) {\n      return typeof x === \"number\" && !$isNaN(x) && x !== Infinity && x !== -Infinity;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/sign.js\nvar require_sign = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/helpers/sign.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function sign(number) {\n      return number >= 0 ? 1 : -1;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToIntegerOrInfinity.js\nvar require_ToIntegerOrInfinity = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToIntegerOrInfinity.js\"(exports, module2) {\n    \"use strict\";\n    var abs = require_abs();\n    var floor = require_floor();\n    var ToNumber = require_ToNumber();\n    var $isNaN = require_isNaN();\n    var $isFinite = require_isFinite();\n    var $sign = require_sign();\n    module2.exports = function ToIntegerOrInfinity(value) {\n      var number = ToNumber(value);\n      if ($isNaN(number) || number === 0) {\n        return 0;\n      }\n      if (!$isFinite(number)) {\n        return number;\n      }\n      return $sign(number) * floor(abs(number));\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToLength.js\nvar require_ToLength = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/ToLength.js\"(exports, module2) {\n    \"use strict\";\n    var MAX_SAFE_INTEGER = require_maxSafeInteger();\n    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();\n    module2.exports = function ToLength(argument) {\n      var len = ToIntegerOrInfinity(argument);\n      if (len <= 0) {\n        return 0;\n      }\n      if (len > MAX_SAFE_INTEGER) {\n        return MAX_SAFE_INTEGER;\n      }\n      return len;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/IsCallable.js\nvar require_IsCallable = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-abstract-npm-1.19.5-524a87d262-55199b0f17.zip/node_modules/es-abstract/2021/IsCallable.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = require_is_callable();\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/implementation.js\nvar require_implementation5 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var ToObject = require_ToObject();\n    var ToLength = require_ToLength();\n    var IsCallable = require_IsCallable();\n    module2.exports = function find(predicate) {\n      var list = ToObject(this);\n      var length = ToLength(list.length);\n      if (!IsCallable(predicate)) {\n        throw new TypeError(\"Array#find: predicate must be a function\");\n      }\n      if (length === 0) {\n        return void 0;\n      }\n      var thisArg;\n      if (arguments.length > 0) {\n        thisArg = arguments[1];\n      }\n      for (var i = 0, value; i < length; i++) {\n        value = list[i];\n        if (predicate.apply(thisArg, [value, i, list])) {\n          return value;\n        }\n      }\n      return void 0;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/polyfill.js\nvar require_polyfill3 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/polyfill.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function getPolyfill() {\n      var implemented = Array.prototype.find && [, 1].find(function() {\n        return true;\n      }) !== 1;\n      return implemented ? Array.prototype.find : require_implementation5();\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-shim-unscopables-npm-1.0.0-06186593f1-83e95cadbb.zip/node_modules/es-shim-unscopables/index.js\nvar require_es_shim_unscopables = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/es-shim-unscopables-npm-1.0.0-06186593f1-83e95cadbb.zip/node_modules/es-shim-unscopables/index.js\"(exports, module2) {\n    \"use strict\";\n    var has = require_src();\n    var hasUnscopables = typeof Symbol === \"function\" && typeof Symbol.unscopables === \"symbol\";\n    var map = hasUnscopables && Array.prototype[Symbol.unscopables];\n    var $TypeError = TypeError;\n    module2.exports = function shimUnscopables(method) {\n      if (typeof method !== \"string\" || !method) {\n        throw new $TypeError(\"method must be a non-empty string\");\n      }\n      if (!has(Array.prototype, method)) {\n        throw new $TypeError(\"method must be on Array.prototype\");\n      }\n      if (hasUnscopables) {\n        map[method] = true;\n      }\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/shim.js\nvar require_shim3 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/shim.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var shimUnscopables = require_es_shim_unscopables();\n    var getPolyfill = require_polyfill3();\n    module2.exports = function shimArrayPrototypeFind() {\n      var polyfill = getPolyfill();\n      define(Array.prototype, { find: polyfill }, {\n        find: function() {\n          return Array.prototype.find !== polyfill;\n        }\n      });\n      shimUnscopables(\"find\");\n      return polyfill;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/index.js\nvar require_array_prototype = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/array.prototype.find-npm-2.2.0-b1ca14f05d-43c19177cc.zip/node_modules/array.prototype.find/index.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var callBound = require_callBound();\n    var RequireObjectCoercible = require_RequireObjectCoercible();\n    var implementation = require_implementation5();\n    var getPolyfill = require_polyfill3();\n    var shim = require_shim3();\n    var $slice = callBound(\"Array.prototype.slice\");\n    var polyfill = getPolyfill();\n    var boundFindShim = function find(array, predicate) {\n      RequireObjectCoercible(array);\n      var args = $slice(arguments, 1);\n      return polyfill.apply(array, args);\n    };\n    define(boundFindShim, {\n      getPolyfill,\n      implementation,\n      shim\n    });\n    module2.exports = boundFindShim;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/functions-have-names-npm-1.2.3-e5cf1e2208-c3f1f5ba20.zip/node_modules/functions-have-names/index.js\nvar require_functions_have_names = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/functions-have-names-npm-1.2.3-e5cf1e2208-c3f1f5ba20.zip/node_modules/functions-have-names/index.js\"(exports, module2) {\n    \"use strict\";\n    var functionsHaveNames = function functionsHaveNames2() {\n      return typeof function f() {\n      }.name === \"string\";\n    };\n    var gOPD = Object.getOwnPropertyDescriptor;\n    if (gOPD) {\n      try {\n        gOPD([], \"length\");\n      } catch (e) {\n        gOPD = null;\n      }\n    }\n    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {\n      if (!functionsHaveNames() || !gOPD) {\n        return false;\n      }\n      var desc = gOPD(function() {\n      }, \"name\");\n      return !!desc && !!desc.configurable;\n    };\n    var $bind = Function.prototype.bind;\n    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {\n      return functionsHaveNames() && typeof $bind === \"function\" && function f() {\n      }.bind().name !== \"\";\n    };\n    module2.exports = functionsHaveNames;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/implementation.js\nvar require_implementation6 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var IsCallable = require_IsCallable();\n    var functionsHaveNames = require_functions_have_names()();\n    var callBound = require_callBound();\n    var $functionToString = callBound(\"Function.prototype.toString\");\n    var $stringMatch = callBound(\"String.prototype.match\");\n    var classRegex = /^class /;\n    var isClass = function isClassConstructor(fn) {\n      if (IsCallable(fn)) {\n        return false;\n      }\n      if (typeof fn !== \"function\") {\n        return false;\n      }\n      try {\n        var match = $stringMatch($functionToString(fn), classRegex);\n        return !!match;\n      } catch (e) {\n      }\n      return false;\n    };\n    var regex = /\\s*function\\s+([^(\\s]*)\\s*/;\n    var functionProto = Function.prototype;\n    module2.exports = function getName() {\n      if (!isClass(this) && !IsCallable(this)) {\n        throw new TypeError(\"Function.prototype.name sham getter called on non-function\");\n      }\n      if (functionsHaveNames) {\n        return this.name;\n      }\n      if (this === functionProto) {\n        return \"\";\n      }\n      var str = $functionToString(this);\n      var match = $stringMatch(str, regex);\n      var name = match && match[1];\n      return name;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/polyfill.js\nvar require_polyfill4 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/polyfill.js\"(exports, module2) {\n    \"use strict\";\n    var implementation = require_implementation6();\n    module2.exports = function getPolyfill() {\n      return implementation;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/shim.js\nvar require_shim4 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/shim.js\"(exports, module2) {\n    \"use strict\";\n    var supportsDescriptors = require_define_properties().supportsDescriptors;\n    var functionsHaveNames = require_functions_have_names()();\n    var getPolyfill = require_polyfill4();\n    var defineProperty = Object.defineProperty;\n    var TypeErr = TypeError;\n    module2.exports = function shimName() {\n      var polyfill = getPolyfill();\n      if (functionsHaveNames) {\n        return polyfill;\n      }\n      if (!supportsDescriptors) {\n        throw new TypeErr(\"Shimming Function.prototype.name support requires ES5 property descriptor support.\");\n      }\n      var functionProto = Function.prototype;\n      defineProperty(functionProto, \"name\", {\n        configurable: true,\n        enumerable: false,\n        get: function() {\n          var name = polyfill.call(this);\n          if (this !== functionProto) {\n            defineProperty(this, \"name\", {\n              configurable: true,\n              enumerable: false,\n              value: name,\n              writable: false\n            });\n          }\n          return name;\n        }\n      });\n      return polyfill;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/index.js\nvar require_function_prototype = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/function.prototype.name-npm-1.1.5-e776a642bb-acd21d733a.zip/node_modules/function.prototype.name/index.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var callBind = require_call_bind();\n    var implementation = require_implementation6();\n    var getPolyfill = require_polyfill4();\n    var shim = require_shim4();\n    var bound = callBind(implementation);\n    define(bound, {\n      getPolyfill,\n      implementation,\n      shim\n    });\n    module2.exports = bound;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/getComponentName.js\nvar require_getComponentName = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/getComponentName.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = getComponentName;\n    var _functionPrototype = _interopRequireDefault(require_function_prototype());\n    var _reactIs = require_react_is();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function getComponentName(Component) {\n      if (typeof Component === \"string\") {\n        return Component;\n      }\n      if (typeof Component === \"function\") {\n        return Component.displayName || (0, _functionPrototype[\"default\"])(Component);\n      }\n      if ((0, _reactIs.isForwardRef)({\n        type: Component,\n        $$typeof: _reactIs.Element\n      })) {\n        return Component.displayName;\n      }\n      if ((0, _reactIs.isMemo)(Component)) {\n        return getComponentName(Component.type);\n      }\n      return null;\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenOfType.js\nvar require_childrenOfType = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenOfType.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _arrayPrototype = _interopRequireDefault(require_array_prototype());\n    var _getComponentName = _interopRequireDefault(require_getComponentName());\n    var _renderableChildren = _interopRequireDefault(require_renderableChildren());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function onlyTypes(types, children, componentName) {\n      if (!children.every(function(child) {\n        return child && (0, _arrayPrototype[\"default\"])(types, function(Type) {\n          return Type === \"*\" || child.type === Type;\n        });\n      })) {\n        var typeNames = types.map(_getComponentName[\"default\"]).join(\", or \");\n        return new TypeError(\"`\".concat(componentName, \"` only accepts children of type \").concat(typeNames));\n      }\n      return null;\n    }\n    function isRequired(types, children, componentName) {\n      if (children.length === 0) {\n        var typeNames = types.map(_getComponentName[\"default\"]).join(\", or \");\n        return new TypeError(\"`\".concat(componentName, \"` requires at least one node of type \").concat(typeNames));\n      }\n      return null;\n    }\n    function childrenOfType() {\n      for (var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++) {\n        types[_key] = arguments[_key];\n      }\n      if (types.length < 1) {\n        throw new TypeError(\"childrenOfType: at least 1 type is required\");\n      }\n      function validator(props, propName, componentName) {\n        return onlyTypes(types, (0, _renderableChildren[\"default\"])(props[propName]), componentName);\n      }\n      validator.isRequired = function(props, propName, componentName) {\n        var children = (0, _renderableChildren[\"default\"])(props[propName]);\n        return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"childrenOfType\", types);\n    }\n    var _default = childrenOfType;\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/isInteger.js\nvar require_isInteger = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/isInteger.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var floor = Math.floor;\n    var finite = isFinite;\n    var _default = Number.isInteger || function(x) {\n      return typeof x === \"number\" && finite(x) && floor(x) === x;\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/integer.js\nvar require_integer = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/integer.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _isInteger = _interopRequireDefault(require_isInteger());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function requiredInteger(props, propName, componentName) {\n      var propValue = props[propName];\n      if (propValue == null || !(0, _isInteger[\"default\"])(propValue)) {\n        return new RangeError(\"\".concat(propName, \" in \").concat(componentName, \" must be an integer\"));\n      }\n      return null;\n    }\n    var validator = function integer(props, propName) {\n      var propValue = props[propName];\n      if (propValue == null) {\n        return null;\n      }\n      for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        rest[_key - 2] = arguments[_key];\n      }\n      return requiredInteger.apply(void 0, [props, propName].concat(rest));\n    };\n    validator.isRequired = requiredInteger;\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(validator, \"integer\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/implementation.js\nvar require_implementation7 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var numberIsNaN = function(value) {\n      return value !== value;\n    };\n    module2.exports = function is(a, b) {\n      if (a === 0 && b === 0) {\n        return 1 / a === 1 / b;\n      }\n      if (a === b) {\n        return true;\n      }\n      if (numberIsNaN(a) && numberIsNaN(b)) {\n        return true;\n      }\n      return false;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/polyfill.js\nvar require_polyfill5 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/polyfill.js\"(exports, module2) {\n    \"use strict\";\n    var implementation = require_implementation7();\n    module2.exports = function getPolyfill() {\n      return typeof Object.is === \"function\" ? Object.is : implementation;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/shim.js\nvar require_shim5 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/shim.js\"(exports, module2) {\n    \"use strict\";\n    var getPolyfill = require_polyfill5();\n    var define = require_define_properties();\n    module2.exports = function shimObjectIs() {\n      var polyfill = getPolyfill();\n      define(Object, { is: polyfill }, {\n        is: function testObjectIs() {\n          return Object.is !== polyfill;\n        }\n      });\n      return polyfill;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/index.js\nvar require_object_is = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object-is-npm-1.1.5-48a862602b-989b18c4cb.zip/node_modules/object-is/index.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var callBind = require_call_bind();\n    var implementation = require_implementation7();\n    var getPolyfill = require_polyfill5();\n    var shim = require_shim5();\n    var polyfill = callBind(getPolyfill(), Object);\n    define(polyfill, {\n      getPolyfill,\n      implementation,\n      shim\n    });\n    module2.exports = polyfill;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/nonNegativeNumber.js\nvar require_nonNegativeNumber = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/nonNegativeNumber.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _objectIs = _interopRequireDefault(require_object_is());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function isNonNegative(x) {\n      return typeof x === \"number\" && isFinite(x) && x >= 0 && !(0, _objectIs[\"default\"])(x, -0);\n    }\n    function nonNegativeNumber(props, propName, componentName) {\n      var value = props[propName];\n      if (value == null || isNonNegative(value)) {\n        return null;\n      }\n      return new RangeError(\"\".concat(propName, \" in \").concat(componentName, \" must be a non-negative number\"));\n    }\n    function requiredNonNegativeNumber(props, propName, componentName) {\n      var value = props[propName];\n      if (isNonNegative(value)) {\n        return null;\n      }\n      return new RangeError(\"\".concat(propName, \" in \").concat(componentName, \" must be a non-negative number\"));\n    }\n    nonNegativeNumber.isRequired = requiredNonNegativeNumber;\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(nonNegativeNumber, \"nonNegativeNumber\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/nonNegativeInteger.js\nvar require_nonNegativeInteger = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/nonNegativeInteger.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _and = _interopRequireDefault(require_and());\n    var _integer = _interopRequireDefault(require_integer());\n    var _nonNegativeNumber = _interopRequireDefault(require_nonNegativeNumber());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var _default = (0, _and[\"default\"])([(0, _integer[\"default\"])(), (0, _nonNegativeNumber[\"default\"])()], \"nonNegativeInteger\");\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/typeOf.js\nvar require_typeOf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/helpers/typeOf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = typeOf;\n    var _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    function typeOf(child) {\n      if (child === null) {\n        return \"null\";\n      }\n      if (Array.isArray(child)) {\n        return \"array\";\n      }\n      if (_typeof(child) !== \"object\") {\n        return _typeof(child);\n      }\n      if (/* @__PURE__ */ _react[\"default\"].isValidElement(child)) {\n        return child.type;\n      }\n      return child;\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/object.js\nvar require_object3 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/object.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _isPlainObject = _interopRequireDefault(require_isPlainObject2());\n    var _typeOf = _interopRequireDefault(require_typeOf());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var ReactPropTypeLocationNames = {\n      prop: \"prop\",\n      context: \"context\",\n      childContext: \"child context\"\n    };\n    function object(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (propValue == null) {\n        return null;\n      }\n      if ((0, _isPlainObject[\"default\"])(propValue)) {\n        return null;\n      }\n      var locationName = ReactPropTypeLocationNames[location] || location;\n      return new TypeError(\"Invalid \".concat(locationName, \" `\").concat(propFullName, \"` of type `\").concat((0, _typeOf[\"default\"])(propValue), \"` supplied to `\").concat(componentName, \"`, expected `object`.\"));\n    }\n    object.isRequired = function objectRequired(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (propValue == null) {\n        var locationName = ReactPropTypeLocationNames[location] || location;\n        return new TypeError(\"The \".concat(locationName, \" `\").concat(propFullName, \"` is marked as required in `\").concat(componentName, \"`, but its value is `\").concat(propValue, \"`.\"));\n      }\n      for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n        rest[_key - 5] = arguments[_key];\n      }\n      return object.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));\n    };\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(object, \"object\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/withShape.js\nvar require_withShape = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/withShape.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = withShape;\n    var _and = _interopRequireDefault(require_and());\n    var _shape = _interopRequireDefault(require_shape());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function withShape(type, shapeTypes) {\n      if (typeof type !== \"function\") {\n        throw new TypeError(\"type must be a valid PropType\");\n      }\n      var shapeValidator = (0, _shape[\"default\"])(shapeTypes);\n      return (0, _and[\"default\"])([type, shapeValidator], \"withShape\");\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/sequenceOf.js\nvar require_sequenceOf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/sequenceOf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = sequenceOfValidator;\n    var _propTypes = require_prop_types();\n    var _and = _interopRequireDefault(require_and());\n    var _between = _interopRequireDefault(require_between());\n    var _nonNegativeInteger = _interopRequireDefault(require_nonNegativeInteger());\n    var _object = _interopRequireDefault(require_object3());\n    var _withShape = _interopRequireDefault(require_withShape());\n    var _typeOf = _interopRequireDefault(require_typeOf());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly)\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var minValidator = _nonNegativeInteger[\"default\"];\n    var maxValidator = (0, _and[\"default\"])([_nonNegativeInteger[\"default\"], (0, _between[\"default\"])({\n      gte: 1\n    })]);\n    function validateRange(min, max) {\n      if (typeof max !== \"number\" || typeof min !== \"number\") {\n        return null;\n      }\n      if (min <= max) {\n        return null;\n      }\n      return new RangeError(\"min must be less than or equal to max\");\n    }\n    var specifierShape = {\n      validator: function validator(props, propName) {\n        var propValue = props[propName];\n        if (typeof propValue !== \"function\") {\n          return new TypeError('\"validator\" must be a propType validator function');\n        }\n        return null;\n      },\n      min: function min(props, propName) {\n        return minValidator(props, propName) || validateRange(props.min, props.max);\n      },\n      max: function max(props, propName) {\n        return maxValidator(props, propName) || validateRange(props.min, props.max);\n      }\n    };\n    function getMinMax(_ref) {\n      var min = _ref.min, max = _ref.max;\n      var minimum;\n      var maximum;\n      if (typeof min !== \"number\" && typeof max !== \"number\") {\n        minimum = 1;\n        maximum = 1;\n      } else {\n        minimum = typeof min === \"number\" ? min : 1;\n        maximum = typeof max === \"number\" ? max : Infinity;\n      }\n      return {\n        minimum,\n        maximum\n      };\n    }\n    function chunkByType(items) {\n      var chunk = [];\n      var lastType;\n      return items.reduce(function(chunks, item) {\n        var itemType = (0, _typeOf[\"default\"])(item);\n        if (!lastType || itemType === lastType) {\n          chunk.push(item);\n        } else {\n          chunks.push(chunk);\n          chunk = [item];\n        }\n        lastType = itemType;\n        return chunks;\n      }, []).concat(chunk.length > 0 ? [chunk] : []);\n    }\n    function validateChunks(specifiers, props, propName, componentName) {\n      var items = props[propName];\n      var chunks = chunkByType(items);\n      for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n        rest[_key - 4] = arguments[_key];\n      }\n      for (var i = 0; i < specifiers.length; i += 1) {\n        var _specifiers$i = specifiers[i], validator = _specifiers$i.validator, min = _specifiers$i.min, max = _specifiers$i.max;\n        var _getMinMax = getMinMax({\n          min,\n          max\n        }), minimum = _getMinMax.minimum, maximum = _getMinMax.maximum;\n        if (chunks.length === 0 && minimum === 0) {\n          continue;\n        }\n        var arrayOfValidator = (0, _propTypes.arrayOf)(validator).isRequired;\n        var chunk = chunks.shift();\n        var chunkError = arrayOfValidator.apply(void 0, [_objectSpread(_objectSpread({}, props), {}, _defineProperty({}, propName, chunk)), propName, componentName].concat(rest));\n        if (chunkError) {\n          if (minimum === 0) {\n            chunks.unshift(chunk);\n            continue;\n          }\n          return chunkError;\n        }\n        if (chunk.length < minimum) {\n          return new RangeError(\"\".concat(componentName, \": specifier index \").concat(i, \" requires a minimum of \").concat(min, \" items, but only has \").concat(chunk.length, \".\"));\n        }\n        if (chunk.length > maximum) {\n          return new RangeError(\"\".concat(componentName, \": specifier index \").concat(i, \" requires a maximum of \").concat(max, \" items, but has \").concat(chunk.length, \".\"));\n        }\n      }\n      if (chunks.length > 0) {\n        return new TypeError(\"\".concat(componentName, \": after all \").concat(specifiers.length, \" specifiers matched, \").concat(chunks.length, \" types of items were remaining.\"));\n      }\n      return null;\n    }\n    var specifierValidator = (0, _withShape[\"default\"])((0, _object[\"default\"])(), specifierShape).isRequired;\n    function sequenceOfValidator() {\n      for (var _len2 = arguments.length, specifiers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        specifiers[_key2] = arguments[_key2];\n      }\n      if (specifiers.length === 0) {\n        throw new RangeError(\"sequenceOf: at least one specifier is required\");\n      }\n      var errors = specifiers.map(function(specifier, i) {\n        return specifierValidator({\n          specifier\n        }, \"specifier\", \"sequenceOf specifier\", \"suequenceOf specifier, index \".concat(i), \"specifier, index \".concat(i));\n      });\n      if (errors.some(Boolean)) {\n        throw new TypeError(\"\\n      sequenceOf: all specifiers must match the appropriate shape.\\n\\n      Errors:\\n        \".concat(errors.map(function(e, i) {\n          return \" - Argument index \".concat(i, \": \").concat(e.message);\n        }).join(\",\\n        \"), \"\\n    \"));\n      }\n      var validator = function sequenceOf(props, propName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return null;\n        }\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          rest[_key3 - 2] = arguments[_key3];\n        }\n        var error = _propTypes.array.apply(void 0, [props, propName].concat(rest));\n        if (error) {\n          return error;\n        }\n        return validateChunks.apply(void 0, [specifiers, props, propName].concat(rest));\n      };\n      validator.isRequired = function sequenceOfRequired(props, propName, componentName) {\n        for (var _len4 = arguments.length, rest = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n          rest[_key4 - 3] = arguments[_key4];\n        }\n        var error = _propTypes.array.isRequired.apply(_propTypes.array, [props, propName, componentName].concat(rest));\n        if (error) {\n          return error;\n        }\n        return validateChunks.apply(void 0, [specifiers, props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"sequenceOf\", specifiers);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenSequenceOf.js\nvar require_childrenSequenceOf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/childrenSequenceOf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = childrenSequenceOfValidator;\n    var _sequenceOf = _interopRequireDefault(require_sequenceOf());\n    var _renderableChildren = _interopRequireDefault(require_renderableChildren());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly)\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function childrenSequenceOfValidator() {\n      for (var _len = arguments.length, specifiers = new Array(_len), _key = 0; _key < _len; _key++) {\n        specifiers[_key] = arguments[_key];\n      }\n      var seq = _sequenceOf[\"default\"].apply(void 0, specifiers);\n      var validator = function childrenSequenceOf(props, propName, componentName) {\n        if (propName !== \"children\") {\n          return new TypeError(\"\".concat(componentName, ' is using the childrenSequenceOf validator on non-children prop \"').concat(propName, '\"'));\n        }\n        var propValue = props[propName];\n        var children = (0, _renderableChildren[\"default\"])(propValue);\n        if (children.length === 0) {\n          return null;\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return seq.apply(void 0, [_objectSpread(_objectSpread({}, props), {}, {\n          children\n        }), propName, componentName].concat(rest));\n      };\n      validator.isRequired = function childrenSequenceOfRequired(props, propName, componentName) {\n        if (propName !== \"children\") {\n          return new TypeError(\"\".concat(componentName, ' is using the childrenSequenceOf validator on non-children prop \"').concat(propName, '\"'));\n        }\n        var propValue = props[propName];\n        var children = (0, _renderableChildren[\"default\"])(propValue);\n        if (children.length === 0) {\n          return new TypeError(\"\".concat(componentName, \": renderable children are required.\"));\n        }\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n          rest[_key3 - 3] = arguments[_key3];\n        }\n        return seq.isRequired.apply(seq, [_objectSpread(_objectSpread({}, props), {}, {\n          children\n        }), propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"childrenSequenceOf\", specifiers);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-regex-npm-1.1.4-cca193ef11-362399b335.zip/node_modules/is-regex/index.js\nvar require_is_regex = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/is-regex-npm-1.1.4-cca193ef11-362399b335.zip/node_modules/is-regex/index.js\"(exports, module2) {\n    \"use strict\";\n    var callBound = require_callBound();\n    var hasToStringTag = require_shams2()();\n    var has;\n    var $exec;\n    var isRegexMarker;\n    var badStringifier;\n    if (hasToStringTag) {\n      has = callBound(\"Object.prototype.hasOwnProperty\");\n      $exec = callBound(\"RegExp.prototype.exec\");\n      isRegexMarker = {};\n      throwRegexMarker = function() {\n        throw isRegexMarker;\n      };\n      badStringifier = {\n        toString: throwRegexMarker,\n        valueOf: throwRegexMarker\n      };\n      if (typeof Symbol.toPrimitive === \"symbol\") {\n        badStringifier[Symbol.toPrimitive] = throwRegexMarker;\n      }\n    }\n    var throwRegexMarker;\n    var $toString = callBound(\"Object.prototype.toString\");\n    var gOPD = Object.getOwnPropertyDescriptor;\n    var regexClass = \"[object RegExp]\";\n    module2.exports = hasToStringTag ? function isRegex(value) {\n      if (!value || typeof value !== \"object\") {\n        return false;\n      }\n      var descriptor = gOPD(value, \"lastIndex\");\n      var hasLastIndexDataProperty = descriptor && has(descriptor, \"value\");\n      if (!hasLastIndexDataProperty) {\n        return false;\n      }\n      try {\n        $exec(value, badStringifier);\n      } catch (e) {\n        return e === isRegexMarker;\n      }\n    } : function isRegex(value) {\n      if (!value || typeof value !== \"object\" && typeof value !== \"function\") {\n        return false;\n      }\n      return $toString(value) === regexClass;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/componentWithName.js\nvar require_componentWithName = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/componentWithName.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = componentWithName;\n    var _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n    var _isRegex = _interopRequireDefault(require_is_regex());\n    var _arrayPrototype = _interopRequireDefault(require_array_prototype());\n    var _getComponentName = _interopRequireDefault(require_getComponentName());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function stripHOCs(fullName, namesOfHOCsToStrip) {\n      var innerName = fullName;\n      while (/\\([^()]*\\)/g.test(innerName)) {\n        var HOC = innerName;\n        var previousHOC = void 0;\n        do {\n          previousHOC = HOC;\n          HOC = previousHOC.replace(/\\([^()]*\\)/g, \"\");\n        } while (previousHOC !== HOC);\n        if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n          return innerName;\n        }\n        innerName = innerName.replace(RegExp(\"^\".concat(HOC, \"\\\\(|\\\\)$\"), \"g\"), \"\");\n      }\n      return innerName;\n    }\n    function hasName(name, namesOfHOCsToStrip, propValue, propName, componentName) {\n      for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n        rest[_key - 5] = arguments[_key];\n      }\n      if (Array.isArray(propValue)) {\n        return (0, _arrayPrototype[\"default\"])(propValue.map(function(item) {\n          return hasName.apply(void 0, [name, namesOfHOCsToStrip, item, propName, componentName].concat(rest));\n        }), Boolean) || null;\n      }\n      if (!/* @__PURE__ */ _react[\"default\"].isValidElement(propValue)) {\n        return new TypeError(\"\".concat(componentName, \".\").concat(propName, \" is not a valid React element\"));\n      }\n      var type = propValue.type;\n      var componentNameFromType = (0, _getComponentName[\"default\"])(type);\n      var innerComponentName = namesOfHOCsToStrip.length > 0 ? stripHOCs(componentNameFromType, namesOfHOCsToStrip) : componentNameFromType;\n      if ((0, _isRegex[\"default\"])(name) && !name.test(innerComponentName)) {\n        return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components matching the regular expression \").concat(name));\n      }\n      if (!(0, _isRegex[\"default\"])(name) && innerComponentName !== name) {\n        return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components named \").concat(name, \", got \").concat(innerComponentName));\n      }\n      return null;\n    }\n    function componentWithName(name) {\n      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n      if (typeof name !== \"string\" && !(0, _isRegex[\"default\"])(name)) {\n        throw new TypeError(\"name must be a string or a regex\");\n      }\n      var passedOptions = Object.keys(options);\n      if (passedOptions.length > 1 || passedOptions.length === 1 && passedOptions[0] !== \"stripHOCs\") {\n        throw new TypeError(\"The only options supported are: \\u201CstripHOCs\\u201D, got: \\u201C\".concat(passedOptions.join(\"\\u201D, \\u201C\"), \"\\u201D\"));\n      }\n      var _options$stripHOCs = options.stripHOCs, namesOfHOCsToStrip = _options$stripHOCs === void 0 ? [] : _options$stripHOCs;\n      var allHOCNamesAreValid = namesOfHOCsToStrip.every(function(x) {\n        if (typeof x !== \"string\" || /[()]/g.test(x)) {\n          return false;\n        }\n        return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n      });\n      if (!allHOCNamesAreValid) {\n        throw new TypeError(\"every provided HOC name must be a string with no parens, and in camelCase\");\n      }\n      function componentWithNameValidator(props, propName, componentName) {\n        var propValue = props[propName];\n        if (props[propName] == null) {\n          return null;\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n      }\n      componentWithNameValidator.isRequired = function componentWithNameRequired(props, propName, componentName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` requires at least one component named \").concat(name));\n        }\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n          rest[_key3 - 3] = arguments[_key3];\n        }\n        return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(componentWithNameValidator, \"componentWithName:\".concat(name), name);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/disallowedIf.js\nvar require_disallowedIf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/disallowedIf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = disallowedIf;\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function disallowedIf(propType, otherPropName, otherPropType) {\n      if (typeof propType !== \"function\" || typeof propType.isRequired !== \"function\") {\n        throw new TypeError(\"a propType validator is required; propType validators must also provide `.isRequired`\");\n      }\n      if (typeof otherPropName !== \"string\") {\n        throw new TypeError(\"other prop name must be a string\");\n      }\n      if (typeof otherPropType !== \"function\") {\n        throw new TypeError(\"other prop type validator is required\");\n      }\n      function disallowedIfRequired(props, propName, componentName) {\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        var error = propType.isRequired.apply(propType, [props, propName, componentName].concat(rest));\n        if (error) {\n          return error;\n        }\n        if (props[otherPropName] == null) {\n          return null;\n        }\n        var otherError = otherPropType.apply(void 0, [props, otherPropName, componentName].concat(rest));\n        if (otherError) {\n          return null;\n        }\n        return new Error(\"prop \\u201C\".concat(propName, \"\\u201D is disallowed when \\u201C\").concat(otherPropName, \"\\u201D matches the provided validator\"));\n      }\n      var validator = function disallowedIfPropType(props, propName) {\n        if (props[propName] == null) {\n          return null;\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          rest[_key2 - 2] = arguments[_key2];\n        }\n        return disallowedIfRequired.apply(void 0, [props, propName].concat(rest));\n      };\n      validator.isRequired = disallowedIfRequired;\n      return (0, _wrapValidator[\"default\"])(validator, \"disallowedIf\", {\n        propType,\n        otherPropName,\n        otherPropType\n      });\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/elementType.js\nvar require_elementType = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/elementType.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = elementTypeValidator;\n    var _propTypes = require_prop_types();\n    var _reactIs = require_react_is();\n    var _and = _interopRequireDefault(require_and());\n    var _getComponentName = _interopRequireDefault(require_getComponentName());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    function getTypeName(Type) {\n      if (typeof Type === \"string\") {\n        return Type;\n      }\n      var type = (0, _getComponentName[\"default\"])(Type);\n      return type || \"Anonymous Component\";\n    }\n    function validateElementType(Type, props, propName, componentName) {\n      var type = props[propName].type;\n      if (type === Type) {\n        return null;\n      }\n      return new TypeError(\"\".concat(componentName, \".\").concat(propName, \" must be a React element of type \").concat(getTypeName(Type)));\n    }\n    function elementTypeValidator(Type) {\n      if (Type === \"*\") {\n        return (0, _wrapValidator[\"default\"])(_propTypes.element, \"elementType(*)\", Type);\n      }\n      if (!(0, _reactIs.isValidElementType)(Type)) {\n        throw new TypeError('Type must be a React Component, an HTML element tag name, or \"*\". Got an '.concat(_typeof(Type)));\n      }\n      function elementType(props, propName, componentName) {\n        if (props[propName] == null) {\n          return null;\n        }\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        return validateElementType.apply(void 0, [Type, props, propName, componentName].concat(rest));\n      }\n      elementType.isRequired = elementType;\n      var typeName = getTypeName(Type);\n      var validatorName = \"elementType(\".concat(typeName, \")\");\n      return (0, _wrapValidator[\"default\"])((0, _and[\"default\"])([_propTypes.element, elementType], validatorName), validatorName, Type);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/or.js\nvar require_or = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/or.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = or;\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _toConsumableArray(arr) {\n      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n    }\n    function _nonIterableSpread() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o)\n        return;\n      if (typeof o === \"string\")\n        return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor)\n        n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\")\n        return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n        return _arrayLikeToArray(o, minLen);\n    }\n    function _iterableToArray(iter) {\n      if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter))\n        return Array.from(iter);\n    }\n    function _arrayWithoutHoles(arr) {\n      if (Array.isArray(arr))\n        return _arrayLikeToArray(arr);\n    }\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length)\n        len = arr.length;\n      for (var i = 0, arr2 = new Array(len); i < len; i++) {\n        arr2[i] = arr[i];\n      }\n      return arr2;\n    }\n    function oneOfTypeValidator(validators) {\n      var validator = function oneOfType(props, propName, componentName) {\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        var propValue = props[propName];\n        if (typeof propValue === \"undefined\") {\n          return null;\n        }\n        var errors = validators.map(function(v) {\n          return v.apply(void 0, [props, propName, componentName].concat(rest));\n        }).filter(Boolean);\n        if (errors.length < validators.length) {\n          return null;\n        }\n        return new TypeError(\"\".concat(componentName, \": invalid value supplied to \").concat(propName, \".\"));\n      };\n      validator.isRequired = function oneOfTypeRequired(props, propName, componentName) {\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        var propValue = props[propName];\n        if (typeof propValue === \"undefined\") {\n          return new TypeError(\"\".concat(componentName, \": missing value for required \").concat(propName, \".\"));\n        }\n        var errors = validators.map(function(v) {\n          return v.apply(void 0, [props, propName, componentName].concat(rest));\n        }).filter(Boolean);\n        if (errors.length === validators.length) {\n          return new TypeError(\"\".concat(componentName, \": invalid value \").concat(errors, \" supplied to required \").concat(propName, \".\"));\n        }\n        return null;\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"oneOfType\", validators);\n    }\n    function or(validators) {\n      var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"or\";\n      if (!Array.isArray(validators)) {\n        throw new TypeError(\"or: 2 or more validators are required\");\n      }\n      if (validators.length <= 1) {\n        throw new RangeError(\"or: 2 or more validators are required\");\n      }\n      var validator = oneOfTypeValidator([(0, _propTypes.arrayOf)(oneOfTypeValidator(validators))].concat(_toConsumableArray(validators)));\n      return (0, _wrapValidator[\"default\"])(validator, name, validators);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/explicitNull.js\nvar require_explicitNull = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/explicitNull.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof2(obj2) {\n          return typeof obj2;\n        };\n      } else {\n        _typeof = function _typeof2(obj2) {\n          return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n        };\n      }\n      return _typeof(obj);\n    }\n    function explicitNull(props, propName, componentName) {\n      if (props[propName] == null) {\n        return null;\n      }\n      return new TypeError(\"\".concat(componentName, \": prop \\u201C\").concat(propName, \"\\u201D must be null or undefined; received \").concat(_typeof(props[propName])));\n    }\n    explicitNull.isRequired = function explicitNullRequired(props, propName, componentName) {\n      if (props[propName] === null) {\n        return null;\n      }\n      return new TypeError(\"\".concat(componentName, \": prop \\u201C\").concat(propName, \"\\u201D must be null; received \").concat(_typeof(props[propName])));\n    };\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(explicitNull, \"explicitNull\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/empty.js\nvar require_empty = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/empty.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _propTypes = require_prop_types();\n    var _or = _interopRequireDefault(require_or());\n    var _explicitNull = _interopRequireDefault(require_explicitNull());\n    var _withShape = _interopRequireDefault(require_withShape());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var arrayOfValidator;\n    var validator = (0, _or[\"default\"])([\n      _explicitNull[\"default\"],\n      (0, _propTypes.oneOf)([false, \"\", NaN]),\n      (0, _withShape[\"default\"])(_propTypes.array, {\n        length: (0, _propTypes.oneOf)([0]).isRequired\n      }).isRequired,\n      function() {\n        return arrayOfValidator.apply(void 0, arguments);\n      }\n    ]);\n    arrayOfValidator = (0, _propTypes.arrayOf)(validator).isRequired;\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(validator, \"empty\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/keysOf.js\nvar require_keysOf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/keysOf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = keysOfValidator;\n    var _isPrimitive = _interopRequireDefault(require_isPrimitive());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function keysOfValidator(propType) {\n      var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"keysOf\";\n      if (typeof propType !== \"function\") {\n        throw new TypeError(\"argument to keysOf must be a valid PropType function\");\n      }\n      var validator = function keysOf(props, propName, componentName, location, propFullName) {\n        for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n          rest[_key - 5] = arguments[_key];\n        }\n        var propValue = props[propName];\n        if (propValue == null || (0, _isPrimitive[\"default\"])(propValue)) {\n          return null;\n        }\n        var firstError = null;\n        Object.keys(propValue).some(function(key) {\n          firstError = propType.apply(void 0, [_defineProperty({}, key, key), key, componentName, location, \"(\".concat(propFullName, \").\").concat(key)].concat(rest));\n          return firstError != null;\n        });\n        return firstError || null;\n      };\n      validator.isRequired = function keyedByRequired(props, propName, componentName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return new TypeError(\"\".concat(componentName, \": \").concat(propName, \" is required, but value is \").concat(propValue));\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return validator.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(validator, name, propType);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/mutuallyExclusiveProps.js\nvar require_mutuallyExclusiveProps = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/mutuallyExclusiveProps.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = mutuallyExclusiveOfType;\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly)\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function mutuallyExclusiveOfType(propType) {\n      if (typeof propType !== \"function\") {\n        throw new TypeError(\"a propType is required\");\n      }\n      for (var _len = arguments.length, exclusiveProps = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        exclusiveProps[_key - 1] = arguments[_key];\n      }\n      if (exclusiveProps.length < 1) {\n        throw new TypeError(\"at least one prop that is mutually exclusive with this propType is required\");\n      }\n      var propList = exclusiveProps.join(\", or \");\n      var map = exclusiveProps.reduce(function(acc, prop) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, prop, true));\n      }, {});\n      var countProps = function countProps2(count, prop) {\n        return count + (map[prop] ? 1 : 0);\n      };\n      var validator = function mutuallyExclusiveProps(props, propName, componentName) {\n        var exclusivePropCount = Object.keys(props).filter(function(prop) {\n          return props[prop] != null;\n        }).reduce(countProps, 0);\n        if (exclusivePropCount > 1) {\n          return new Error(\"A \".concat(componentName, \" cannot have more than one of these props: \").concat(propList));\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return propType.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      validator.isRequired = function mutuallyExclusivePropsRequired(props, propName, componentName) {\n        var exclusivePropCount = Object.keys(props).filter(function(prop) {\n          return prop === propName || props[prop] != null;\n        }).reduce(countProps, 0);\n        if (exclusivePropCount > 1) {\n          return new Error(\"A \".concat(componentName, \" cannot have more than one of these props: \").concat(propList));\n        }\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n          rest[_key3 - 3] = arguments[_key3];\n        }\n        return propType.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"mutuallyExclusiveProps:\".concat(propList), exclusiveProps);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/mutuallyExclusiveTrueProps.js\nvar require_mutuallyExclusiveTrueProps = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/mutuallyExclusiveTrueProps.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = mutuallyExclusiveTrue;\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function mutuallyExclusiveTrue() {\n      for (var _len = arguments.length, exclusiveProps = new Array(_len), _key = 0; _key < _len; _key++) {\n        exclusiveProps[_key] = arguments[_key];\n      }\n      if (exclusiveProps.length < 1) {\n        throw new TypeError(\"at least one prop that is mutually exclusive is required\");\n      }\n      if (!exclusiveProps.every(function(x) {\n        return typeof x === \"string\";\n      })) {\n        throw new TypeError(\"all exclusive true props must be strings\");\n      }\n      var propsList = exclusiveProps.join(\", or \");\n      var validator = function mutuallyExclusiveTrueProps(props, propName, componentName) {\n        var countProps = function countProps2(count, prop) {\n          return count + (props[prop] ? 1 : 0);\n        };\n        var exclusivePropCount = exclusiveProps.reduce(countProps, 0);\n        if (exclusivePropCount > 1) {\n          return new Error(\"A \".concat(componentName, \" cannot have more than one of these boolean props be true: \").concat(propsList));\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return _propTypes.bool.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      validator.isRequired = function mutuallyExclusiveTruePropsRequired(props, propName, componentName) {\n        var countProps = function countProps2(count, prop) {\n          return count + (props[prop] ? 1 : 0);\n        };\n        var exclusivePropCount = exclusiveProps.reduce(countProps, 0);\n        if (exclusivePropCount > 1) {\n          return new Error(\"A \".concat(componentName, \" cannot have more than one of these boolean props be true: \").concat(propsList));\n        }\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n          rest[_key3 - 3] = arguments[_key3];\n        }\n        return _propTypes.bool.isRequired.apply(_propTypes.bool, [props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"mutuallyExclusiveTrueProps: \".concat(propsList), exclusiveProps);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/nChildren.js\nvar require_nChildren = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/nChildren.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = nChildren;\n    var _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function nChildren(n) {\n      var propType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _propTypes.node;\n      if (typeof n !== \"number\" || isNaN(n) || n < 0) {\n        throw new TypeError(\"a non-negative number is required\");\n      }\n      var validator = function nChildrenValidator(props, propName, componentName) {\n        if (propName !== \"children\") {\n          return new TypeError(\"\".concat(componentName, \" is using the nChildren validator on a non-children prop\"));\n        }\n        var children = props.children;\n        var childrenCount = _react[\"default\"].Children.count(children);\n        if (childrenCount !== n) {\n          return new RangeError(\"\".concat(componentName, \" expects to receive \").concat(n, \" children, but received \").concat(childrenCount, \" children.\"));\n        }\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        return propType.apply(void 0, [props, propName, componentName].concat(rest));\n      };\n      validator.isRequired = validator;\n      return (0, _wrapValidator[\"default\"])(validator, \"nChildren:\".concat(n), n);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/numericString.js\nvar require_numericString = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/numericString.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var validNumericChars = /^[-+]?(?:[1-9][0-9]*(?:\\.[0-9]+)?|0|0\\.[0-9]+)$/;\n    var validator = function numericString(props, propName, componentName) {\n      if (props[propName] == null) {\n        return null;\n      }\n      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        rest[_key - 3] = arguments[_key];\n      }\n      var stringError = _propTypes.string.apply(void 0, [props, propName, componentName].concat(rest));\n      if (stringError) {\n        return stringError;\n      }\n      var value = props[propName];\n      var passesRegex = validNumericChars.test(value);\n      if (passesRegex) {\n        return null;\n      }\n      return new TypeError(\"\".concat(componentName, ': prop \"').concat(propName, '\" (value \"').concat(value, '\") must be a numeric string:\\n    - starting with an optional + or -\\n    - that does not have a leading zero\\n    - with an optional decimal part (that contains only one decimal point, if present)\\n    - that otherwise only contains digits (0-9)\\n    - not +-NaN, or +-Infinity\\n  '));\n    };\n    validator.isRequired = function numericStringRequired(props, propName, componentName) {\n      if (props[propName] == null) {\n        return new TypeError(\"\".concat(componentName, \": \").concat(propName, \" is required\"));\n      }\n      for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        rest[_key2 - 3] = arguments[_key2];\n      }\n      return validator.apply(void 0, [props, propName, componentName].concat(rest));\n    };\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(validator, \"numericString\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/predicate.js\nvar require_predicate = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/predicate.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = predicate;\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function predicate(fn) {\n      var message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n      if (typeof fn !== \"function\") {\n        throw new TypeError(\"`fn` must be a function\");\n      }\n      if (typeof message !== \"string\") {\n        throw new TypeError(\"`message`, if provided, must be a string\");\n      }\n      function requiredValidator(props, propName, componentName) {\n        var result = fn(props[propName]);\n        if (result) {\n          return null;\n        }\n        return new TypeError(\"`\".concat(componentName, \"` requires that `\").concat(propName, \"` pass a predicate function\").concat(message ? \": \".concat(message) : \"\", \".\"));\n      }\n      function validator(props, propName) {\n        if (props[propName] == null) {\n          return null;\n        }\n        for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          rest[_key - 2] = arguments[_key];\n        }\n        return requiredValidator.apply(void 0, [props, propName].concat(rest));\n      }\n      validator.isRequired = requiredValidator;\n      return (0, _wrapValidator[\"default\"])(validator, \"predicate\", fn);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/range.js\nvar require_range = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/range.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = range;\n    var _and = _interopRequireDefault(require_and());\n    var _between = _interopRequireDefault(require_between());\n    var _integer = _interopRequireDefault(require_integer());\n    var _isInteger = _interopRequireDefault(require_isInteger());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;\n    function isValidLength(x) {\n      return (0, _isInteger[\"default\"])(x) && Math.abs(x) < MAX_SAFE_INTEGER;\n    }\n    function range(min, max) {\n      if (!isValidLength(min) || !isValidLength(max)) {\n        throw new RangeError('\"range\" requires two integers: '.concat(min, \" and \").concat(max, \" given\"));\n      }\n      if (min === max) {\n        throw new RangeError(\"min and max must not be the same\");\n      }\n      return (0, _wrapValidator[\"default\"])((0, _and[\"default\"])([(0, _integer[\"default\"])(), (0, _between[\"default\"])({\n        gte: min,\n        lt: max\n      })], \"range\"), \"range\", {\n        min,\n        max\n      });\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/ref.js\nvar require_ref = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/ref.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n    var _isPlainObject = _interopRequireDefault(require_isPlainObject2());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var isPrototypeOf = Object.prototype.isPrototypeOf;\n    function isNewRef(prop) {\n      if (!(0, _isPlainObject[\"default\"])(prop)) {\n        return false;\n      }\n      var ownProperties = Object.keys(prop);\n      return ownProperties.length === 1 && ownProperties[0] === \"current\";\n    }\n    function isCallbackRef(prop) {\n      return typeof prop === \"function\" && !isPrototypeOf.call(_react.Component, prop) && (!_react.PureComponent || !isPrototypeOf.call(_react.PureComponent, prop));\n    }\n    function requiredRef(props, propName, componentName) {\n      var propValue = props[propName];\n      if (isCallbackRef(propValue) || isNewRef(propValue)) {\n        return null;\n      }\n      return new TypeError(\"\".concat(propName, \" in \").concat(componentName, \" must be a ref\"));\n    }\n    function ref(props, propName, componentName) {\n      var propValue = props[propName];\n      if (propValue == null) {\n        return null;\n      }\n      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        rest[_key - 3] = arguments[_key];\n      }\n      return requiredRef.apply(void 0, [props, propName, componentName].concat(rest));\n    }\n    ref.isRequired = requiredRef;\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(ref, \"ref\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/requiredBy.js\nvar require_requiredBy = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/requiredBy.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = getRequiredBy;\n    var _objectIs = _interopRequireDefault(require_object_is());\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function getRequiredBy(requiredByPropName, propType) {\n      var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n      function requiredBy(props, propName, componentName) {\n        if (props[requiredByPropName]) {\n          var propValue = props[propName];\n          if ((0, _objectIs[\"default\"])(propValue, defaultValue) || typeof propValue === \"undefined\") {\n            return new TypeError(\"\".concat(componentName, \": when \").concat(requiredByPropName, \" is true, prop \\u201C\").concat(propName, \"\\u201D must be present.\"));\n          }\n        }\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        return propType.apply(void 0, [props, propName, componentName].concat(rest));\n      }\n      requiredBy.isRequired = function requiredByRequired(props, propName, componentName) {\n        var propValue = props[propName];\n        if ((0, _objectIs[\"default\"])(propValue, defaultValue)) {\n          return new TypeError(\"\".concat(componentName, \": prop \\u201C\").concat(propName, \"\\u201D must be present.\"));\n        }\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          rest[_key2 - 3] = arguments[_key2];\n        }\n        return propType.isRequired.apply(propType, [props, propName, componentName].concat(rest));\n      };\n      return (0, _wrapValidator[\"default\"])(requiredBy, \"requiredBy \\u201C\".concat(requiredByPropName, \"\\u201D\"), [requiredByPropName, defaultValue]);\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/restrictedProp.js\nvar require_restrictedProp = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/restrictedProp.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function customMessageWrapper(messsageFunction) {\n      function restrictedProp(props, propName, componentName, location) {\n        if (props[propName] == null) {\n          return null;\n        }\n        if (messsageFunction && typeof messsageFunction === \"function\") {\n          for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n            rest[_key - 4] = arguments[_key];\n          }\n          return new TypeError(messsageFunction.apply(void 0, [props, propName, componentName, location].concat(rest)));\n        }\n        return new TypeError(\"The \".concat(propName, \" \").concat(location, \" on \").concat(componentName, \" is not allowed.\"));\n      }\n      restrictedProp.isRequired = restrictedProp;\n      return restrictedProp;\n    }\n    var _default = function _default2() {\n      var messsageFunction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n      return (0, _wrapValidator[\"default\"])(customMessageWrapper(messsageFunction), \"restrictedProp\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/stringEndsWith.js\nvar require_stringEndsWith = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/stringEndsWith.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = stringEndsWithValidator;\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function stringEndsWithValidator(end) {\n      if (typeof end !== \"string\" || end.length === 0) {\n        throw new TypeError(\"a non-empty string is required\");\n      }\n      var validator = function stringEndsWith(props, propName, componentName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return null;\n        }\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        var stringError = _propTypes.string.apply(void 0, [props, propName, componentName].concat(rest));\n        if (stringError) {\n          return stringError;\n        }\n        if (!propValue.endsWith(end) || propValue.length <= end.length) {\n          return new TypeError(\"\".concat(componentName, \": \").concat(propName, ' does not end with \"').concat(end, '\"'));\n        }\n        return null;\n      };\n      validator.isRequired = function requiredStringEndsWith() {\n        var stringError = _propTypes.string.isRequired.apply(_propTypes.string, arguments);\n        if (stringError) {\n          return stringError;\n        }\n        return validator.apply(void 0, arguments);\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"stringEndsWith: \".concat(end));\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/stringStartsWith.js\nvar require_stringStartsWith = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/stringStartsWith.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = stringStartsWithValidator;\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function stringStartsWithValidator(start) {\n      if (typeof start !== \"string\" || start.length === 0) {\n        throw new TypeError(\"a non-empty string is required\");\n      }\n      var validator = function stringStartsWith(props, propName, componentName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return null;\n        }\n        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          rest[_key - 3] = arguments[_key];\n        }\n        var stringError = _propTypes.string.apply(void 0, [props, propName, componentName].concat(rest));\n        if (stringError) {\n          return stringError;\n        }\n        if (!propValue.startsWith(start) || propValue.length <= start.length) {\n          return new TypeError(\"\".concat(componentName, \": \").concat(propName, ' does not start with \"').concat(start, '\"'));\n        }\n        return null;\n      };\n      validator.isRequired = function requiredStringStartsWith() {\n        var stringError = _propTypes.string.isRequired.apply(_propTypes.string, arguments);\n        if (stringError) {\n          return stringError;\n        }\n        return validator.apply(void 0, arguments);\n      };\n      return (0, _wrapValidator[\"default\"])(validator, \"stringStartsWith: \".concat(start));\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/uniqueArray.js\nvar require_uniqueArray = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/uniqueArray.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _propTypes = require_prop_types();\n    var _wrapValidator = _interopRequireDefault(require_wrapValidator());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function uniqueCountWithSet(arr) {\n      return new Set(arr).size;\n    }\n    function uniqueCountLegacy(arr) {\n      var seen = [];\n      arr.forEach(function(item) {\n        if (seen.indexOf(item) === -1) {\n          seen.push(item);\n        }\n      });\n      return seen.length;\n    }\n    var getUniqueCount = typeof Set === \"function\" ? uniqueCountWithSet : uniqueCountLegacy;\n    function requiredUniqueArray(props, propName, componentName) {\n      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        rest[_key - 3] = arguments[_key];\n      }\n      var result = _propTypes.array.isRequired.apply(_propTypes.array, [props, propName, componentName].concat(rest));\n      if (result != null) {\n        return result;\n      }\n      var propValue = props[propName];\n      var uniqueCount = getUniqueCount(propValue);\n      if (uniqueCount !== propValue.length) {\n        return new RangeError(\"\".concat(componentName, \": values must be unique. \").concat(propValue.length - uniqueCount, \" duplicate values found.\"));\n      }\n      return null;\n    }\n    function uniqueArray(props, propName) {\n      var propValue = props[propName];\n      if (propValue == null) {\n        return null;\n      }\n      for (var _len2 = arguments.length, rest = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        rest[_key2 - 2] = arguments[_key2];\n      }\n      return requiredUniqueArray.apply(void 0, [props, propName].concat(rest));\n    }\n    uniqueArray.isRequired = requiredUniqueArray;\n    var _default = function _default2() {\n      return (0, _wrapValidator[\"default\"])(uniqueArray, \"uniqueArray\");\n    };\n    exports[\"default\"] = _default;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/uniqueArrayOf.js\nvar require_uniqueArrayOf = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/uniqueArrayOf.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = uniqueArrayOfTypeValidator;\n    var _propTypes = require_prop_types();\n    var _and = _interopRequireDefault(require_and());\n    var _uniqueArray = _interopRequireDefault(require_uniqueArray());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly)\n          symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n        keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n          ownKeys(Object(source), true).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n          });\n        } else if (Object.getOwnPropertyDescriptors) {\n          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n          ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n          });\n        }\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var unique = (0, _uniqueArray[\"default\"])();\n    function uniqueArrayOfTypeValidator(type) {\n      if (typeof type !== \"function\") {\n        throw new TypeError(\"type must be a validator function\");\n      }\n      var mapper = null;\n      var name = \"uniqueArrayOfType\";\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n      if (rest.length === 1) {\n        if (typeof rest[0] === \"function\") {\n          mapper = rest[0];\n        } else if (typeof rest[0] === \"string\") {\n          name = rest[0];\n        } else {\n          throw new TypeError(\"single input must either be string or function\");\n        }\n      } else if (rest.length === 2) {\n        if (typeof rest[0] === \"function\" && typeof rest[1] === \"string\") {\n          mapper = rest[0];\n          name = rest[1];\n        } else {\n          throw new TypeError(\"multiple inputs must be in [function, string] order\");\n        }\n      } else if (rest.length > 2) {\n        throw new TypeError(\"only [], [name], [mapper], and [mapper, name] are valid inputs\");\n      }\n      function uniqueArrayOfMapped(props, propName) {\n        var propValue = props[propName];\n        if (propValue == null) {\n          return null;\n        }\n        var values = propValue.map(mapper);\n        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n        return unique.apply(void 0, [_objectSpread(_objectSpread({}, props), {}, _defineProperty({}, propName, values)), propName].concat(args));\n      }\n      uniqueArrayOfMapped.isRequired = function isRequired(props, propName) {\n        var propValue = props[propName];\n        for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          args[_key3 - 2] = arguments[_key3];\n        }\n        if (propValue == null) {\n          return _propTypes.array.isRequired.apply(_propTypes.array, [props, propName].concat(args));\n        }\n        return uniqueArrayOfMapped.apply(void 0, [props, propName].concat(args));\n      };\n      var arrayValidator = (0, _propTypes.arrayOf)(type);\n      var uniqueValidator = mapper ? uniqueArrayOfMapped : unique;\n      var validator = (0, _and[\"default\"])([arrayValidator, uniqueValidator], name);\n      validator.isRequired = (0, _and[\"default\"])([uniqueValidator.isRequired, arrayValidator.isRequired], \"\".concat(name, \".isRequired\"));\n      return validator;\n    }\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/index.js\nvar require_build2 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/build/index.js\"(exports, module2) {\n    \"use strict\";\n    var _propTypesExact = _interopRequireDefault(require_build());\n    var _and = _interopRequireDefault(require_and());\n    var _between = _interopRequireDefault(require_between());\n    var _booleanSome = _interopRequireDefault(require_booleanSome());\n    var _childrenHavePropXorChildren = _interopRequireDefault(require_childrenHavePropXorChildren());\n    var _childrenOf = _interopRequireDefault(require_childrenOf());\n    var _childrenOfType = _interopRequireDefault(require_childrenOfType());\n    var _childrenSequenceOf = _interopRequireDefault(require_childrenSequenceOf());\n    var _componentWithName = _interopRequireDefault(require_componentWithName());\n    var _disallowedIf = _interopRequireDefault(require_disallowedIf());\n    var _elementType = _interopRequireDefault(require_elementType());\n    var _empty = _interopRequireDefault(require_empty());\n    var _explicitNull = _interopRequireDefault(require_explicitNull());\n    var _integer = _interopRequireDefault(require_integer());\n    var _keysOf = _interopRequireDefault(require_keysOf());\n    var _mutuallyExclusiveProps = _interopRequireDefault(require_mutuallyExclusiveProps());\n    var _mutuallyExclusiveTrueProps = _interopRequireDefault(require_mutuallyExclusiveTrueProps());\n    var _nChildren = _interopRequireDefault(require_nChildren());\n    var _nonNegativeInteger = _interopRequireDefault(require_nonNegativeInteger());\n    var _nonNegativeNumber = _interopRequireDefault(require_nonNegativeNumber());\n    var _numericString = _interopRequireDefault(require_numericString());\n    var _object = _interopRequireDefault(require_object3());\n    var _or = _interopRequireDefault(require_or());\n    var _predicate = _interopRequireDefault(require_predicate());\n    var _range = _interopRequireDefault(require_range());\n    var _ref = _interopRequireDefault(require_ref());\n    var _requiredBy = _interopRequireDefault(require_requiredBy());\n    var _restrictedProp = _interopRequireDefault(require_restrictedProp());\n    var _sequenceOf = _interopRequireDefault(require_sequenceOf());\n    var _shape = _interopRequireDefault(require_shape());\n    var _stringEndsWith = _interopRequireDefault(require_stringEndsWith());\n    var _stringStartsWith = _interopRequireDefault(require_stringStartsWith());\n    var _uniqueArray = _interopRequireDefault(require_uniqueArray());\n    var _uniqueArrayOf = _interopRequireDefault(require_uniqueArrayOf());\n    var _valuesOf = _interopRequireDefault(require_valuesOf());\n    var _withShape = _interopRequireDefault(require_withShape());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    module2.exports = {\n      and: _and[\"default\"],\n      between: _between[\"default\"],\n      booleanSome: _booleanSome[\"default\"],\n      childrenHavePropXorChildren: _childrenHavePropXorChildren[\"default\"],\n      childrenOf: _childrenOf[\"default\"],\n      childrenOfType: _childrenOfType[\"default\"],\n      childrenSequenceOf: _childrenSequenceOf[\"default\"],\n      componentWithName: _componentWithName[\"default\"],\n      disallowedIf: _disallowedIf[\"default\"],\n      elementType: _elementType[\"default\"],\n      empty: _empty[\"default\"],\n      explicitNull: _explicitNull[\"default\"],\n      forbidExtraProps: _propTypesExact[\"default\"],\n      integer: _integer[\"default\"],\n      keysOf: _keysOf[\"default\"],\n      mutuallyExclusiveProps: _mutuallyExclusiveProps[\"default\"],\n      mutuallyExclusiveTrueProps: _mutuallyExclusiveTrueProps[\"default\"],\n      nChildren: _nChildren[\"default\"],\n      nonNegativeInteger: _nonNegativeInteger[\"default\"],\n      nonNegativeNumber: _nonNegativeNumber[\"default\"],\n      numericString: _numericString[\"default\"],\n      object: _object[\"default\"],\n      or: _or[\"default\"],\n      predicate: _predicate[\"default\"],\n      range: _range[\"default\"],\n      ref: _ref[\"default\"],\n      requiredBy: _requiredBy[\"default\"],\n      restrictedProp: _restrictedProp[\"default\"],\n      sequenceOf: _sequenceOf[\"default\"],\n      shape: _shape[\"default\"],\n      stringEndsWith: _stringEndsWith[\"default\"],\n      stringStartsWith: _stringStartsWith[\"default\"],\n      uniqueArray: _uniqueArray[\"default\"],\n      uniqueArrayOf: _uniqueArrayOf[\"default\"],\n      valuesOf: _valuesOf[\"default\"],\n      withShape: _withShape[\"default\"]\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/index.js\nvar require_airbnb_prop_types = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/airbnb-prop-types-virtual-2dbacd412b/0/cache/airbnb-prop-types-npm-2.16.0-d794f5271c-393a5988b9.zip/node_modules/airbnb-prop-types/index.js\"(exports, module2) {\n    module2.exports =  false ? 0 : require_build2();\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/consolidated-events-npm-2.0.2-4a127006c6-3ffb9fa264.zip/node_modules/consolidated-events/lib/index.js\nvar require_lib = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/consolidated-events-npm-2.0.2-4a127006c6-3ffb9fa264.zip/node_modules/consolidated-events/lib/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var CAN_USE_DOM = !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n    function testPassiveEventListeners() {\n      if (!CAN_USE_DOM) {\n        return false;\n      }\n      if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n        return false;\n      }\n      var supportsPassiveOption = false;\n      try {\n        var opts = Object.defineProperty({}, \"passive\", {\n          get: function() {\n            function get() {\n              supportsPassiveOption = true;\n            }\n            return get;\n          }()\n        });\n        var noop = function noop2() {\n        };\n        window.addEventListener(\"testPassiveEventSupport\", noop, opts);\n        window.removeEventListener(\"testPassiveEventSupport\", noop, opts);\n      } catch (e) {\n      }\n      return supportsPassiveOption;\n    }\n    var memoized = void 0;\n    function canUsePassiveEventListeners() {\n      if (memoized === void 0) {\n        memoized = testPassiveEventListeners();\n      }\n      return memoized;\n    }\n    function normalizeEventOptions(eventOptions) {\n      if (!eventOptions) {\n        return void 0;\n      }\n      if (!canUsePassiveEventListeners()) {\n        return !!eventOptions.capture;\n      }\n      return eventOptions;\n    }\n    function eventOptionsKey(normalizedEventOptions) {\n      if (!normalizedEventOptions) {\n        return 0;\n      }\n      if (normalizedEventOptions === true) {\n        return 100;\n      }\n      var capture = normalizedEventOptions.capture << 0;\n      var passive = normalizedEventOptions.passive << 1;\n      var once = normalizedEventOptions.once << 2;\n      return capture + passive + once;\n    }\n    function ensureCanMutateNextEventHandlers(eventHandlers) {\n      if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n        eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n      }\n    }\n    function TargetEventHandlers(target) {\n      this.target = target;\n      this.events = {};\n    }\n    TargetEventHandlers.prototype.getEventHandlers = function() {\n      function getEventHandlers(eventName, options) {\n        var key = String(eventName) + \" \" + String(eventOptionsKey(options));\n        if (!this.events[key]) {\n          this.events[key] = {\n            handlers: [],\n            handleEvent: void 0\n          };\n          this.events[key].nextHandlers = this.events[key].handlers;\n        }\n        return this.events[key];\n      }\n      return getEventHandlers;\n    }();\n    TargetEventHandlers.prototype.handleEvent = function() {\n      function handleEvent(eventName, options, event) {\n        var eventHandlers = this.getEventHandlers(eventName, options);\n        eventHandlers.handlers = eventHandlers.nextHandlers;\n        eventHandlers.handlers.forEach(function(handler) {\n          if (handler) {\n            handler(event);\n          }\n        });\n      }\n      return handleEvent;\n    }();\n    TargetEventHandlers.prototype.add = function() {\n      function add(eventName, listener, options) {\n        var _this = this;\n        var eventHandlers = this.getEventHandlers(eventName, options);\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        if (eventHandlers.nextHandlers.length === 0) {\n          eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n          this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n        }\n        eventHandlers.nextHandlers.push(listener);\n        var isSubscribed = true;\n        var unsubscribe = function() {\n          function unsubscribe2() {\n            if (!isSubscribed) {\n              return;\n            }\n            isSubscribed = false;\n            ensureCanMutateNextEventHandlers(eventHandlers);\n            var index = eventHandlers.nextHandlers.indexOf(listener);\n            eventHandlers.nextHandlers.splice(index, 1);\n            if (eventHandlers.nextHandlers.length === 0) {\n              if (_this.target) {\n                _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n              }\n              eventHandlers.handleEvent = void 0;\n            }\n          }\n          return unsubscribe2;\n        }();\n        return unsubscribe;\n      }\n      return add;\n    }();\n    var EVENT_HANDLERS_KEY = \"__consolidated_events_handlers__\";\n    function addEventListener(target, eventName, listener, options) {\n      if (!target[EVENT_HANDLERS_KEY]) {\n        target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n      }\n      var normalizedEventOptions = normalizeEventOptions(options);\n      return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n    }\n    exports.addEventListener = addEventListener;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/implementation.js\nvar require_implementation8 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/implementation.js\"(exports, module2) {\n    \"use strict\";\n    var RequireObjectCoercible = require_RequireObjectCoercible();\n    var callBound = require_callBound();\n    var $isEnumerable = callBound(\"Object.prototype.propertyIsEnumerable\");\n    var $push = callBound(\"Array.prototype.push\");\n    module2.exports = function values(O) {\n      var obj = RequireObjectCoercible(O);\n      var vals = [];\n      for (var key in obj) {\n        if ($isEnumerable(obj, key)) {\n          $push(vals, obj[key]);\n        }\n      }\n      return vals;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/polyfill.js\nvar require_polyfill6 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/polyfill.js\"(exports, module2) {\n    \"use strict\";\n    var implementation = require_implementation8();\n    module2.exports = function getPolyfill() {\n      return typeof Object.values === \"function\" ? Object.values : implementation;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/shim.js\nvar require_shim6 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/shim.js\"(exports, module2) {\n    \"use strict\";\n    var getPolyfill = require_polyfill6();\n    var define = require_define_properties();\n    module2.exports = function shimValues() {\n      var polyfill = getPolyfill();\n      define(Object, { values: polyfill }, {\n        values: function testValues() {\n          return Object.values !== polyfill;\n        }\n      });\n      return polyfill;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/index.js\nvar require_object4 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/object.values-npm-1.1.5-f1de7f3742-0f17e99741.zip/node_modules/object.values/index.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var callBind = require_call_bind();\n    var implementation = require_implementation8();\n    var getPolyfill = require_polyfill6();\n    var shim = require_shim6();\n    var polyfill = callBind(getPolyfill(), Object);\n    define(polyfill, {\n      getPolyfill,\n      implementation,\n      shim\n    });\n    module2.exports = polyfill;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/implementation.js\nvar require_implementation9 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/implementation.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function contains(other) {\n      if (arguments.length < 1) {\n        throw new TypeError(\"1 argument is required\");\n      }\n      if (typeof other !== \"object\") {\n        throw new TypeError(\"Argument 1 (\\u201Dother\\u201C) to Node.contains must be an instance of Node\");\n      }\n      var node = other;\n      do {\n        if (this === node) {\n          return true;\n        }\n        if (node) {\n          node = node.parentNode;\n        }\n      } while (node);\n      return false;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/polyfill.js\nvar require_polyfill7 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/polyfill.js\"(exports, module2) {\n    \"use strict\";\n    var implementation = require_implementation9();\n    module2.exports = function getPolyfill() {\n      if (typeof document !== \"undefined\") {\n        if (document.contains) {\n          return document.contains;\n        }\n        if (document.body && document.body.contains) {\n          try {\n            if (typeof document.body.contains.call(document, \"\") === \"boolean\") {\n              return document.body.contains;\n            }\n          } catch (e) {\n          }\n        }\n      }\n      return implementation;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/shim.js\nvar require_shim7 = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/shim.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var getPolyfill = require_polyfill7();\n    module2.exports = function shimContains() {\n      var polyfill = getPolyfill();\n      if (typeof document !== \"undefined\") {\n        define(document, { contains: polyfill }, { contains: function() {\n          return document.contains !== polyfill;\n        } });\n        if (typeof Element !== \"undefined\") {\n          define(Element.prototype, { contains: polyfill }, { contains: function() {\n            return Element.prototype.contains !== polyfill;\n          } });\n        }\n      }\n      return polyfill;\n    };\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/index.js\nvar require_document = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/cache/document.contains-npm-1.0.2-b186799607-dbb8c1f6ec.zip/node_modules/document.contains/index.js\"(exports, module2) {\n    \"use strict\";\n    var define = require_define_properties();\n    var implementation = require_implementation9();\n    var getPolyfill = require_polyfill7();\n    var polyfill = getPolyfill();\n    var shim = require_shim7();\n    var boundContains = function contains(node, other) {\n      return polyfill.apply(node, [other]);\n    };\n    define(boundContains, {\n      getPolyfill,\n      implementation,\n      shim\n    });\n    module2.exports = boundContains;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/react-outside-click-handler-virtual-7bddcab458/0/cache/react-outside-click-handler-npm-1.3.0-7fa0d196a3-c3afc3ce1c.zip/node_modules/react-outside-click-handler/build/OutsideClickHandler.js\nvar require_OutsideClickHandler = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/react-outside-click-handler-virtual-7bddcab458/0/cache/react-outside-click-handler-npm-1.3.0-7fa0d196a3-c3afc3ce1c.zip/node_modules/react-outside-click-handler/build/OutsideClickHandler.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var _createClass = function() {\n      function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor)\n            descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n      return function(Constructor, protoProps, staticProps) {\n        if (protoProps)\n          defineProperties(Constructor.prototype, protoProps);\n        if (staticProps)\n          defineProperties(Constructor, staticProps);\n        return Constructor;\n      };\n    }();\n    var _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n    var _react2 = _interopRequireDefault(_react);\n    var _propTypes = require_prop_types();\n    var _propTypes2 = _interopRequireDefault(_propTypes);\n    var _airbnbPropTypes = require_airbnb_prop_types();\n    var _consolidatedEvents = require_lib();\n    var _object = require_object4();\n    var _object2 = _interopRequireDefault(_object);\n    var _document = require_document();\n    var _document2 = _interopRequireDefault(_document);\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _possibleConstructorReturn(self, call) {\n      if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n      if (superClass)\n        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n    var DISPLAY = {\n      BLOCK: \"block\",\n      FLEX: \"flex\",\n      INLINE: \"inline\",\n      INLINE_BLOCK: \"inline-block\",\n      CONTENTS: \"contents\"\n    };\n    var propTypes = (0, _airbnbPropTypes.forbidExtraProps)({\n      children: _propTypes2[\"default\"].node.isRequired,\n      onOutsideClick: _propTypes2[\"default\"].func.isRequired,\n      disabled: _propTypes2[\"default\"].bool,\n      useCapture: _propTypes2[\"default\"].bool,\n      display: _propTypes2[\"default\"].oneOf((0, _object2[\"default\"])(DISPLAY))\n    });\n    var defaultProps = {\n      disabled: false,\n      useCapture: true,\n      display: DISPLAY.BLOCK\n    };\n    var OutsideClickHandler = function(_React$Component) {\n      _inherits(OutsideClickHandler2, _React$Component);\n      function OutsideClickHandler2() {\n        var _ref;\n        _classCallCheck(this, OutsideClickHandler2);\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var _this = _possibleConstructorReturn(this, (_ref = OutsideClickHandler2.__proto__ || Object.getPrototypeOf(OutsideClickHandler2)).call.apply(_ref, [this].concat(args)));\n        _this.onMouseDown = _this.onMouseDown.bind(_this);\n        _this.onMouseUp = _this.onMouseUp.bind(_this);\n        _this.setChildNodeRef = _this.setChildNodeRef.bind(_this);\n        return _this;\n      }\n      _createClass(OutsideClickHandler2, [{\n        key: \"componentDidMount\",\n        value: function() {\n          function componentDidMount() {\n            var _props = this.props, disabled = _props.disabled, useCapture = _props.useCapture;\n            if (!disabled)\n              this.addMouseDownEventListener(useCapture);\n          }\n          return componentDidMount;\n        }()\n      }, {\n        key: \"componentDidUpdate\",\n        value: function() {\n          function componentDidUpdate(_ref2) {\n            var prevDisabled = _ref2.disabled;\n            var _props2 = this.props, disabled = _props2.disabled, useCapture = _props2.useCapture;\n            if (prevDisabled !== disabled) {\n              if (disabled) {\n                this.removeEventListeners();\n              } else {\n                this.addMouseDownEventListener(useCapture);\n              }\n            }\n          }\n          return componentDidUpdate;\n        }()\n      }, {\n        key: \"componentWillUnmount\",\n        value: function() {\n          function componentWillUnmount() {\n            this.removeEventListeners();\n          }\n          return componentWillUnmount;\n        }()\n      }, {\n        key: \"onMouseDown\",\n        value: function() {\n          function onMouseDown(e) {\n            var useCapture = this.props.useCapture;\n            var isDescendantOfRoot = this.childNode && (0, _document2[\"default\"])(this.childNode, e.target);\n            if (!isDescendantOfRoot) {\n              if (this.removeMouseUp) {\n                this.removeMouseUp();\n                this.removeMouseUp = null;\n              }\n              this.removeMouseUp = (0, _consolidatedEvents.addEventListener)(document, \"mouseup\", this.onMouseUp, { capture: useCapture });\n            }\n          }\n          return onMouseDown;\n        }()\n      }, {\n        key: \"onMouseUp\",\n        value: function() {\n          function onMouseUp(e) {\n            var onOutsideClick = this.props.onOutsideClick;\n            var isDescendantOfRoot = this.childNode && (0, _document2[\"default\"])(this.childNode, e.target);\n            if (this.removeMouseUp) {\n              this.removeMouseUp();\n              this.removeMouseUp = null;\n            }\n            if (!isDescendantOfRoot) {\n              onOutsideClick(e);\n            }\n          }\n          return onMouseUp;\n        }()\n      }, {\n        key: \"setChildNodeRef\",\n        value: function() {\n          function setChildNodeRef(ref) {\n            this.childNode = ref;\n          }\n          return setChildNodeRef;\n        }()\n      }, {\n        key: \"addMouseDownEventListener\",\n        value: function() {\n          function addMouseDownEventListener(useCapture) {\n            this.removeMouseDown = (0, _consolidatedEvents.addEventListener)(document, \"mousedown\", this.onMouseDown, { capture: useCapture });\n          }\n          return addMouseDownEventListener;\n        }()\n      }, {\n        key: \"removeEventListeners\",\n        value: function() {\n          function removeEventListeners() {\n            if (this.removeMouseDown)\n              this.removeMouseDown();\n            if (this.removeMouseUp)\n              this.removeMouseUp();\n          }\n          return removeEventListeners;\n        }()\n      }, {\n        key: \"render\",\n        value: function() {\n          function render() {\n            var _props3 = this.props, children = _props3.children, display = _props3.display;\n            return _react2[\"default\"].createElement(\"div\", {\n              ref: this.setChildNodeRef,\n              style: display !== DISPLAY.BLOCK && (0, _object2[\"default\"])(DISPLAY).includes(display) ? { display } : void 0\n            }, children);\n          }\n          return render;\n        }()\n      }]);\n      return OutsideClickHandler2;\n    }(_react2[\"default\"].Component);\n    exports[\"default\"] = OutsideClickHandler;\n    OutsideClickHandler.propTypes = propTypes;\n    OutsideClickHandler.defaultProps = defaultProps;\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/react-outside-click-handler-virtual-7bddcab458/0/cache/react-outside-click-handler-npm-1.3.0-7fa0d196a3-c3afc3ce1c.zip/node_modules/react-outside-click-handler/index.js\nvar require_react_outside_click_handler = __commonJS({\n  \"pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/.yarn/__virtual__/react-outside-click-handler-virtual-7bddcab458/0/cache/react-outside-click-handler-npm-1.3.0-7fa0d196a3-c3afc3ce1c.zip/node_modules/react-outside-click-handler/index.js\"(exports, module2) {\n    module2.exports = require_OutsideClickHandler();\n  }\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/index.ts\n__export(exports, {\n  Body1: () => Body1,\n  Body2: () => Body2,\n  Body3: () => Body3,\n  Botton: () => Botton,\n  Button: () => Button,\n  ButtonElement: () => ButtonElement,\n  Caption: () => Caption,\n  Select: () => Select,\n  Subtitle1: () => Subtitle1,\n  Subtitle2: () => Subtitle2,\n  Subtitle3: () => Subtitle3,\n  Subtitle4: () => Subtitle4,\n  SwitchButton: () => SwitchButton,\n  Title1: () => Title1,\n  Title2: () => Title2,\n  Title3: () => Title3,\n  ToggleButton: () => ToggleButton\n});\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/Button/index.tsx\nvar import_react16 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar import_styled2 = __toModule(__webpack_require__(/*! @emotion/styled */ \"./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js\"));\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Title1.tsx\nvar import_react3 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/BaseTypography/index.tsx\nvar import_react2 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar import_styled = __toModule(__webpack_require__(/*! @emotion/styled */ \"./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js\"));\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/BaseTypography/textStyles.ts\nvar import_react = __toModule(__webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\"));\nvar title1 = import_react.css`\n    font-size: 40px;\n    line-height: 60px;\n`;\nvar title2 = import_react.css`\n    font-size: 36px;\n    line-height: 54px;\n`;\nvar title3 = import_react.css`\n    font-size: 32px;\n    line-height: 48px;\n`;\nvar subtitle1 = import_react.css`\n    font-size: 32px;\n    line-height: 48px;\n`;\nvar subtitle2 = import_react.css`\n    font-size: 28px;\n    line-height: 32px;\n`;\nvar subtitle3 = import_react.css`\n    font-size: 24px;  \n    line-height: 36px;\n`;\nvar subtitle4 = import_react.css`\n    font-size: 20px;\n    line-height: 28px;\n`;\nvar body1 = import_react.css`\n    font-size: 16px;\n    line-height: 24px;\n`;\nvar body2 = import_react.css`\n    font-size: 14px;\n    line-height: 20px;\n`;\nvar body3 = import_react.css`\n    font-size: 12px;\n    line-height: 16px;\n`;\nvar botton = import_react.css`\n    font-size: 14px;\n    line-height: 20px;\n`;\nvar caption = import_react.css`\n    font-size: 12px;\n    line-height: 16px;\n`;\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/BaseTypography/index.tsx\nvar defaultElement = {\n  Title1: \"h1\",\n  Title2: \"h2\",\n  Title3: \"h3\",\n  Subtitle1: \"h4\",\n  Subtitle2: \"h5\",\n  Subtitle3: \"h6\",\n  Subtitle4: \"h6\",\n  Body1: \"p\",\n  Body2: \"p\",\n  Body3: \"p\",\n  Caption: \"div\",\n  Botton: \"div\"\n};\nvar defaultWeight = {\n  Title1: \"bold\",\n  Title2: \"bold\",\n  Title3: \"bold\",\n  Subtitle1: \"medium\",\n  Subtitle2: \"medium\",\n  Subtitle3: \"medium\",\n  Subtitle4: \"medium\",\n  Body1: \"regular\",\n  Body2: \"regular\",\n  Body3: \"regular\",\n  Caption: \"regular\",\n  Botton: \"regular\"\n};\nvar typographyList = {\n  Title1: title1,\n  Title2: title2,\n  Title3: title3,\n  Subtitle1: subtitle1,\n  Subtitle2: subtitle2,\n  Subtitle3: subtitle3,\n  Subtitle4: subtitle4,\n  Body1: body1,\n  Body2: body2,\n  Body3: body3,\n  Caption: caption,\n  Botton: botton\n};\nvar TextElement = import_styled.default.div`\n    margin: 0;\n    color: ${({ theme, color }) => color ? theme.colors[color] : theme.colors.black};\n    font-weight: ${({ fontWeight, md, theme }) => fontWeight ? theme.fonts.weight[fontWeight] : theme.fonts.weight[defaultWeight[md]]};\n    ${(props) => props.textAlign && `text-align: ${props.textAlign}`};\n    ${(props) => typographyList[props.md]};\n`;\nvar BaseTypography = (props) => {\n  const { children, md, ...restProps } = props;\n  const element = defaultElement[md];\n  return /* @__PURE__ */ import_react2.default.createElement(TextElement, {\n    md,\n    as: element,\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Title1.tsx\nvar Title1 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react3.default.createElement(BaseTypography, {\n    md: \"Title1\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Title2.tsx\nvar import_react4 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Title2 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react4.default.createElement(BaseTypography, {\n    md: \"Title2\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Title3.tsx\nvar import_react5 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Title3 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react5.default.createElement(BaseTypography, {\n    md: \"Title3\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Subtitle1.tsx\nvar import_react6 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Subtitle1 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react6.default.createElement(BaseTypography, {\n    md: \"Subtitle1\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Subtitle2.tsx\nvar import_react7 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Subtitle2 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react7.default.createElement(BaseTypography, {\n    md: \"Subtitle2\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Subtitle3.tsx\nvar import_react8 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Subtitle3 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react8.default.createElement(BaseTypography, {\n    md: \"Subtitle3\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Subtitle4.tsx\nvar import_react9 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Subtitle4 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react9.default.createElement(BaseTypography, {\n    md: \"Subtitle4\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Body1.tsx\nvar import_react10 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Body1 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react10.default.createElement(BaseTypography, {\n    md: \"Body1\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Body2.tsx\nvar import_react11 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Body2 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react11.default.createElement(BaseTypography, {\n    md: \"Body2\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Body3.tsx\nvar import_react12 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Body3 = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react12.default.createElement(BaseTypography, {\n    md: \"Body3\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Botton.tsx\nvar import_react13 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Botton = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react13.default.createElement(BaseTypography, {\n    md: \"Botton\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/typography/Caption.tsx\nvar import_react14 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Caption = (props) => {\n  const { children, ...restProps } = props;\n  return /* @__PURE__ */ import_react14.default.createElement(BaseTypography, {\n    md: \"Caption\",\n    ...restProps\n  }, children);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/Button/types.ts\nvar Colors = {\n  default: \"gray50\",\n  purple: \"purple400\",\n  purpleLight: \"purple50\",\n  border: \"white\",\n  borderColor: \"gray300\",\n  link: \"white\",\n  bnDefault: \"white\",\n  bnPurple: \"white\"\n};\nvar ActiveColors = {\n  default: \"gray200\",\n  purple: \"purple500\",\n  purpleLight: \"purple100\",\n  border: \"gray50\",\n  link: \"white\",\n  bnDefault: \"gray50\",\n  bnPurple: \"purple50\"\n};\nvar FontColors = {\n  default: \"gray700\",\n  purple: \"white\",\n  purpleLight: \"purple400\",\n  border: \"gray700\",\n  link: \"blue400\",\n  full: \"gray700\",\n  bnDefault: \"gray700\",\n  bnPurple: \"purple400\"\n};\nvar DisabledColors = {\n  default: \"gray50\",\n  purple: \"purple50\",\n  purpleLight: \"gray50\",\n  border: \"gray50\",\n  link: \"gray50\",\n  bnDefault: \"gray50\",\n  bnPurple: \"gray50\"\n};\nvar DisabledFontColors = {\n  default: \"gray300\",\n  purple: \"white\",\n  purpleLight: \"gray300\",\n  border: \"gray200\",\n  link: \"gray300\",\n  bnDefault: \"gray300\",\n  bnPurple: \"gray300\"\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/Button/utils.ts\nfunction colorObjectToColorString(color, addedBn) {\n  if (typeof color === \"string\")\n    return color || \"default\";\n  else if (typeof color === \"undefined\")\n    return \"default\";\n  else if (addedBn && color.background === false) {\n    switch (color.fillStyle) {\n      case \"default\":\n        return firstCharToTypeMessage(color.fillStyle);\n      case \"purple\":\n        return firstCharToTypeMessage(color.fillStyle);\n      default:\n        return color.fillStyle || \"default\";\n    }\n  } else\n    return color.fillStyle || \"default\";\n}\nfunction firstCharToTypeMessage(message) {\n  return \"bn\" + message.charAt(0).toUpperCase() + message.slice(1);\n}\nfunction isBackgroundNone(color) {\n  if (color.indexOf(\"bn\") !== -1)\n    return true;\n  else\n    return false;\n}\nfunction fillStyleToColorString(fillStyle, colroState) {\n  switch (colroState) {\n    case \"default\":\n      return Colors[fillStyle];\n    case \"active\":\n      return ActiveColors[fillStyle];\n    case \"font\":\n      return FontColors[fillStyle];\n    case \"diabled\":\n      return DisabledColors[fillStyle];\n    case \"disabledFont\":\n      return DisabledFontColors[fillStyle];\n  }\n}\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/Button/styles.ts\nvar import_react15 = __toModule(__webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\"));\nvar full = () => import_react15.css`\n    width: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 0;\n`;\nvar link = (props) => import_react15.css`\n    &:hover,\n    &:active {\n        text-decoration: underline 1px solid ${props.theme.colors[props.color]};\n    }\n`;\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/Button/index.tsx\nvar Cursor;\n(function(Cursor2) {\n  Cursor2[\"DISABLED\"] = \"not-allowed\";\n  Cursor2[\"LOADING\"] = \"progress\";\n  Cursor2[\"DEFAULT\"] = \"pointer\";\n})(Cursor || (Cursor = {}));\nvar PaddingVertical;\n(function(PaddingVertical2) {\n  PaddingVertical2[PaddingVertical2[\"lg\"] = 16] = \"lg\";\n  PaddingVertical2[PaddingVertical2[\"md\"] = 16] = \"md\";\n  PaddingVertical2[PaddingVertical2[\"sm\"] = 8] = \"sm\";\n})(PaddingVertical || (PaddingVertical = {}));\nvar PaddingHorizontal;\n(function(PaddingHorizontal2) {\n  PaddingHorizontal2[PaddingHorizontal2[\"lg\"] = 150] = \"lg\";\n  PaddingHorizontal2[PaddingHorizontal2[\"md\"] = 68] = \"md\";\n  PaddingHorizontal2[PaddingHorizontal2[\"sm\"] = 16] = \"sm\";\n})(PaddingHorizontal || (PaddingHorizontal = {}));\nvar BorderRadius;\n(function(BorderRadius2) {\n  BorderRadius2[BorderRadius2[\"lg\"] = 12] = \"lg\";\n  BorderRadius2[BorderRadius2[\"md\"] = 12] = \"md\";\n  BorderRadius2[BorderRadius2[\"sm\"] = 4] = \"sm\";\n})(BorderRadius || (BorderRadius = {}));\nvar ButtonElement = import_styled2.default.button`\n    display: flex;\n    align-items: center;\n    border: none;\n    outline: none;\n    cursor: ${(props) => props.cursor};\n    background: ${(props) => props.theme.colors[props.background]};\n    padding: ${(props) => `${props.paddingVertical}px ${props.paddingHorizontal}px`};\n    border-radius: ${(props) => props.borderRadius}px;\n    border: 1px solid ${(props) => props.theme.colors[props.borderColor]};\n\n    ${(props) => props.fullWidth && full()}\n\n    ${(props) => props.fillStyle === \"link\" && link(props)}\n    @media(hover: hover) {\n        &:hover {\n            background: ${(props) => props.theme.colors[props.activeBackground]};\n        }\n    }\n    -webkit-tap-highlight-color: transparent;\n    &:active {\n        background: ${(props) => props.theme.colors[props.activeBackground]};\n    }\n\n    & .semicolon-button-typography {\n        margin-left: ${(props) => props.marginLeft}px;\n        margin-right: ${(props) => props.marginRight}px;\n    }\n`;\nvar Button = ({\n  size = \"md\",\n  fill = \"default\",\n  loading = false,\n  disabled = false,\n  leftIcon,\n  rightIcon,\n  onClick,\n  className,\n  children,\n  fullWidth\n}) => {\n  const cursorType = disabled ? \"DISABLED\" : loading ? \"LOADING\" : \"DEFAULT\";\n  const colorString = colorObjectToColorString(fill, true);\n  const BackgroundColor = disabled ? fillStyleToColorString(colorString, \"diabled\") : fillStyleToColorString(colorString, \"default\");\n  const BackgroundActiveColor = disabled ? fillStyleToColorString(colorString, \"diabled\") : fillStyleToColorString(colorString, \"active\");\n  const FontColor = disabled ? fillStyleToColorString(colorString, \"disabledFont\") : fillStyleToColorString(colorString, \"font\");\n  const styledProps = {\n    cursor: Cursor[cursorType],\n    background: BackgroundColor,\n    activeBackground: loading && isBackgroundNone(colorString) ? BackgroundColor : BackgroundActiveColor,\n    paddingVertical: PaddingVertical[size],\n    paddingHorizontal: PaddingHorizontal[size],\n    borderRadius: BorderRadius[size],\n    borderColor: colorString === \"border\" ? Colors[\"borderColor\"] : BackgroundColor,\n    size,\n    fillStyle: colorString,\n    color: FontColor,\n    fullWidth: Boolean(fullWidth),\n    marginLeft: leftIcon ? 6 : 0,\n    marginRight: loading || rightIcon ? 6 : 0\n  };\n  return /* @__PURE__ */ import_react16.default.createElement(ButtonElement, {\n    className,\n    onClick,\n    disabled,\n    ...styledProps\n  }, leftIcon, /* @__PURE__ */ import_react16.default.createElement(Botton, {\n    className: \"semicolon-button-typography\",\n    color: FontColor\n  }, children), rightIcon);\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/SwitchButton.tsx\nvar import_react17 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar import_styled3 = __toModule(__webpack_require__(/*! @emotion/styled */ \"./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js\"));\nvar Position;\n(function(Position2) {\n  Position2[Position2[\"false\"] = 1] = \"false\";\n  Position2[Position2[\"true\"] = 22] = \"true\";\n})(Position || (Position = {}));\nvar Background;\n(function(Background3) {\n  Background3[\"false\"] = \"gray100\";\n  Background3[\"true\"] = \"purple400\";\n})(Background || (Background = {}));\nvar ButtonWrapperElement = import_styled3.default.div`\n    width: 40px;\n    height: 20px;\n    border-radius: 11px;\n    padding: 1px;\n    cursor: pointer;\n    position: relative;\n    background: ${(props) => props.theme.colors[props.background]};\n    transition: background 0.1s linear;\n`;\nvar ButtonCircle = import_styled3.default.div`\n    position: absolute;\n    width: 18px;\n    height: 18px;\n    border-radius: 50%;\n    background: white;\n    top: 50%;\n    left: 0;\n    transform: translate(${(props) => props.position}px, -50%);\n    transition: transform 0.08s ease-in;\n`;\nvar SwitchButton = ({ value = false, onToggle }) => {\n  const [isActive, setIsActive] = (0, import_react17.useState)(value);\n  const onClick = () => {\n    setIsActive((prevState) => !prevState);\n  };\n  (0, import_react17.useEffect)(() => {\n    if (onToggle)\n      onToggle(isActive);\n  }, [isActive]);\n  const styledProps = {\n    background: Background[isActive ? \"true\" : \"false\"],\n    position: Position[isActive ? \"true\" : \"false\"]\n  };\n  return /* @__PURE__ */ import_react17.default.createElement(ButtonWrapperElement, {\n    onClick,\n    background: styledProps.background\n  }, /* @__PURE__ */ import_react17.default.createElement(ButtonCircle, {\n    position: styledProps.position\n  }));\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/ToggleButton.tsx\nvar import_react18 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar import_styled4 = __toModule(__webpack_require__(/*! @emotion/styled */ \"./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js\"));\nvar Container = import_styled4.default.div`\n    width: 100%;\n    padding: 4px;\n    overflow: hidden;\n    border-radius: 22px;\n    display: flex;\n    position: relative;\n`;\nvar ButtonWrapper = import_styled4.default.div`\n    width: 100%;\n    display: flex;\n    position: relative;\n`;\nvar Button2 = import_styled4.default.button`\n    border-radius: 22px;\n    padding: 8px 0;\n    flex: 1;\n    z-index: 3;\n    cursor: pointer;\n    border: none;\n    background: none;\n`;\nvar ActiveBackground = import_styled4.default.div`\n    width: calc(${(props) => 100 / props.length}%);\n    height: 100%;\n    border-radius: 22px;\n    position: absolute;\n    background: white;\n    z-index: 2;\n    transform: translateX(${(props) => (props.activeNumber - 1) * 100}%);\n    transition: all 0.3s cubic-bezier(0.5, 1, 0.89, 1);\n`;\nvar Background2 = import_styled4.default.div`\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: ${(props) => props.theme.colors.gray100};\n    z-index: 1;\n`;\nvar ToggleButton = ({ items, containStyle, defaultValue = 1 }) => {\n  const rangeValue = defaultValue < 1 ? 1 : defaultValue > items.length ? items.length : defaultValue;\n  const [activeNumber, setActiveNumber] = (0, import_react18.useState)(rangeValue);\n  const buttonOnClick = (number, e, callback) => {\n    setActiveNumber(number);\n    if (callback)\n      callback(e);\n  };\n  return /* @__PURE__ */ import_react18.default.createElement(Container, {\n    style: containStyle\n  }, /* @__PURE__ */ import_react18.default.createElement(Background2, null), /* @__PURE__ */ import_react18.default.createElement(ButtonWrapper, null, /* @__PURE__ */ import_react18.default.createElement(ActiveBackground, {\n    activeNumber,\n    length: items.length\n  }), items.map(({ title, onClick, buttonStyle }, i) => /* @__PURE__ */ import_react18.default.createElement(Button2, {\n    style: buttonStyle,\n    onClick: (e) => buttonOnClick(i + 1, e, onClick),\n    key: i\n  }, /* @__PURE__ */ import_react18.default.createElement(Botton, {\n    color: \"gray700\"\n  }, title)))));\n};\n\n// pnp:/home/runner/work/SemicolonDesign_Frontend/SemicolonDesign_Frontend/packages/ui/src/components/Select.tsx\nvar import_react19 = __toModule(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar import_styled5 = __toModule(__webpack_require__(/*! @emotion/styled */ \"./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js\"));\nvar import_react_outside_click_handler = __toModule(require_react_outside_click_handler());\nvar direction = {\n  center: \"center\",\n  left: \"flex-end\",\n  right: \"flex-start\"\n};\nvar Select = ({\n  items,\n  value,\n  overflowOptionDirection = \"right\",\n  onChange,\n  placeholder\n}) => {\n  const [isOpen, setIsOpen] = (0, import_react19.useState)(false);\n  const [text, setText] = (0, import_react19.useState)(value ? value : placeholder);\n  return /* @__PURE__ */ import_react19.default.createElement(import_react_outside_click_handler.default, {\n    onOutsideClick: () => setIsOpen(false)\n  }, /* @__PURE__ */ import_react19.default.createElement(SelectButtonBox, {\n    overflowOptionDirection,\n    onClick: () => setIsOpen(!isOpen)\n  }, /* @__PURE__ */ import_react19.default.createElement(SelectMainBox, null, /* @__PURE__ */ import_react19.default.createElement(Body2, {\n    className: \"select-title\"\n  }, text), /* @__PURE__ */ import_react19.default.createElement(DropDownIcon, null, /* @__PURE__ */ import_react19.default.createElement(\"svg\", {\n    width: \"12\",\n    height: \"6\",\n    viewBox: \"0 0 12 6\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, /* @__PURE__ */ import_react19.default.createElement(\"path\", {\n    d: \"M0 0L6 6L12 0H0Z\",\n    fill: \"#98959E\"\n  })))), /* @__PURE__ */ import_react19.default.createElement(DropDownMenuWrapper, {\n    isVisiable: isOpen\n  }, items.map((title, i) => /* @__PURE__ */ import_react19.default.createElement(DropDownOption, {\n    key: i,\n    onClick: () => {\n      if (onChange)\n        onChange(title);\n      setText(title);\n    }\n  }, /* @__PURE__ */ import_react19.default.createElement(Body2, {\n    className: \"select-title\"\n  }, title))))));\n};\nvar SelectMainBox = import_styled5.default.div`\n    padding: 0 12px;\n    display: flex;\n    align-items: center;\n    height: 36px;\n    border-radius: 4px;\n    background: ${({ theme }) => theme.colors.gray100};\n    color: ${({ theme }) => theme.colors.gray700};\n    width: 100%;\n    .select-title {\n        width: 60px;\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        overflow: hidden;\n    }\n    cursor: pointer;\n    :hover,\n    :active {\n        background: ${({ theme }) => theme.colors.gray300};\n    }\n`;\nvar SelectButtonBox = import_styled5.default.div`\n    border-radius: 4px;\n    width: 104px;\n    display: flex;\n    align-items: center;\n    position: relative;\n    justify-content: ${({ overflowOptionDirection }) => direction[overflowOptionDirection]};\n`;\nvar DropDownIcon = import_styled5.default.div`\n    width: 16px;\n    height: 16px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: absolute;\n    right: 13px;\n    top: 10px;\n`;\nvar DropDownMenuWrapper = import_styled5.default.div`\n    display: ${({ isVisiable }) => isVisiable ? \"block\" : \"none\"};\n    position: absolute;\n    min-width: 100%;\n    z-index: ${Math.pow(10, 10)};\n    border: 1px solid ${({ theme }) => theme.colors.gray300};\n    top: 40px;\n    padding: 4px 0;\n    border-radius: 4px;\n    background-color: ${({ theme }) => theme.colors.white};\n`;\nvar DropDownOption = import_styled5.default.div`\n    height: 28px;\n    padding: 0 15px;\n    white-space: nowrap;\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    :hover {\n        background: ${({ theme }) => theme.colors.purple400};\n        .select-title {\n            color: ${({ theme }) => theme.colors.white};\n            white-space: nowrap;\n        }\n    }\n`;\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNlbWljb2xvbmRzbS91aS9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQUssRUFBRSxFQUVWLENBQUM7QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsMklBQTJJO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRNQUE0TSxjQUFjO0FBQzFOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSSw0RkFBNEYsQ0FBTTtBQUNoSDtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssRUFFTjtBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsaUZBQWlGLHNDQUFzQztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4Q0FBOEM7QUFDdEYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxRQUFRO0FBQ1Isc0RBQXNEO0FBQ3RELFFBQVE7QUFDUiw0REFBNEQ7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLFVBQVU7QUFDL0M7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTLFVBQVU7QUFDN0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0VBQXNFO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE1BQU07QUFDckQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQixJQUFJO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2REFBNkQ7QUFDdkcsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixhQUFhO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUE2RDtBQUN2RyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwrQkFBK0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkNBQTZDLFVBQVUsb0JBQW9CO0FBQzNFLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVSxvQkFBb0I7QUFDM0UsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsYUFBYTtBQUM1RztBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUN2RDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUN2RDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkRBQTZEO0FBQ3ZHLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsWUFBWTtBQUNsRjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixhQUFhO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUN2RDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixhQUFhO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUE2RDtBQUN2RyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUc7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixZQUFZLG9CQUFvQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsZUFBZTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkRBQTZEO0FBQ3ZHLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGFBQWE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBLHdFQUF3RSxZQUFZO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLG1CQUFPLENBQUMsNENBQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixhQUFhO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixhQUFhO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixhQUFhO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsYUFBYTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUg7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2REFBNkQ7QUFDdkcsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUE2RDtBQUN2RyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVUsb0JBQW9CO0FBQzNFLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxvRkFBb0YsYUFBYTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLDRDQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsYUFBYTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDRDQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsYUFBYTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixhQUFhO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkRBQTZEO0FBQ3ZHLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBO0FBQ0EsbUVBQW1FLFlBQVksb0JBQW9CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFLLEdBQUcsQ0FBSTtBQUNsQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CLElBQUk7QUFDbkQ7QUFDQSxXQUFXO0FBQ1g7QUFDQSxzQ0FBc0Msb0JBQW9CLElBQUk7QUFDOUQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsbUJBQU8sQ0FBQyw0Q0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlLDBFQUEwRTtBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxxQkFBcUI7QUFDekk7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxxQkFBcUI7QUFDN0k7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsVUFBVTtBQUNwSCxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDRDQUFPO0FBQy9DLGdDQUFnQyxtQkFBTyxDQUFDLDBGQUFpQjs7QUFFekQ7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFOUM7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw0Q0FBTztBQUM5QywrQkFBK0IsbUJBQU8sQ0FBQywwRkFBaUI7O0FBRXhEO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsdUZBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUcsY0FBYztBQUM5QixtQkFBbUIsR0FBRyx1QkFBdUI7QUFDN0MsTUFBTSw2Q0FBNkMsZ0JBQWdCO0FBQ25FLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsNENBQU87QUFDOUM7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw0Q0FBTztBQUM5QztBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLDRDQUFPO0FBQzlDO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsNENBQU87QUFDOUM7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw0Q0FBTztBQUM5QztBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLDRDQUFPO0FBQzlDO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsNENBQU87QUFDL0M7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUMvQztBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDRDQUFPO0FBQy9DO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsNENBQU87QUFDL0M7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUMvQztBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsdUZBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsZUFBZSxjQUFjLHNCQUFzQixLQUFLLHdCQUF3QjtBQUNoRixxQkFBcUIsOEJBQThCO0FBQ25ELHdCQUF3Qjs7QUFFeEIsTUFBTTs7QUFFTixNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsNENBQU87QUFDL0MsZ0NBQWdDLG1CQUFPLENBQUMsMEZBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUMvQyxnQ0FBZ0MsbUJBQU8sQ0FBQywwRkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUMvQyxnQ0FBZ0MsbUJBQU8sQ0FBQywwRkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixHQUFHLE9BQU87QUFDNUIsYUFBYSxHQUFHLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsR0FBRyxPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRyx5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHLFlBQVk7QUFDOUI7QUFDQTtBQUNBLGVBQWU7QUFDZix3QkFBd0IsR0FBRyxPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixHQUFHLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEdBQUcsT0FBTztBQUNoQztBQUNBLHFCQUFxQixHQUFHLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2VtaWNvbG9uZHNtL3VpL2Rpc3QvaW5kZXguanM/NmI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW09iamVjdC5rZXlzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9yZWFjdC1pcy1ucG0tMTYuMTMuMS1hOWI5MzgyYjRmLWY3YTE5YWMzNDkuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbnZhciByZXF1aXJlX3JlYWN0X2lzX2RldmVsb3BtZW50ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvcmVhY3QtaXMtbnBtLTE2LjEzLjEtYTliOTM4MmI0Zi1mN2ExOWFjMzQ5LnppcC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0cnVlKSB7XG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3I7XG4gICAgICAgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzO1xuICAgICAgICB2YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpIDogNjAxMDY7XG4gICAgICAgIHZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpIDogNjAxMDc7XG4gICAgICAgIHZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpIDogNjAxMDg7XG4gICAgICAgIHZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpIDogNjAxMTQ7XG4gICAgICAgIHZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpIDogNjAxMDk7XG4gICAgICAgIHZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSA6IDYwMTEwO1xuICAgICAgICB2YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIikgOiA2MDExMTtcbiAgICAgICAgdmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKSA6IDYwMTExO1xuICAgICAgICB2YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IDYwMTEyO1xuICAgICAgICB2YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSA6IDYwMTEzO1xuICAgICAgICB2YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIikgOiA2MDEyMDtcbiAgICAgICAgdmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpIDogNjAxMTU7XG4gICAgICAgIHZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSA6IDYwMTE2O1xuICAgICAgICB2YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKSA6IDYwMTIxO1xuICAgICAgICB2YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mdW5kYW1lbnRhbFwiKSA6IDYwMTE3O1xuICAgICAgICB2YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpIDogNjAxMTg7XG4gICAgICAgIHZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpIDogNjAxMTk7XG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xuICAgICAgICB2YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbiAgICAgICAgdmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbiAgICAgICAgdmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG4gICAgICAgIHZhciBFbGVtZW50MiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgICAgICAgdmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xuICAgICAgICB2YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgICAgICB2YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbiAgICAgICAgdmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG4gICAgICAgIHZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbiAgICAgICAgdmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICAgICAgdmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgICAgICB2YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICAgICAgICB2YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbiAgICAgICAgZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuICAgICAgICBleHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgICAgIGV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQyO1xuICAgICAgICBleHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuICAgICAgICBleHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG4gICAgICAgIGV4cG9ydHMuTGF6eSA9IExhenk7XG4gICAgICAgIGV4cG9ydHMuTWVtbyA9IE1lbW87XG4gICAgICAgIGV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuICAgICAgICBleHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG4gICAgICAgIGV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG4gICAgICAgIGV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbiAgICAgICAgZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuICAgICAgICBleHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuICAgICAgICBleHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgIGV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbiAgICAgICAgZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgICAgIGV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuICAgICAgICBleHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuICAgICAgICBleHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbiAgICAgICAgZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG4gICAgICAgIGV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbiAgICAgICAgZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbiAgICAgICAgZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG4gICAgICAgIGV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG4gICAgICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuICAgICAgICBleHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvcmVhY3QtaXMtbnBtLTE2LjEzLjEtYTliOTM4MmI0Zi1mN2ExOWFjMzQ5LnppcC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanNcbnZhciByZXF1aXJlX3JlYWN0X2lzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvcmVhY3QtaXMtbnBtLTE2LjEzLjEtYTliOTM4MmI0Zi1mN2ExOWFjMzQ5LnppcC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX3JlYWN0X2lzX2RldmVsb3BtZW50KCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LWFzc2lnbi1ucG0tNC4xLjEtMTAwNGFkNmRlYy1mY2M2ZTRlYThjLnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xudmFyIHJlcXVpcmVfb2JqZWN0X2Fzc2lnbiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC1hc3NpZ24tbnBtLTQuMS4xLTEwMDRhZDZkZWMtZmNjNmU0ZWE4Yy56aXAvbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QodmFsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoXCJhYmNcIik7XG4gICAgICAgIHRlc3QxWzVdID0gXCJkZVwiO1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSBcIjVcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVzdDIgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgdGVzdDJbXCJfXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiB0ZXN0MltuXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmRlcjIuam9pbihcIlwiKSAhPT0gXCIwMTIzNDU2Nzg5XCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlc3QzID0ge307XG4gICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3RcIi5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGxldHRlcikge1xuICAgICAgICAgIHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKFwiXCIpICE9PSBcImFiY2RlZmdoaWprbG1ub3BxcnN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgdmFyIGZyb207XG4gICAgICB2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuICAgICAgdmFyIHN5bWJvbHM7XG4gICAgICBmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuICAgICAgICBmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG4gICAgICAgICAgICAgIHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0bztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvcHJvcC10eXBlcy1ucG0tMTUuOC4xLTE3YzcxZWU3ZWUtYzA1NmQzZjFjMC56aXAvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG52YXIgcmVxdWlyZV9SZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL3Byb3AtdHlwZXMtbnBtLTE1LjguMS0xN2M3MWVlN2VlLWMwNTZkM2YxYzAuemlwL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9wcm9wLXR5cGVzLW5wbS0xNS44LjEtMTdjNzFlZTdlZS1jMDU2ZDNmMWMwLnppcC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzXG52YXIgcmVxdWlyZV9oYXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9wcm9wLXR5cGVzLW5wbS0xNS44LjEtMTdjNzFlZTdlZS1jMDU2ZDNmMWMwLnppcC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL3Byb3AtdHlwZXMtbnBtLTE1LjguMS0xN2M3MWVlN2VlLWMwNTZkM2YxYzAuemlwL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXG52YXIgcmVxdWlyZV9jaGVja1Byb3BUeXBlcyA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL3Byb3AtdHlwZXMtbnBtLTE1LjguMS0xN2M3MWVlN2VlLWMwNTZkM2YxYzAuemlwL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmVfUmVhY3RQcm9wVHlwZXNTZWNyZXQoKTtcbiAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICAgICAgaGFzID0gcmVxdWlyZV9oYXMoKTtcbiAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIldhcm5pbmc6IFwiICsgdGV4dDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4gICAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcztcbiAgICB2YXIgaGFzO1xuICAgIGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyBsb2NhdGlvbiArIFwiIHR5cGUgYFwiICsgdHlwZVNwZWNOYW1lICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArIFwiYC5UaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC5cIik7XG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICBwcmludFdhcm5pbmcoKGNvbXBvbmVudE5hbWUgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHR5cGVTcGVjTmFtZSArIFwiYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhIFwiICsgdHlwZW9mIGVycm9yICsgXCIuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6IFwiXCI7XG4gICAgICAgICAgICAgIHByaW50V2FybmluZyhcIkZhaWxlZCBcIiArIGxvY2F0aW9uICsgXCIgdHlwZTogXCIgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICAgICAgfVxuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9wcm9wLXR5cGVzLW5wbS0xNS44LjEtMTdjNzFlZTdlZS1jMDU2ZDNmMWMwLnppcC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1xudmFyIHJlcXVpcmVfZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9wcm9wLXR5cGVzLW5wbS0xNS44LjEtMTdjNzFlZTdlZS1jMDU2ZDNmMWMwLnppcC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgUmVhY3RJcyA9IHJlcXVpcmVfcmVhY3RfaXMoKTtcbiAgICB2YXIgYXNzaWduID0gcmVxdWlyZV9vYmplY3RfYXNzaWduKCk7XG4gICAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZV9SZWFjdFByb3BUeXBlc1NlY3JldCgpO1xuICAgIHZhciBoYXMgPSByZXF1aXJlX2hhcygpO1xuICAgIHZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmVfY2hlY2tQcm9wVHlwZXMoKTtcbiAgICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiV2FybmluZzogXCIgKyB0ZXh0O1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIEFOT05ZTU9VUyA9IFwiPDxhbm9ueW1vdXM+PlwiO1xuICAgICAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgICAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoXCJhcnJheVwiKSxcbiAgICAgICAgYmlnaW50OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihcImJpZ2ludFwiKSxcbiAgICAgICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoXCJib29sZWFuXCIpLFxuICAgICAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihcImZ1bmN0aW9uXCIpLFxuICAgICAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKFwibnVtYmVyXCIpLFxuICAgICAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKFwib2JqZWN0XCIpLFxuICAgICAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKFwic3RyaW5nXCIpLFxuICAgICAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKFwic3ltYm9sXCIpLFxuICAgICAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICAgICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgICAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgICAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgICAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlclxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgPyBkYXRhIDoge307XG4gICAgICAgIHRoaXMuc3RhY2sgPSBcIlwiO1xuICAgICAgfVxuICAgICAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4gICAgICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIkNhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuIFVzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlc1wiKTtcbiAgICAgICAgICAgICAgZXJyLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIjtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgXCI6XCIgKyBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgaWYgKCFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiYgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFwiWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBgXCIgKyBwcm9wRnVsbE5hbWUgKyBcImAgcHJvcCBvbiBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzIGZvciBkZXRhaWxzLlwiKTtcbiAgICAgICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFwiVGhlIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBwcm9wRnVsbE5hbWUgKyBcImAgaXMgbWFya2VkIGFzIHJlcXVpcmVkIFwiICsgKFwiaW4gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXCJUaGUgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gXCIgKyAoXCJgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgICAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXCJJbnZhbGlkIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBwcm9wRnVsbE5hbWUgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIHByZWNpc2VUeXBlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIFwiKSArIChcImBcIiArIGV4cGVjdGVkVHlwZSArIFwiYC5cIiksIHsgZXhwZWN0ZWRUeXBlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIlByb3BlcnR5IGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXCJJbnZhbGlkIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBwcm9wRnVsbE5hbWUgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIHByb3BUeXBlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGFuIGFycmF5LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyBcIltcIiArIGkgKyBcIl1cIiwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIkludmFsaWQgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgcHJvcFR5cGUgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIkludmFsaWQgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgcHJvcFR5cGUgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIkludmFsaWQgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgYWN0dWFsQ2xhc3NOYW1lICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIFwiKSArIChcImluc3RhbmNlIG9mIGBcIiArIGV4cGVjdGVkQ2xhc3NOYW1lICsgXCJgLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFwiSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgXCIgKyBhcmd1bWVudHMubGVuZ3RoICsgXCIgYXJndW1lbnRzLiBBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmludFdhcm5pbmcoXCJJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uICsgXCIgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIG9mIHZhbHVlIGBcIiArIFN0cmluZyhwcm9wVmFsdWUpICsgXCJgIFwiICsgKFwic3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgb25lIG9mIFwiICsgdmFsdWVzU3RyaW5nICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIlByb3BlcnR5IGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgICAgaWYgKHByb3BUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXCJJbnZhbGlkIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBwcm9wRnVsbE5hbWUgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIHByb3BUeXBlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGFuIG9iamVjdC5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArIFwiLlwiICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICAgICAgdHJ1ZSA/IHByaW50V2FybmluZyhcIkludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS5cIikgOiB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXCJJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgXCIgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyBcIiBhdCBpbmRleCBcIiArIGkgKyBcIi5cIik7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIHZhciBjaGVja2VyMiA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaTJdO1xuICAgICAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyMihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICAgIGlmIChjaGVja2VyUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hlY2tlclJlc3VsdC5kYXRhICYmIGhhcyhjaGVja2VyUmVzdWx0LmRhdGEsIFwiZXhwZWN0ZWRUeXBlXCIpKSB7XG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChjaGVja2VyUmVzdWx0LmRhdGEuZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZXNNZXNzYWdlID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwID8gXCIsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFtcIiArIGV4cGVjdGVkVHlwZXMuam9pbihcIiwgXCIpICsgXCJdXCIgOiBcIlwiO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIkludmFsaWQgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBzdXBwbGllZCB0byBcIiArIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImBcIiArIGV4cGVjdGVkVHlwZXNNZXNzYWdlICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIkludmFsaWQgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBzdXBwbGllZCB0byBcIiArIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCB0eXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcigoY29tcG9uZW50TmFtZSB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgbG9jYXRpb24gKyBcIiB0eXBlIGBcIiArIHByb3BGdWxsTmFtZSArIFwiLlwiICsga2V5ICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGUgKyBcImAuXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgICBpZiAocHJvcFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcIkludmFsaWQgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBvZiB0eXBlIGBcIiArIHByb3BUeXBlICsgXCJgIFwiICsgKFwic3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYG9iamVjdGAuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyBcIi5cIiArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgICAgaWYgKHByb3BUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXCJJbnZhbGlkIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBwcm9wRnVsbE5hbWUgKyBcImAgb2YgdHlwZSBgXCIgKyBwcm9wVHlwZSArIFwiYCBcIiArIChcInN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBvYmplY3RgLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uICsgXCIgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIGtleSBgXCIgKyBrZXkgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYC5cXG5CYWQgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgXCIgIFwiKSArIFwiXFxuVmFsaWQga2V5czogXCIgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgXCIgIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgXCIuXCIgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BUeXBlID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZVtcIkBAdG9TdHJpbmdUYWdcIl0gPT09IFwiU3ltYm9sXCIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFwic3ltYm9sXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BUeXBlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcIlwiICsgcHJvcFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChwcm9wVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBcInJlZ2V4cFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcFR5cGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFuIFwiICsgdHlwZTtcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYSBcIiArIHR5cGU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfVxuICAgICAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgICAgIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gICAgICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcbiAgICAgIHJldHVybiBSZWFjdFByb3BUeXBlcztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvcHJvcC10eXBlcy1ucG0tMTUuOC4xLTE3YzcxZWU3ZWUtYzA1NmQzZjFjMC56aXAvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbnZhciByZXF1aXJlX3Byb3BfdHlwZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9wcm9wLXR5cGVzLW5wbS0xNS44LjEtMTdjNzFlZTdlZS1jMDU2ZDNmMWMwLnppcC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgUmVhY3RJcyA9IHJlcXVpcmVfcmVhY3RfaXMoKTtcbiAgICAgIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9mYWN0b3J5V2l0aFR5cGVDaGVja2VycygpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gbnVsbCgpO1xuICAgIH1cbiAgICB2YXIgUmVhY3RJcztcbiAgICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcztcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC1rZXlzLW5wbS0xLjEuMS0xYmYyZjFiZTkzLWIzNjNjNWU3NjQuemlwL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qc1xudmFyIHJlcXVpcmVfaXNBcmd1bWVudHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3Qta2V5cy1ucG0tMS4xLjEtMWJmMmYxYmU5My1iMzYzYzVlNzY0LnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgdmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuICAgICAgdmFyIGlzQXJncyA9IHN0ciA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIjtcbiAgICAgIGlmICghaXNBcmdzKSB7XG4gICAgICAgIGlzQXJncyA9IHN0ciAhPT0gXCJbb2JqZWN0IEFycmF5XVwiICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSBcIm51bWJlclwiICYmIHZhbHVlLmxlbmd0aCA+PSAwICYmIHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJncztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LWtleXMtbnBtLTEuMS4xLTFiZjJmMWJlOTMtYjM2M2M1ZTc2NC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2ltcGxlbWVudGF0aW9uLmpzXG52YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC1rZXlzLW5wbS0xLjEuMS0xYmYyZjFiZTkzLWIzNjNjNWU3NjQuemlwL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIga2V5c1NoaW07XG4gICAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgICAgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICAgIGlzQXJncyA9IHJlcXVpcmVfaXNBcmd1bWVudHMoKTtcbiAgICAgIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgICBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sIFwidG9TdHJpbmdcIik7XG4gICAgICBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbigpIHtcbiAgICAgIH0sIFwicHJvdG90eXBlXCIpO1xuICAgICAgZG9udEVudW1zID0gW1xuICAgICAgICBcInRvU3RyaW5nXCIsXG4gICAgICAgIFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICAgICAgXCJ2YWx1ZU9mXCIsXG4gICAgICAgIFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgXCJpc1Byb3RvdHlwZU9mXCIsXG4gICAgICAgIFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcbiAgICAgICAgXCJjb25zdHJ1Y3RvclwiXG4gICAgICBdO1xuICAgICAgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG4gICAgICB9O1xuICAgICAgZXhjbHVkZWRLZXlzID0ge1xuICAgICAgICAkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcbiAgICAgICAgJGNvbnNvbGU6IHRydWUsXG4gICAgICAgICRleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgJGZyYW1lOiB0cnVlLFxuICAgICAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICAgICAkZnJhbWVzOiB0cnVlLFxuICAgICAgICAkaW5uZXJIZWlnaHQ6IHRydWUsXG4gICAgICAgICRpbm5lcldpZHRoOiB0cnVlLFxuICAgICAgICAkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuICAgICAgICAkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG4gICAgICAgICRvdXRlckhlaWdodDogdHJ1ZSxcbiAgICAgICAgJG91dGVyV2lkdGg6IHRydWUsXG4gICAgICAgICRwYWdlWE9mZnNldDogdHJ1ZSxcbiAgICAgICAgJHBhZ2VZT2Zmc2V0OiB0cnVlLFxuICAgICAgICAkcGFyZW50OiB0cnVlLFxuICAgICAgICAkc2Nyb2xsTGVmdDogdHJ1ZSxcbiAgICAgICAgJHNjcm9sbFRvcDogdHJ1ZSxcbiAgICAgICAgJHNjcm9sbFg6IHRydWUsXG4gICAgICAgICRzY3JvbGxZOiB0cnVlLFxuICAgICAgICAkc2VsZjogdHJ1ZSxcbiAgICAgICAgJHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcbiAgICAgICAgJHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuICAgICAgICAkd2luZG93OiB0cnVlXG4gICAgICB9O1xuICAgICAgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsgaW4gd2luZG93KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghZXhjbHVkZWRLZXlzW1wiJFwiICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KCk7XG4gICAgICBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcbiAgICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgIHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICAgICAgICB2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcbiAgICAgICAgdmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xuICAgICAgICB2YXIgdGhlS2V5cyA9IFtdO1xuICAgICAgICBpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcbiAgICAgICAgaWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gXCJwcm90b3R5cGVcIikgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgdmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICBpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSBcImNvbnN0cnVjdG9yXCIpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoZUtleXM7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgaGFzO1xuICAgIHZhciB0b1N0cjtcbiAgICB2YXIgaXNBcmdzO1xuICAgIHZhciBpc0VudW1lcmFibGU7XG4gICAgdmFyIGhhc0RvbnRFbnVtQnVnO1xuICAgIHZhciBoYXNQcm90b0VudW1CdWc7XG4gICAgdmFyIGRvbnRFbnVtcztcbiAgICB2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGU7XG4gICAgdmFyIGV4Y2x1ZGVkS2V5cztcbiAgICB2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnO1xuICAgIHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3k7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ga2V5c1NoaW07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3Qta2V5cy1ucG0tMS4xLjEtMWJmMmYxYmU5My1iMzYzYzVlNzY0LnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanNcbnZhciByZXF1aXJlX29iamVjdF9rZXlzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LWtleXMtbnBtLTEuMS4xLTFiZjJmMWJlOTMtYjM2M2M1ZTc2NC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICB2YXIgaXNBcmdzID0gcmVxdWlyZV9pc0FyZ3VtZW50cygpO1xuICAgIHZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIHZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7XG4gICAgICByZXR1cm4gb3JpZ0tleXMobyk7XG4gICAgfSA6IHJlcXVpcmVfaW1wbGVtZW50YXRpb24oKTtcbiAgICB2YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG4gICAga2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB9KDEsIDIpO1xuICAgICAgICBpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcmdzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2hhcy1zeW1ib2xzLW5wbS0xLjAuMy0xOTg2YmZmMmM0LWEwNTRjNDBjNjMuemlwL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qc1xudmFyIHJlcXVpcmVfc2hhbXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9oYXMtc3ltYm9scy1ucG0tMS4wLjMtMTk4NmJmZjJjNC1hMDU0YzQwYzYzLnppcC9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHZhciBzeW0gPSBTeW1ib2woXCJ0ZXN0XCIpO1xuICAgICAgdmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuICAgICAgaWYgKHR5cGVvZiBzeW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSBcIltvYmplY3QgU3ltYm9sXVwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gXCJbb2JqZWN0IFN5bWJvbF1cIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc3ltVmFsID0gNDI7XG4gICAgICBvYmpbc3ltXSA9IHN5bVZhbDtcbiAgICAgIGZvciAoc3ltIGluIG9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gXCJmdW5jdGlvblwiICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuICAgICAgaWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9oYXMtc3ltYm9scy1ucG0tMS4wLjMtMTk4NmJmZjJjNC1hMDU0YzQwYzYzLnppcC9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanNcbnZhciByZXF1aXJlX2hhc19zeW1ib2xzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvaGFzLXN5bWJvbHMtbnBtLTEuMC4zLTE5ODZiZmYyYzQtYTA1NGM0MGM2My56aXAvbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2w7XG4gICAgdmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlX3NoYW1zKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcmlnU3ltYm9sKFwiZm9vXCIpICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sKFwiYmFyXCIpICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2Z1bmN0aW9uLWJpbmQtbnBtLTEuMS4xLWI1NmIzMjJhZTktYjMyZmJhZWJiMy56aXAvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanNcbnZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uMiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2Z1bmN0aW9uLWJpbmQtbnBtLTEuMS4xLWI1NmIzMjJhZTktYjMyZmJhZWJiMy56aXAvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIEVSUk9SX01FU1NBR0UgPSBcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgXCI7XG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgdmFyIGZ1bmNUeXBlID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGJvdW5kO1xuICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goXCIkXCIgKyBpKTtcbiAgICAgIH1cbiAgICAgIGJvdW5kID0gRnVuY3Rpb24oXCJiaW5kZXJcIiwgXCJyZXR1cm4gZnVuY3Rpb24gKFwiICsgYm91bmRBcmdzLmpvaW4oXCIsXCIpICsgXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO1xuICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkyKCkge1xuICAgICAgICB9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZnVuY3Rpb24tYmluZC1ucG0tMS4xLjEtYjU2YjMyMmFlOS1iMzJmYmFlYmIzLnppcC9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qc1xudmFyIHJlcXVpcmVfZnVuY3Rpb25fYmluZCA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2Z1bmN0aW9uLWJpbmQtbnBtLTEuMS4xLWI1NmIzMjJhZTktYjMyZmJhZWJiMy56aXAvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjIoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2hhcy1ucG0tMS4wLjMtYjdmMDA2MzFjMS1iOWFkNTNkNTNiLnppcC9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3JjID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvaGFzLW5wbS0xLjAuMy1iN2YwMDYzMWMxLWI5YWQ1M2Q1M2IuemlwL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiaW5kID0gcmVxdWlyZV9mdW5jdGlvbl9iaW5kKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZ2V0LWludHJpbnNpYy1ucG0tMS4xLjEtN2U4Njg3NDVkYS1hOWZlMmNhOGZhLnppcC9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qc1xudmFyIHJlcXVpcmVfZ2V0X2ludHJpbnNpYyA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2dldC1pbnRyaW5zaWMtbnBtLTEuMS4xLTdlODY4NzQ1ZGEtYTlmZTJjYThmYS56aXAvbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHVuZGVmaW5lZDI7XG4gICAgdmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xuICAgIHZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbiAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICB2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24oZXhwcmVzc2lvblN5bnRheCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyBcIikuY29uc3RydWN0b3I7XCIpKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGlmICgkZ09QRCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgJGdPUEQoe30sIFwiXCIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAkZ09QRCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbiAgICB9O1xuICAgIHZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEID8gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICByZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG4gICAgICB9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gJGdPUEQoYXJndW1lbnRzLCBcImNhbGxlZVwiKS5nZXQ7XG4gICAgICAgIH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCkgOiB0aHJvd1R5cGVFcnJvcjtcbiAgICB2YXIgaGFzU3ltYm9scyA9IHJlcXVpcmVfaGFzX3N5bWJvbHMoKSgpO1xuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC5fX3Byb3RvX187XG4gICAgfTtcbiAgICB2YXIgbmVlZHNFdmFsID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZDIgOiBnZXRQcm90byhVaW50OEFycmF5KTtcbiAgICB2YXIgSU5UUklOU0lDUyA9IHtcbiAgICAgIFwiJUFnZ3JlZ2F0ZUVycm9yJVwiOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogQWdncmVnYXRlRXJyb3IsXG4gICAgICBcIiVBcnJheSVcIjogQXJyYXksXG4gICAgICBcIiVBcnJheUJ1ZmZlciVcIjogdHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IEFycmF5QnVmZmVyLFxuICAgICAgXCIlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVcIjogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQyLFxuICAgICAgXCIlQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiOiB1bmRlZmluZWQyLFxuICAgICAgXCIlQXN5bmNGdW5jdGlvbiVcIjogbmVlZHNFdmFsLFxuICAgICAgXCIlQXN5bmNHZW5lcmF0b3IlXCI6IG5lZWRzRXZhbCxcbiAgICAgIFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCI6IG5lZWRzRXZhbCxcbiAgICAgIFwiJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6IG5lZWRzRXZhbCxcbiAgICAgIFwiJUF0b21pY3MlXCI6IHR5cGVvZiBBdG9taWNzID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IEF0b21pY3MsXG4gICAgICBcIiVCaWdJbnQlXCI6IHR5cGVvZiBCaWdJbnQgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogQmlnSW50LFxuICAgICAgXCIlQm9vbGVhbiVcIjogQm9vbGVhbixcbiAgICAgIFwiJURhdGFWaWV3JVwiOiB0eXBlb2YgRGF0YVZpZXcgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogRGF0YVZpZXcsXG4gICAgICBcIiVEYXRlJVwiOiBEYXRlLFxuICAgICAgXCIlZGVjb2RlVVJJJVwiOiBkZWNvZGVVUkksXG4gICAgICBcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6IGRlY29kZVVSSUNvbXBvbmVudCxcbiAgICAgIFwiJWVuY29kZVVSSSVcIjogZW5jb2RlVVJJLFxuICAgICAgXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOiBlbmNvZGVVUklDb21wb25lbnQsXG4gICAgICBcIiVFcnJvciVcIjogRXJyb3IsXG4gICAgICBcIiVldmFsJVwiOiBldmFsLFxuICAgICAgXCIlRXZhbEVycm9yJVwiOiBFdmFsRXJyb3IsXG4gICAgICBcIiVGbG9hdDMyQXJyYXklXCI6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogRmxvYXQzMkFycmF5LFxuICAgICAgXCIlRmxvYXQ2NEFycmF5JVwiOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IEZsb2F0NjRBcnJheSxcbiAgICAgIFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG4gICAgICBcIiVGdW5jdGlvbiVcIjogJEZ1bmN0aW9uLFxuICAgICAgXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6IG5lZWRzRXZhbCxcbiAgICAgIFwiJUludDhBcnJheSVcIjogdHlwZW9mIEludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZDIgOiBJbnQ4QXJyYXksXG4gICAgICBcIiVJbnQxNkFycmF5JVwiOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZDIgOiBJbnQxNkFycmF5LFxuICAgICAgXCIlSW50MzJBcnJheSVcIjogdHlwZW9mIEludDMyQXJyYXkgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogSW50MzJBcnJheSxcbiAgICAgIFwiJWlzRmluaXRlJVwiOiBpc0Zpbml0ZSxcbiAgICAgIFwiJWlzTmFOJVwiOiBpc05hTixcbiAgICAgIFwiJUl0ZXJhdG9yUHJvdG90eXBlJVwiOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQyLFxuICAgICAgXCIlSlNPTiVcIjogdHlwZW9mIEpTT04gPT09IFwib2JqZWN0XCIgPyBKU09OIDogdW5kZWZpbmVkMixcbiAgICAgIFwiJU1hcCVcIjogdHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZDIgOiBNYXAsXG4gICAgICBcIiVNYXBJdGVyYXRvclByb3RvdHlwZSVcIjogdHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZDIgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcbiAgICAgIFwiJU1hdGglXCI6IE1hdGgsXG4gICAgICBcIiVOdW1iZXIlXCI6IE51bWJlcixcbiAgICAgIFwiJU9iamVjdCVcIjogT2JqZWN0LFxuICAgICAgXCIlcGFyc2VGbG9hdCVcIjogcGFyc2VGbG9hdCxcbiAgICAgIFwiJXBhcnNlSW50JVwiOiBwYXJzZUludCxcbiAgICAgIFwiJVByb21pc2UlXCI6IHR5cGVvZiBQcm9taXNlID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IFByb21pc2UsXG4gICAgICBcIiVQcm94eSVcIjogdHlwZW9mIFByb3h5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IFByb3h5LFxuICAgICAgXCIlUmFuZ2VFcnJvciVcIjogUmFuZ2VFcnJvcixcbiAgICAgIFwiJVJlZmVyZW5jZUVycm9yJVwiOiBSZWZlcmVuY2VFcnJvcixcbiAgICAgIFwiJVJlZmxlY3QlXCI6IHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IFJlZmxlY3QsXG4gICAgICBcIiVSZWdFeHAlXCI6IFJlZ0V4cCxcbiAgICAgIFwiJVNldCVcIjogdHlwZW9mIFNldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZDIgOiBTZXQsXG4gICAgICBcIiVTZXRJdGVyYXRvclByb3RvdHlwZSVcIjogdHlwZW9mIFNldCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZDIgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcbiAgICAgIFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogU2hhcmVkQXJyYXlCdWZmZXIsXG4gICAgICBcIiVTdHJpbmclXCI6IFN0cmluZyxcbiAgICAgIFwiJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVwiOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oXCJcIltTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkMixcbiAgICAgIFwiJVN5bWJvbCVcIjogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZDIsXG4gICAgICBcIiVTeW50YXhFcnJvciVcIjogJFN5bnRheEVycm9yLFxuICAgICAgXCIlVGhyb3dUeXBlRXJyb3IlXCI6IFRocm93VHlwZUVycm9yLFxuICAgICAgXCIlVHlwZWRBcnJheSVcIjogVHlwZWRBcnJheSxcbiAgICAgIFwiJVR5cGVFcnJvciVcIjogJFR5cGVFcnJvcixcbiAgICAgIFwiJVVpbnQ4QXJyYXklXCI6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IFVpbnQ4QXJyYXksXG4gICAgICBcIiVVaW50OENsYW1wZWRBcnJheSVcIjogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgICAgXCIlVWludDE2QXJyYXklXCI6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZDIgOiBVaW50MTZBcnJheSxcbiAgICAgIFwiJVVpbnQzMkFycmF5JVwiOiB0eXBlb2YgVWludDMyQXJyYXkgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogVWludDMyQXJyYXksXG4gICAgICBcIiVVUklFcnJvciVcIjogVVJJRXJyb3IsXG4gICAgICBcIiVXZWFrTWFwJVwiOiB0eXBlb2YgV2Vha01hcCA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZDIgOiBXZWFrTWFwLFxuICAgICAgXCIlV2Vha1JlZiVcIjogdHlwZW9mIFdlYWtSZWYgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQyIDogV2Vha1JlZixcbiAgICAgIFwiJVdlYWtTZXQlXCI6IHR5cGVvZiBXZWFrU2V0ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkMiA6IFdlYWtTZXRcbiAgICB9O1xuICAgIHZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwyKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChuYW1lID09PSBcIiVBc3luY0Z1bmN0aW9uJVwiKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIik7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcIiVBc3luY0dlbmVyYXRvciVcIikge1xuICAgICAgICB2YXIgZm4gPSBkb0V2YWwyKFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpO1xuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICB2YWx1ZSA9IGZuLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiKSB7XG4gICAgICAgIHZhciBnZW4gPSBkb0V2YWwyKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtcbiAgICAgICAgaWYgKGdlbikge1xuICAgICAgICAgIHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcbiAgICAgIFwiJUFycmF5QnVmZmVyUHJvdG90eXBlJVwiOiBbXCJBcnJheUJ1ZmZlclwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJUFycmF5UHJvdG90eXBlJVwiOiBbXCJBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJUFycmF5UHJvdG9fZW50cmllcyVcIjogW1wiQXJyYXlcIiwgXCJwcm90b3R5cGVcIiwgXCJlbnRyaWVzXCJdLFxuICAgICAgXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOiBbXCJBcnJheVwiLCBcInByb3RvdHlwZVwiLCBcImZvckVhY2hcIl0sXG4gICAgICBcIiVBcnJheVByb3RvX2tleXMlXCI6IFtcIkFycmF5XCIsIFwicHJvdG90eXBlXCIsIFwia2V5c1wiXSxcbiAgICAgIFwiJUFycmF5UHJvdG9fdmFsdWVzJVwiOiBbXCJBcnJheVwiLCBcInByb3RvdHlwZVwiLCBcInZhbHVlc1wiXSxcbiAgICAgIFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6IFtcIkFzeW5jRnVuY3Rpb25cIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVBc3luY0dlbmVyYXRvciVcIjogW1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJVwiOiBbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsIFwicHJvdG90eXBlXCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlQm9vbGVhblByb3RvdHlwZSVcIjogW1wiQm9vbGVhblwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJURhdGFWaWV3UHJvdG90eXBlJVwiOiBbXCJEYXRhVmlld1wiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJURhdGVQcm90b3R5cGUlXCI6IFtcIkRhdGVcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVFcnJvclByb3RvdHlwZSVcIjogW1wiRXJyb3JcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVFdmFsRXJyb3JQcm90b3R5cGUlXCI6IFtcIkV2YWxFcnJvclwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjogW1wiRmxvYXQzMkFycmF5XCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlRmxvYXQ2NEFycmF5UHJvdG90eXBlJVwiOiBbXCJGbG9hdDY0QXJyYXlcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVGdW5jdGlvblByb3RvdHlwZSVcIjogW1wiRnVuY3Rpb25cIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVHZW5lcmF0b3IlXCI6IFtcIkdlbmVyYXRvckZ1bmN0aW9uXCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlR2VuZXJhdG9yUHJvdG90eXBlJVwiOiBbXCJHZW5lcmF0b3JGdW5jdGlvblwiLCBcInByb3RvdHlwZVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJUludDhBcnJheVByb3RvdHlwZSVcIjogW1wiSW50OEFycmF5XCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlSW50MTZBcnJheVByb3RvdHlwZSVcIjogW1wiSW50MTZBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJUludDMyQXJyYXlQcm90b3R5cGUlXCI6IFtcIkludDMyQXJyYXlcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVKU09OUGFyc2UlXCI6IFtcIkpTT05cIiwgXCJwYXJzZVwiXSxcbiAgICAgIFwiJUpTT05TdHJpbmdpZnklXCI6IFtcIkpTT05cIiwgXCJzdHJpbmdpZnlcIl0sXG4gICAgICBcIiVNYXBQcm90b3R5cGUlXCI6IFtcIk1hcFwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJU51bWJlclByb3RvdHlwZSVcIjogW1wiTnVtYmVyXCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlT2JqZWN0UHJvdG90eXBlJVwiOiBbXCJPYmplY3RcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVPYmpQcm90b190b1N0cmluZyVcIjogW1wiT2JqZWN0XCIsIFwicHJvdG90eXBlXCIsIFwidG9TdHJpbmdcIl0sXG4gICAgICBcIiVPYmpQcm90b192YWx1ZU9mJVwiOiBbXCJPYmplY3RcIiwgXCJwcm90b3R5cGVcIiwgXCJ2YWx1ZU9mXCJdLFxuICAgICAgXCIlUHJvbWlzZVByb3RvdHlwZSVcIjogW1wiUHJvbWlzZVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVByb21pc2VQcm90b190aGVuJVwiOiBbXCJQcm9taXNlXCIsIFwicHJvdG90eXBlXCIsIFwidGhlblwiXSxcbiAgICAgIFwiJVByb21pc2VfYWxsJVwiOiBbXCJQcm9taXNlXCIsIFwiYWxsXCJdLFxuICAgICAgXCIlUHJvbWlzZV9yZWplY3QlXCI6IFtcIlByb21pc2VcIiwgXCJyZWplY3RcIl0sXG4gICAgICBcIiVQcm9taXNlX3Jlc29sdmUlXCI6IFtcIlByb21pc2VcIiwgXCJyZXNvbHZlXCJdLFxuICAgICAgXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjogW1wiUmFuZ2VFcnJvclwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJVwiOiBbXCJSZWZlcmVuY2VFcnJvclwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVJlZ0V4cFByb3RvdHlwZSVcIjogW1wiUmVnRXhwXCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlU2V0UHJvdG90eXBlJVwiOiBbXCJTZXRcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjogW1wiU2hhcmVkQXJyYXlCdWZmZXJcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVTdHJpbmdQcm90b3R5cGUlXCI6IFtcIlN0cmluZ1wiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVN5bWJvbFByb3RvdHlwZSVcIjogW1wiU3ltYm9sXCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlU3ludGF4RXJyb3JQcm90b3R5cGUlXCI6IFtcIlN5bnRheEVycm9yXCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlVHlwZWRBcnJheVByb3RvdHlwZSVcIjogW1wiVHlwZWRBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjogW1wiVHlwZUVycm9yXCIsIFwicHJvdG90eXBlXCJdLFxuICAgICAgXCIlVWludDhBcnJheVByb3RvdHlwZSVcIjogW1wiVWludDhBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJVwiOiBbXCJVaW50OENsYW1wZWRBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOiBbXCJVaW50MTZBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVVpbnQzMkFycmF5UHJvdG90eXBlJVwiOiBbXCJVaW50MzJBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVVSSUVycm9yUHJvdG90eXBlJVwiOiBbXCJVUklFcnJvclwiLCBcInByb3RvdHlwZVwiXSxcbiAgICAgIFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6IFtcIldlYWtNYXBcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgICBcIiVXZWFrU2V0UHJvdG90eXBlJVwiOiBbXCJXZWFrU2V0XCIsIFwicHJvdG90eXBlXCJdXG4gICAgfTtcbiAgICB2YXIgYmluZCA9IHJlcXVpcmVfZnVuY3Rpb25fYmluZCgpO1xuICAgIHZhciBoYXNPd24gPSByZXF1aXJlX3NyYygpO1xuICAgIHZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xuICAgIHZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xuICAgIHZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuICAgIHZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG4gICAgdmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbiAgICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aDIoc3RyaW5nKSB7XG4gICAgICB2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcbiAgICAgIHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuICAgICAgaWYgKGZpcnN0ID09PSBcIiVcIiAmJiBsYXN0ICE9PSBcIiVcIikge1xuICAgICAgICB0aHJvdyBuZXcgJFN5bnRheEVycm9yKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gXCIlXCIgJiYgZmlyc3QgIT09IFwiJVwiKSB7XG4gICAgICAgIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgJHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsIFwiJDFcIikgOiBudW1iZXIgfHwgbWF0Y2g7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB2YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMyKG5hbWUsIGFsbG93TWlzc2luZykge1xuICAgICAgdmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuICAgICAgdmFyIGFsaWFzO1xuICAgICAgaWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcbiAgICAgICAgYWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcbiAgICAgICAgaW50cmluc2ljTmFtZSA9IFwiJVwiICsgYWxpYXNbMF0gKyBcIiVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcbiAgICAgICAgICB2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiICYmICFhbGxvd01pc3NpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcImludHJpbnNpYyBcIiArIG5hbWUgKyBcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhbGlhcyxcbiAgICAgICAgICBuYW1lOiBpbnRyaW5zaWNOYW1lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgJFN5bnRheEVycm9yKFwiaW50cmluc2ljIFwiICsgbmFtZSArIFwiIGRvZXMgbm90IGV4aXN0IVwiKTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG4gICAgICB2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiBcIlwiO1xuICAgICAgdmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoXCIlXCIgKyBpbnRyaW5zaWNCYXNlTmFtZSArIFwiJVwiLCBhbGxvd01pc3NpbmcpO1xuICAgICAgdmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG4gICAgICB2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG4gICAgICB2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG4gICAgICB2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG4gICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgaW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcbiAgICAgICAgJHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICB2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG4gICAgICAgIHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcbiAgICAgICAgaWYgKChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09IFwiYFwiIHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09IFwiYFwiKSkgJiYgZmlyc3QgIT09IGxhc3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgJFN5bnRheEVycm9yKFwicHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3Rlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydCA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8ICFpc093bikge1xuICAgICAgICAgIHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW50cmluc2ljQmFzZU5hbWUgKz0gXCIuXCIgKyBwYXJ0O1xuICAgICAgICBpbnRyaW5zaWNSZWFsTmFtZSA9IFwiJVwiICsgaW50cmluc2ljQmFzZU5hbWUgKyBcIiVcIjtcbiAgICAgICAgaWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFhbGxvd01pc3NpbmcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJiYXNlIGludHJpbnNpYyBmb3IgXCIgKyBuYW1lICsgXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRnT1BEICYmIGkgKyAxID49IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG4gICAgICAgICAgICBpc093biA9ICEhZGVzYztcbiAgICAgICAgICAgIGlmIChpc093biAmJiBcImdldFwiIGluIGRlc2MgJiYgIShcIm9yaWdpbmFsVmFsdWVcIiBpbiBkZXNjLmdldCkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBkZXNjLmdldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcGFydF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcGFydF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG4gICAgICAgICAgICBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMtbnBtLTEuMC4wLTU2Mjg5YjkxOGQtYTZkM2YwYTI2Ni56aXAvbm9kZV9tb2R1bGVzL2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycy9pbmRleC5qc1xudmFyIHJlcXVpcmVfaGFzX3Byb3BlcnR5X2Rlc2NyaXB0b3JzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzLW5wbS0xLjAuMC01NjI4OWI5MThkLWE2ZDNmMGEyNjYuemlwL25vZGVfbW9kdWxlcy9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmVfZ2V0X2ludHJpbnNpYygpO1xuICAgIHZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLCB0cnVlKTtcbiAgICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMyKCkge1xuICAgICAgaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eSh7fSwgXCJhXCIsIHsgdmFsdWU6IDEgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcbiAgICAgIGlmICghaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgXCJsZW5ndGhcIiwgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2RlZmluZS1wcm9wZXJ0aWVzLW5wbS0xLjEuNC04NWVlNTc1NjU1LWNlMGFlZjNmOWUuemlwL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfZGVmaW5lX3Byb3BlcnRpZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9kZWZpbmUtcHJvcGVydGllcy1ucG0tMS4xLjQtODVlZTU3NTY1NS1jZTBhZWYzZjllLnppcC9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGtleXMgPSByZXF1aXJlX29iamVjdF9rZXlzKCk7XG4gICAgdmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbChcImZvb1wiKSA9PT0gXCJzeW1ib2xcIjtcbiAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIHZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuICAgIHZhciBvcmlnRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiICYmIHRvU3RyLmNhbGwoZm4pID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG4gICAgfTtcbiAgICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IHJlcXVpcmVfaGFzX3Byb3BlcnR5X2Rlc2NyaXB0b3JzKCkoKTtcbiAgICB2YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgb3JpZ0RlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbihvYmplY3QsIG1hcCkge1xuICAgICAgdmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhtYXApO1xuICAgICAgaWYgKGhhc1N5bWJvbHMpIHtcbiAgICAgICAgcHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9jYWxsLWJpbmQtbnBtLTEuMC4yLWM5NTcxMjQ4NjEtZjhlMzFkZTlkMS56aXAvbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qc1xudmFyIHJlcXVpcmVfY2FsbF9iaW5kID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvY2FsbC1iaW5kLW5wbS0xLjAuMi1jOTU3MTI0ODYxLWY4ZTMxZGU5ZDEuemlwL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGJpbmQgPSByZXF1aXJlX2Z1bmN0aW9uX2JpbmQoKTtcbiAgICB2YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZV9nZXRfaW50cmluc2ljKCk7XG4gICAgdmFyICRhcHBseSA9IEdldEludHJpbnNpYyhcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO1xuICAgIHZhciAkY2FsbCA9IEdldEludHJpbnNpYyhcIiVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCVcIik7XG4gICAgdmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoXCIlUmVmbGVjdC5hcHBseSVcIiwgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuICAgIHZhciAkZ09QRCA9IEdldEludHJpbnNpYyhcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLCB0cnVlKTtcbiAgICB2YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKFwiJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSVcIiwgdHJ1ZSk7XG4gICAgdmFyICRtYXggPSBHZXRJbnRyaW5zaWMoXCIlTWF0aC5tYXglXCIpO1xuICAgIGlmICgkZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eSh7fSwgXCJhXCIsIHsgdmFsdWU6IDEgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgkZ09QRCAmJiAkZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGRlc2MgPSAkZ09QRChmdW5jLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgJGRlZmluZVByb3BlcnR5KGZ1bmMsIFwibGVuZ3RoXCIsIHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG4gICAgdmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZDIoKSB7XG4gICAgICByZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBpZiAoJGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlMi5leHBvcnRzLCBcImFwcGx5XCIsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlMi5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2NhbGwtYmluZC1ucG0tMS4wLjItYzk1NzEyNDg2MS1mOGUzMWRlOWQxLnppcC9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qc1xudmFyIHJlcXVpcmVfY2FsbEJvdW5kID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvY2FsbC1iaW5kLW5wbS0xLjAuMi1jOTU3MTI0ODYxLWY4ZTMxZGU5ZDEuemlwL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlX2dldF9pbnRyaW5zaWMoKTtcbiAgICB2YXIgY2FsbEJpbmQgPSByZXF1aXJlX2NhbGxfYmluZCgpO1xuICAgIHZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYyhcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuICAgICAgdmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG4gICAgICBpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gXCJmdW5jdGlvblwiICYmICRpbmRleE9mKG5hbWUsIFwiLnByb3RvdHlwZS5cIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRyaW5zaWM7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5hc3NpZ24tbnBtLTQuMS4yLWQ1MmVkYWRhMWMtZDYyMWQ4MzJlZC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vaW1wbGVtZW50YXRpb24uanNcbnZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uMyA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5hc3NpZ24tbnBtLTQuMS4yLWQ1MmVkYWRhMWMtZDYyMWQ4MzJlZC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vaW1wbGVtZW50YXRpb24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGtleXMgPSByZXF1aXJlX29iamVjdF9rZXlzKCk7XG4gICAgdmFyIGNhbkJlT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmogIT09IG51bGw7XG4gICAgfTtcbiAgICB2YXIgaGFzU3ltYm9scyA9IHJlcXVpcmVfc2hhbXMoKSgpO1xuICAgIHZhciBjYWxsQm91bmQgPSByZXF1aXJlX2NhbGxCb3VuZCgpO1xuICAgIHZhciB0b09iamVjdCA9IE9iamVjdDtcbiAgICB2YXIgJHB1c2ggPSBjYWxsQm91bmQoXCJBcnJheS5wcm90b3R5cGUucHVzaFwiKTtcbiAgICB2YXIgJHByb3BJc0VudW1lcmFibGUgPSBjYWxsQm91bmQoXCJPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXCIpO1xuICAgIHZhciBvcmlnaW5hbEdldFN5bWJvbHMgPSBoYXNTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IG51bGw7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlMSkge1xuICAgICAgaWYgKCFjYW5CZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICB9XG4gICAgICB2YXIgb2JqVGFyZ2V0ID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgICAgIHZhciBzLCBzb3VyY2UsIGksIHByb3BzLCBzeW1zLCB2YWx1ZSwga2V5O1xuICAgICAgZm9yIChzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7ICsrcykge1xuICAgICAgICBzb3VyY2UgPSB0b09iamVjdChhcmd1bWVudHNbc10pO1xuICAgICAgICBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgICAgdmFyIGdldFN5bWJvbHMgPSBoYXNTeW1ib2xzICYmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIHx8IG9yaWdpbmFsR2V0U3ltYm9scyk7XG4gICAgICAgIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgICAgICAgc3ltcyA9IGdldFN5bWJvbHMoc291cmNlKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAga2V5ID0gc3ltc1tpXTtcbiAgICAgICAgICAgIGlmICgkcHJvcElzRW51bWVyYWJsZShzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgJHB1c2gocHJvcHMsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IHByb3BzW2ldO1xuICAgICAgICAgIHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgaWYgKCRwcm9wSXNFbnVtZXJhYmxlKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgb2JqVGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpUYXJnZXQ7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5hc3NpZ24tbnBtLTQuMS4yLWQ1MmVkYWRhMWMtZDYyMWQ4MzJlZC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vcG9seWZpbGwuanNcbnZhciByZXF1aXJlX3BvbHlmaWxsID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LmFzc2lnbi1ucG0tNC4xLjItZDUyZWRhZGExYy1kNjIxZDgzMmVkLnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9wb2x5ZmlsbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uMygpO1xuICAgIHZhciBsYWNrc1Byb3BlckVudW1lcmF0aW9uT3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc3RyID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiO1xuICAgICAgdmFyIGxldHRlcnMgPSBzdHIuc3BsaXQoXCJcIik7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbWFwW2xldHRlcnNbaV1dID0gbGV0dGVyc1tpXTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBPYmplY3QuYXNzaWduKHt9LCBtYXApO1xuICAgICAgdmFyIGFjdHVhbCA9IFwiXCI7XG4gICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICBhY3R1YWwgKz0gaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIgIT09IGFjdHVhbDtcbiAgICB9O1xuICAgIHZhciBhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFPYmplY3QuYXNzaWduIHx8ICFPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRocm93ZXIgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoeyAxOiAyIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aHJvd2VyLCBcInh5XCIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdGhyb3dlclsxXSA9PT0gXCJ5XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcbiAgICAgIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb247XG4gICAgICB9XG4gICAgICBpZiAobGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyKCkpIHtcbiAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zKCkpIHtcbiAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ247XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5hc3NpZ24tbnBtLTQuMS4yLWQ1MmVkYWRhMWMtZDYyMWQ4MzJlZC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vc2hpbS5qc1xudmFyIHJlcXVpcmVfc2hpbSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5hc3NpZ24tbnBtLTQuMS4yLWQ1MmVkYWRhMWMtZDYyMWQ4MzJlZC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vc2hpbS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydGllcygpO1xuICAgIHZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmVfcG9seWZpbGwoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltQXNzaWduKCkge1xuICAgICAgdmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcbiAgICAgIGRlZmluZShPYmplY3QsIHsgYXNzaWduOiBwb2x5ZmlsbCB9LCB7IGFzc2lnbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduICE9PSBwb2x5ZmlsbDtcbiAgICAgIH0gfSk7XG4gICAgICByZXR1cm4gcG9seWZpbGw7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5hc3NpZ24tbnBtLTQuMS4yLWQ1MmVkYWRhMWMtZDYyMWQ4MzJlZC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vaW5kZXguanNcbnZhciByZXF1aXJlX29iamVjdCA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5hc3NpZ24tbnBtLTQuMS4yLWQ1MmVkYWRhMWMtZDYyMWQ4MzJlZC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzKCk7XG4gICAgdmFyIGNhbGxCaW5kID0gcmVxdWlyZV9jYWxsX2JpbmQoKTtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uMygpO1xuICAgIHZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmVfcG9seWZpbGwoKTtcbiAgICB2YXIgc2hpbSA9IHJlcXVpcmVfc2hpbSgpO1xuICAgIHZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kLmFwcGx5KGdldFBvbHlmaWxsKCkpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZTEpIHtcbiAgICAgIHJldHVybiBwb2x5ZmlsbChPYmplY3QsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKGJvdW5kLCB7XG4gICAgICBnZXRQb2x5ZmlsbCxcbiAgICAgIGltcGxlbWVudGF0aW9uLFxuICAgICAgc2hpbVxuICAgIH0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGJvdW5kO1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvcHJvcC10eXBlcy1leGFjdC1ucG0tMS4yLjAtNDY2NDIwOTY0OC0yMTY3NmExNmQ1LnppcC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy1leGFjdC9idWlsZC9oZWxwZXJzL2lzUGxhaW5PYmplY3QuanNcbnZhciByZXF1aXJlX2lzUGxhaW5PYmplY3QgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9wcm9wLXR5cGVzLWV4YWN0LW5wbS0xLjIuMC00NjY0MjA5NjQ4LTIxNjc2YTE2ZDUuemlwL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzLWV4YWN0L2J1aWxkL2hlbHBlcnMvaXNQbGFpbk9iamVjdC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGlzUGxhaW5PYmplY3Q7XG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gICAgICByZXR1cm4geCAmJiAodHlwZW9mIHggPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih4KSkgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoeCk7XG4gICAgfVxuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvcHJvcC10eXBlcy1leGFjdC1ucG0tMS4yLjAtNDY2NDIwOTY0OC0yMTY3NmExNmQ1LnppcC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy1leGFjdC9idWlsZC9pbmRleC5qc1xudmFyIHJlcXVpcmVfYnVpbGQgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9wcm9wLXR5cGVzLWV4YWN0LW5wbS0xLjIuMC00NjY0MjA5NjQ4LTIxNjc2YTE2ZDUuemlwL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzLWV4YWN0L2J1aWxkL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZvcmJpZEV4dHJhUHJvcHM7XG4gICAgdmFyIF9vYmplY3QgPSByZXF1aXJlX29iamVjdCgpO1xuICAgIHZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG4gICAgdmFyIF9oYXMgPSByZXF1aXJlX3NyYygpO1xuICAgIHZhciBfaGFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhcyk7XG4gICAgdmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZV9pc1BsYWluT2JqZWN0KCk7XG4gICAgdmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgemVyb1dpZHRoU3BhY2UgPSBcIlxcdTIwMEJcIjtcbiAgICB2YXIgc3BlY2lhbFByb3BlcnR5ID0gXCJwcm9wLXR5cGVzLWV4YWN0OiBcIiArIHplcm9XaWR0aFNwYWNlO1xuICAgIHZhciBzZW1hcGhvcmUgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbFtcImZvclwiXSA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sW1wiZm9yXCJdKHNwZWNpYWxQcm9wZXJ0eSkgOiBzcGVjaWFsUHJvcGVydHk7XG4gICAgZnVuY3Rpb24gYnJhbmQoZm4pIHtcbiAgICAgIHJldHVybiAoMCwgX29iamVjdDJbXCJkZWZhdWx0XCJdKShmbiwgX2RlZmluZVByb3BlcnR5KHt9LCBzcGVjaWFsUHJvcGVydHksIHNlbWFwaG9yZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JyYW5kZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZVtzcGVjaWFsUHJvcGVydHldID09PSBzZW1hcGhvcmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcmJpZEV4dHJhUHJvcHMocHJvcFR5cGVzKSB7XG4gICAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShwcm9wVHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJnaXZlbiBwcm9wVHlwZXMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoKDAsIF9oYXMyW1wiZGVmYXVsdFwiXSkocHJvcFR5cGVzLCBzcGVjaWFsUHJvcGVydHkpICYmICFpc0JyYW5kZWQocHJvcFR5cGVzW3NwZWNpYWxQcm9wZXJ0eV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBZ2FpbnN0IGFsbCBvZGRzLCB5b3UgY3JlYXRlZCBhIHByb3BUeXBlIGZvciBhIHByb3AgdGhhdCB1c2VzIGJvdGggdGhlIHplcm8td2lkdGggc3BhY2UgYW5kIG91ciBjdXN0b20gc3RyaW5nIC0gd2hpY2gsIHNhZGx5LCBjb25mbGljdHMgd2l0aCBgcHJvcC10eXBlcy1leGFjdGBcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKDAsIF9vYmplY3QyW1wiZGVmYXVsdFwiXSkoe30sIHByb3BUeXBlcywgX2RlZmluZVByb3BlcnR5KHt9LCBzcGVjaWFsUHJvcGVydHksIGJyYW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBmb3JiaWRVbmtub3duUHJvcHMocHJvcHMsIF8sIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgICB2YXIgdW5rbm93blByb3BzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gISgwLCBfaGFzMltcImRlZmF1bHRcIl0pKHByb3BUeXBlcywgcHJvcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihTdHJpbmcoY29tcG9uZW50TmFtZSkgKyBcIjogdW5rbm93biBwcm9wcyBmb3VuZDogXCIgKyBTdHJpbmcodW5rbm93blByb3BzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yYmlkVW5rbm93blByb3BzO1xuICAgICAgfSgpKSkpO1xuICAgIH1cbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvaGVscGVycy93cmFwVmFsaWRhdG9yLmpzXG52YXIgcmVxdWlyZV93cmFwVmFsaWRhdG9yID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9oZWxwZXJzL3dyYXBWYWxpZGF0b3IuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd3JhcFZhbGlkYXRvcjtcbiAgICB2YXIgX29iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9vYmplY3QoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcFZhbGlkYXRvcih2YWxpZGF0b3IsIHR5cGVOYW1lKSB7XG4gICAgICB2YXIgdHlwZUNoZWNrZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICByZXR1cm4gKDAsIF9vYmplY3RbXCJkZWZhdWx0XCJdKSh2YWxpZGF0b3IuYmluZCgpLCB7XG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICB0eXBlQ2hlY2tlcixcbiAgICAgICAgaXNSZXF1aXJlZDogKDAsIF9vYmplY3RbXCJkZWZhdWx0XCJdKSh2YWxpZGF0b3IuaXNSZXF1aXJlZC5iaW5kKCksIHtcbiAgICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgICB0eXBlQ2hlY2tlcixcbiAgICAgICAgICB0eXBlUmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvYW5kLmpzXG52YXIgcmVxdWlyZV9hbmQgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2FuZC5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhbmRWYWxpZGF0b3I7XG4gICAgdmFyIF93cmFwVmFsaWRhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3dyYXBWYWxpZGF0b3IoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW5kVmFsaWRhdG9yKHZhbGlkYXRvcnMpIHtcbiAgICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBcImFuZFwiO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhbmQ6IDIgb3IgbW9yZSB2YWxpZGF0b3JzIGFyZSByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0b3JzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYW5kOiAyIG9yIG1vcmUgdmFsaWRhdG9ycyBhcmUgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24gYW5kKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdEVycm9yID0gbnVsbDtcbiAgICAgICAgdmFsaWRhdG9ycy5zb21lKGZ1bmN0aW9uKHZhbGlkYXRvckZuKSB7XG4gICAgICAgICAgZmlyc3RFcnJvciA9IHZhbGlkYXRvckZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0RXJyb3IgIT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaXJzdEVycm9yID09IG51bGwgPyBudWxsIDogZmlyc3RFcnJvcjtcbiAgICAgIH07XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIGFuZElzUmVxdWlyZWQoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RFcnJvciA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRvcnMuc29tZShmdW5jdGlvbih2YWxpZGF0b3JGbikge1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSB2YWxpZGF0b3JGbi5pc1JlcXVpcmVkLmFwcGx5KHZhbGlkYXRvckZuLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gZmlyc3RFcnJvciAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpcnN0RXJyb3IgPT0gbnVsbCA/IG51bGwgOiBmaXJzdEVycm9yO1xuICAgICAgfTtcbiAgICAgIHJldHVybiAoMCwgX3dyYXBWYWxpZGF0b3JbXCJkZWZhdWx0XCJdKSh2YWxpZGF0b3IsIG5hbWUsIHZhbGlkYXRvcnMpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLWFic3RyYWN0LW5wbS0xLjE5LjUtNTI0YTg3ZDI2Mi01NTE5OWIwZjE3LnppcC9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvNS9DaGVja09iamVjdENvZXJjaWJsZS5qc1xudmFyIHJlcXVpcmVfQ2hlY2tPYmplY3RDb2VyY2libGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzUvQ2hlY2tPYmplY3RDb2VyY2libGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmVfZ2V0X2ludHJpbnNpYygpO1xuICAgIHZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKFwiJVR5cGVFcnJvciVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gQ2hlY2tPYmplY3RDb2VyY2libGUodmFsdWUsIG9wdE1lc3NhZ2UpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKG9wdE1lc3NhZ2UgfHwgXCJDYW5ub3QgY2FsbCBtZXRob2Qgb24gXCIgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLWFic3RyYWN0LW5wbS0xLjE5LjUtNTI0YTg3ZDI2Mi01NTE5OWIwZjE3LnppcC9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlLmpzXG52YXIgcmVxdWlyZV9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1JlcXVpcmVPYmplY3RDb2VyY2libGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9DaGVja09iamVjdENvZXJjaWJsZSgpO1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LmVudHJpZXMtbnBtLTEuMS41LTdhOGZjYmM0M2UtZDY1ODY5NmY3NC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5lbnRyaWVzL2ltcGxlbWVudGF0aW9uLmpzXG52YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjQgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QuZW50cmllcy1ucG0tMS4xLjUtN2E4ZmNiYzQzZS1kNjU4Njk2Zjc0LnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LmVudHJpZXMvaW1wbGVtZW50YXRpb24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlX1JlcXVpcmVPYmplY3RDb2VyY2libGUoKTtcbiAgICB2YXIgY2FsbEJvdW5kID0gcmVxdWlyZV9jYWxsQm91bmQoKTtcbiAgICB2YXIgJGlzRW51bWVyYWJsZSA9IGNhbGxCb3VuZChcIk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVcIik7XG4gICAgdmFyICRwdXNoID0gY2FsbEJvdW5kKFwiQXJyYXkucHJvdG90eXBlLnB1c2hcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gZW50cmllcyhPKSB7XG4gICAgICB2YXIgb2JqID0gUmVxdWlyZU9iamVjdENvZXJjaWJsZShPKTtcbiAgICAgIHZhciBlbnRyeXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCRpc0VudW1lcmFibGUob2JqLCBrZXkpKSB7XG4gICAgICAgICAgJHB1c2goZW50cnlzLCBba2V5LCBvYmpba2V5XV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnlzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QuZW50cmllcy1ucG0tMS4xLjUtN2E4ZmNiYzQzZS1kNjU4Njk2Zjc0LnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LmVudHJpZXMvcG9seWZpbGwuanNcbnZhciByZXF1aXJlX3BvbHlmaWxsMiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC5lbnRyaWVzLW5wbS0xLjEuNS03YThmY2JjNDNlLWQ2NTg2OTZmNzQuemlwL25vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy9wb2x5ZmlsbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uNCgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBPYmplY3QuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmVudHJpZXMgOiBpbXBsZW1lbnRhdGlvbjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LmVudHJpZXMtbnBtLTEuMS41LTdhOGZjYmM0M2UtZDY1ODY5NmY3NC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5lbnRyaWVzL3NoaW0uanNcbnZhciByZXF1aXJlX3NoaW0yID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LmVudHJpZXMtbnBtLTEuMS41LTdhOGZjYmM0M2UtZDY1ODY5NmY3NC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5lbnRyaWVzL3NoaW0uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZV9wb2x5ZmlsbDIoKTtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydGllcygpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1FbnRyaWVzKCkge1xuICAgICAgdmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcbiAgICAgIGRlZmluZShPYmplY3QsIHsgZW50cmllczogcG9seWZpbGwgfSwge1xuICAgICAgICBlbnRyaWVzOiBmdW5jdGlvbiB0ZXN0RW50cmllcygpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMgIT09IHBvbHlmaWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb2x5ZmlsbDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LmVudHJpZXMtbnBtLTEuMS41LTdhOGZjYmM0M2UtZDY1ODY5NmY3NC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5lbnRyaWVzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9vYmplY3QyID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LmVudHJpZXMtbnBtLTEuMS41LTdhOGZjYmM0M2UtZDY1ODY5NmY3NC56aXAvbm9kZV9tb2R1bGVzL29iamVjdC5lbnRyaWVzL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzKCk7XG4gICAgdmFyIGNhbGxCaW5kID0gcmVxdWlyZV9jYWxsX2JpbmQoKTtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uNCgpO1xuICAgIHZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmVfcG9seWZpbGwyKCk7XG4gICAgdmFyIHNoaW0gPSByZXF1aXJlX3NoaW0yKCk7XG4gICAgdmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcbiAgICBkZWZpbmUocG9seWZpbGwsIHtcbiAgICAgIGdldFBvbHlmaWxsLFxuICAgICAgaW1wbGVtZW50YXRpb24sXG4gICAgICBzaGltXG4gICAgfSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcG9seWZpbGw7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2hlbHBlcnMvaXNQbGFpbk9iamVjdC5qc1xudmFyIHJlcXVpcmVfaXNQbGFpbk9iamVjdDIgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2hlbHBlcnMvaXNQbGFpbk9iamVjdC5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gICAgdmFyIF9pc1BsYWluT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2lzUGxhaW5PYmplY3QoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgdmFyIF9kZWZhdWx0ID0gX2lzUGxhaW5PYmplY3RbXCJkZWZhdWx0XCJdO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL3NoYXBlLmpzXG52YXIgcmVxdWlyZV9zaGFwZSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvc2hhcGUuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2hhcGVWYWxpZGF0b3I7XG4gICAgdmFyIF9pc1BsYWluT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2lzUGxhaW5PYmplY3QyKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNoYXBlVmFsaWRhdG9yKHNoYXBlVHlwZXMpIHtcbiAgICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0W1wiZGVmYXVsdFwiXSkoc2hhcGVUeXBlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNoYXBlIG11c3QgYmUgYSBub3JtYWwgb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2hhcGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gNCA/IF9sZW4gLSA0IDogMCksIF9rZXkgPSA0OyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5IC0gNF0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgICBpZiAoY2hlY2tlcikge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlci5hcHBseSh2b2lkIDAsIFtwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb25dLmNvbmNhdChyZXN0KSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNoYXBlLmlzUmVxdWlyZWQgPSBmdW5jdGlvbiBzaGFwZVJlcXVpcmVkKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogXCIpLmNvbmNhdChwcm9wTmFtZSwgXCIgaXMgcmVxdWlyZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjIgPiAzID8gX2xlbjIgLSAzIDogMCksIF9rZXkyID0gMzsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIHJlc3RbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYXBlLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkoc2hhcGUsIFwic2hhcGVcIiwgc2hhcGVUeXBlcyk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzXG52YXIgcmVxdWlyZV9pc1ByaW1pdGl2ZSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvaGVscGVycy9pc1ByaW1pdGl2ZS5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpc1ByaW1pdGl2ZTtcbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmoyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmoyO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iajIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqMiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqMi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iajIgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajI7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh4KSB7XG4gICAgICByZXR1cm4gIXggfHwgX3R5cGVvZih4KSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgeCAhPT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvdmFsdWVzT2YuanNcbnZhciByZXF1aXJlX3ZhbHVlc09mID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC92YWx1ZXNPZi5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2YWx1ZXNPZlZhbGlkYXRvcjtcbiAgICB2YXIgX2lzUHJpbWl0aXZlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2lzUHJpbWl0aXZlKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbHVlc09mVmFsaWRhdG9yKHByb3BUeXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9iamVjdE9mOiBwcm9wVHlwZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24gdmFsdWVzT2YocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiA1ID8gX2xlbiAtIDUgOiAwKSwgX2tleSA9IDU7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICByZXN0W19rZXkgLSA1XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwgfHwgKDAsIF9pc1ByaW1pdGl2ZVtcImRlZmF1bHRcIl0pKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RFcnJvcjtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcFZhbHVlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSBwcm9wVHlwZS5hcHBseSh2b2lkIDAsIFtwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIFwiXCIuY29uY2F0KHByb3BGdWxsTmFtZSwgXCIuXCIpLmNvbmNhdChrZXkpXS5jb25jYXQocmVzdCkpO1xuICAgICAgICAgIHJldHVybiBmaXJzdEVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpcnN0RXJyb3IgfHwgbnVsbDtcbiAgICAgIH07XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIHZhbHVlc09mUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBcIikuY29uY2F0KHByb3BOYW1lLCBcIiBpcyByZXF1aXJlZC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdG9yLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBcInZhbHVlc09mXCIsIHByb3BUeXBlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2JldHdlZW4uanNcbnZhciByZXF1aXJlX2JldHdlZW4gPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2JldHdlZW4uanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYmV0d2VlblZhbGlkYXRvcjtcbiAgICB2YXIgX29iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9vYmplY3QyKCkpO1xuICAgIHZhciBfc2hhcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2hhcGUoKSk7XG4gICAgdmFyIF92YWx1ZXNPZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV92YWx1ZXNPZigpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmoyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmoyO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iajIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqMiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqMi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iajIgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajI7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIGlmIChpICUgMikge1xuICAgICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcilcbiAgICAgICAgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpXG4gICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBfYXJyID0gW107XG4gICAgICB2YXIgX24gPSB0cnVlO1xuICAgICAgdmFyIF9kID0gZmFsc2U7XG4gICAgICB2YXIgX2UgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcbiAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2QgPSB0cnVlO1xuICAgICAgICBfZSA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKVxuICAgICAgICAgICAgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2QpXG4gICAgICAgICAgICB0aHJvdyBfZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51bWJlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBcIikuY29uY2F0KHByb3BOYW1lLCBcIiBtdXN0IGJlIGEgbm9uLU5hTiBudW1iZXIuXCIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbnVtYmVyT3JQcm9wc0Z1bmMocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChwcm9wTmFtZSwgXCI6IGEgZnVuY3Rpb24sIG9yIGEgbm9uLU5hTiBudW1iZXIgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb3dlckNvbXBhcmUodmFsdWUsIF9yZWYpIHtcbiAgICAgIHZhciBndCA9IF9yZWYuZ3QsIGd0ZSA9IF9yZWYuZ3RlO1xuICAgICAgaWYgKHR5cGVvZiBndCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPiBndDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZ3RlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSBndGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBwZXJDb21wYXJlKHZhbHVlLCBfcmVmMikge1xuICAgICAgdmFyIGx0ID0gX3JlZjIubHQsIGx0ZSA9IF9yZWYyLmx0ZTtcbiAgICAgIGlmICh0eXBlb2YgbHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgbHQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGx0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gbHRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdyZWF0ZXJUaGFuRXJyb3IoX3JlZjMpIHtcbiAgICAgIHZhciBndCA9IF9yZWYzLmd0LCBndGUgPSBfcmVmMy5ndGU7XG4gICAgICBpZiAodHlwZW9mIGd0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcImdyZWF0ZXIgdGhhbiBcIi5jb25jYXQoZ3QpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBndGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiLmNvbmNhdChndGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlc3NUaGFuRXJyb3IoX3JlZjQpIHtcbiAgICAgIHZhciBsdCA9IF9yZWY0Lmx0LCBsdGUgPSBfcmVmNC5sdGU7XG4gICAgICBpZiAodHlwZW9mIGx0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcImxlc3MgdGhhbiBcIi5jb25jYXQobHQpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvIFwiLmNvbmNhdChsdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVycm9yTWVzc2FnZShjb21wb25lbnROYW1lLCBwcm9wTmFtZSwgb3B0cykge1xuICAgICAgdmFyIGVycm9ycyA9IFtncmVhdGVyVGhhbkVycm9yKG9wdHMpLCBsZXNzVGhhbkVycm9yKG9wdHMpXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBhbmQgXCIpO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBcIikuY29uY2F0KHByb3BOYW1lLCBcIiBtdXN0IGJlIFwiKS5jb25jYXQoZXJyb3JzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcHNUaHVua2lmeShvcHRzKSB7XG4gICAgICByZXR1cm4gKDAsIF9vYmplY3RbXCJkZWZhdWx0XCJdKShvcHRzKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBfcmVmNSkge1xuICAgICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksIGtleSA9IF9yZWY2WzBdLCB2YWx1ZSA9IF9yZWY2WzFdO1xuICAgICAgICB2YXIgbnVtYmVyVGh1bmsgPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYWNjKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBudW1iZXJUaHVuaykpO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2VXaXRoUHJvcHMob3B0c1RodW5rcywgcHJvcHMpIHtcbiAgICAgIHJldHVybiAoMCwgX29iamVjdFtcImRlZmF1bHRcIl0pKG9wdHNUaHVua3MpLnJlZHVjZShmdW5jdGlvbihhY2MsIF9yZWY3KSB7XG4gICAgICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAyKSwga2V5ID0gX3JlZjhbMF0sIHRodW5rID0gX3JlZjhbMV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHRodW5rKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYWNjKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSkpO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICB2YXIgYXJnVmFsaWRhdG9ycyA9IFsoMCwgX3NoYXBlW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgbHQ6IG51bWJlck9yUHJvcHNGdW5jLFxuICAgICAgZ3Q6IG51bWJlck9yUHJvcHNGdW5jXG4gICAgfSkuaXNSZXF1aXJlZCwgKDAsIF9zaGFwZVtcImRlZmF1bHRcIl0pKHtcbiAgICAgIGx0ZTogbnVtYmVyT3JQcm9wc0Z1bmMsXG4gICAgICBndDogbnVtYmVyT3JQcm9wc0Z1bmNcbiAgICB9KS5pc1JlcXVpcmVkLCAoMCwgX3NoYXBlW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgbHQ6IG51bWJlck9yUHJvcHNGdW5jLFxuICAgICAgZ3RlOiBudW1iZXJPclByb3BzRnVuY1xuICAgIH0pLmlzUmVxdWlyZWQsICgwLCBfc2hhcGVbXCJkZWZhdWx0XCJdKSh7XG4gICAgICBsdGU6IG51bWJlck9yUHJvcHNGdW5jLFxuICAgICAgZ3RlOiBudW1iZXJPclByb3BzRnVuY1xuICAgIH0pLmlzUmVxdWlyZWQsICgwLCBfc2hhcGVbXCJkZWZhdWx0XCJdKSh7XG4gICAgICBsdDogbnVtYmVyT3JQcm9wc0Z1bmNcbiAgICB9KS5pc1JlcXVpcmVkLCAoMCwgX3NoYXBlW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgbHRlOiBudW1iZXJPclByb3BzRnVuY1xuICAgIH0pLmlzUmVxdWlyZWQsICgwLCBfc2hhcGVbXCJkZWZhdWx0XCJdKSh7XG4gICAgICBndDogbnVtYmVyT3JQcm9wc0Z1bmNcbiAgICB9KS5pc1JlcXVpcmVkLCAoMCwgX3NoYXBlW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgZ3RlOiBudW1iZXJPclByb3BzRnVuY1xuICAgIH0pLmlzUmVxdWlyZWRdO1xuICAgIGZ1bmN0aW9uIGFyZ1ZhbGlkYXRvcihwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIHJldHVybiBhcmdWYWxpZGF0b3JzLmV2ZXJ5KGZ1bmN0aW9uKHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gISF2YWxpZGF0b3IocHJvcHMsIHByb3BOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdGh1bmtWYWx1ZVZhbGlkYXRvciA9ICgwLCBfdmFsdWVzT2ZbXCJkZWZhdWx0XCJdKShudW1iZXIpLmlzUmVxdWlyZWQ7XG4gICAgZnVuY3Rpb24gYmV0d2VlblZhbGlkYXRvcihvcHRpb25zKSB7XG4gICAgICB2YXIgYXJnRXJyb3IgPSBhcmdWYWxpZGF0b3Ioe1xuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBcIm9wdGlvbnNcIik7XG4gICAgICBpZiAoYXJnRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImJldHdlZW46IG9ubHkgb25lIG9mIHRoZSBwYWlycyBvZiBgbHRgL2BsdGVgLCBhbmQgYGd0YC9gZ3RlYCwgbWF5IGJlIHN1cHBsaWVkLCBhbmQgYXQgbGVhc3Qgb25lIHBhaXIgbXVzdCBiZSBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgICB2YXIgb3B0c1RodW5rcyA9IHByb3BzVGh1bmtpZnkob3B0aW9ucyk7XG4gICAgICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24gYmV0d2Vlbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCI6IFwiKS5jb25jYXQocHJvcE5hbWUsICcgbXVzdCBiZSBhIG51bWJlciwgZ290IFwiJykuY29uY2F0KF90eXBlb2YocHJvcFZhbHVlKSwgJ1wiJykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRzID0gaW52b2tlV2l0aFByb3BzKG9wdHNUaHVua3MsIHByb3BzKTtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIHJlc3RbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aHVua1ZhbHVlc0Vycm9yID0gdGh1bmtWYWx1ZVZhbGlkYXRvci5hcHBseSh2b2lkIDAsIFtfZGVmaW5lUHJvcGVydHkoe30sIHByb3BOYW1lLCBvcHRzKSwgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIGlmICh0aHVua1ZhbHVlc0Vycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRodW5rVmFsdWVzRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb3dlckNvbXBhcmUocHJvcFZhbHVlLCBvcHRzKSB8fCAhdXBwZXJDb21wYXJlKHByb3BWYWx1ZSwgb3B0cykpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IoZXJyb3JNZXNzYWdlKGNvbXBvbmVudE5hbWUsIHByb3BOYW1lLCBvcHRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgdmFsaWRhdG9yLmlzUmVxdWlyZWQgPSBmdW5jdGlvbiBiZXR3ZWVuUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBcIikuY29uY2F0KHByb3BOYW1lLCAnIG11c3QgYmUgYSBudW1iZXIsIGdvdCBcIicpLmNvbmNhdChfdHlwZW9mKHByb3BWYWx1ZSksICdcIicpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0cyA9IGludm9rZVdpdGhQcm9wcyhvcHRzVGh1bmtzLCBwcm9wcyk7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGh1bmtWYWx1ZXNFcnJvciA9IHRodW5rVmFsdWVWYWxpZGF0b3IuYXBwbHkodm9pZCAwLCBbX2RlZmluZVByb3BlcnR5KHt9LCBwcm9wTmFtZSwgb3B0cyksIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgICBpZiAodGh1bmtWYWx1ZXNFcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aHVua1ZhbHVlc0Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbG93ZXJDb21wYXJlKHByb3BWYWx1ZSwgb3B0cykgfHwgIXVwcGVyQ29tcGFyZShwcm9wVmFsdWUsIG9wdHMpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKGVycm9yTWVzc2FnZShjb21wb25lbnROYW1lLCBwcm9wTmFtZSwgb3B0cykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiAoMCwgX3dyYXBWYWxpZGF0b3JbXCJkZWZhdWx0XCJdKSh2YWxpZGF0b3IsIFwiYmV0d2VlblwiLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2Jvb2xlYW5Tb21lLmpzXG52YXIgcmVxdWlyZV9ib29sZWFuU29tZSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvYm9vbGVhblNvbWUuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYm9vbGVhblNvbWVWYWxpZGF0b3I7XG4gICAgdmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlX3Byb3BfdHlwZXMoKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBib29sZWFuU29tZVZhbGlkYXRvcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBub3RBbGxQcm9wc0ZhbHNlID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBub3RBbGxQcm9wc0ZhbHNlW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKG5vdEFsbFByb3BzRmFsc2UubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXQgbGVhc3Qgb25lIHByb3AgKG9uZSBvZiB3aGljaCBtdXN0IGJlIGB0cnVlYCkgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW5vdEFsbFByb3BzRmFsc2UuZXZlcnkoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3RyaW5nXCI7XG4gICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYWxsIGJvb2xlYW5Tb21lIHByb3BzIG11c3QgYmUgc3RyaW5nc1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wc0xpc3QgPSBub3RBbGxQcm9wc0ZhbHNlLmpvaW4oXCIsIG9yIFwiKTtcbiAgICAgIHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbiBib29sZWFuU29tZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGNvdW50RmFsc2UgPSBmdW5jdGlvbiBjb3VudEZhbHNlMihjb3VudCwgcHJvcCkge1xuICAgICAgICAgIHJldHVybiBjb3VudCArIChwcm9wc1twcm9wXSA9PT0gZmFsc2UgPyAxIDogMCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYWxzZVByb3BDb3VudCA9IG5vdEFsbFByb3BzRmFsc2UucmVkdWNlKGNvdW50RmFsc2UsIDApO1xuICAgICAgICBpZiAoZmFsc2VQcm9wQ291bnQgPT09IG5vdEFsbFByb3BzRmFsc2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkEgXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlc2UgYm9vbGVhbiBwcm9wcyBiZSBgdHJ1ZWA6IFwiKS5jb25jYXQocHJvcHNMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4yID4gMyA/IF9sZW4yIC0gMyA6IDApLCBfa2V5MiA9IDM7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICByZXN0W19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcHJvcFR5cGVzLmJvb2wuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgfTtcbiAgICAgIHZhbGlkYXRvci5pc1JlcXVpcmVkID0gZnVuY3Rpb24gYm9vbGVhblNvbWVSZXF1aXJlZChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGNvdW50RmFsc2UgPSBmdW5jdGlvbiBjb3VudEZhbHNlMihjb3VudCwgcHJvcCkge1xuICAgICAgICAgIHJldHVybiBjb3VudCArIChwcm9wc1twcm9wXSA9PT0gZmFsc2UgPyAxIDogMCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYWxzZVByb3BDb3VudCA9IG5vdEFsbFByb3BzRmFsc2UucmVkdWNlKGNvdW50RmFsc2UsIDApO1xuICAgICAgICBpZiAoZmFsc2VQcm9wQ291bnQgPT09IG5vdEFsbFByb3BzRmFsc2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkEgXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlc2UgYm9vbGVhbiBwcm9wcyBiZSBgdHJ1ZWA6IFwiKS5jb25jYXQocHJvcHNMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMyA/IF9sZW4zIC0gMyA6IDApLCBfa2V5MyA9IDM7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gM10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZC5hcHBseShfcHJvcFR5cGVzLmJvb2wsIFtwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgXCJib29sZWFuU29tZTogXCIuY29uY2F0KHByb3BzTGlzdCksIG5vdEFsbFByb3BzRmFsc2UpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvY2hpbGRyZW5IYXZlUHJvcFhvckNoaWxkcmVuLmpzXG52YXIgcmVxdWlyZV9jaGlsZHJlbkhhdmVQcm9wWG9yQ2hpbGRyZW4gPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2NoaWxkcmVuSGF2ZVByb3BYb3JDaGlsZHJlbi5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjaGlsZHJlbkhhdmVQcm9wWG9yQ2hpbGRyZW47XG4gICAgdmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmoyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmoyO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iajIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqMiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqMi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iajIgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajI7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGlsZHJlbkhhdmVQcm9wWG9yQ2hpbGRyZW4ocHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wICE9PSBcInN0cmluZ1wiICYmIF90eXBlb2YocHJvcCkgIT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcHJvcDogbXVzdCBiZSBzdHJpbmcgb3Igc3ltYm9sXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIGNoaWxkcmVuSGF2ZVByb3BYb3JDaGlsZHJlbldpdGhQcm9wKF9yZWYsIF8sIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgICAgICAgdmFyIHRydXRoeUNoaWxkcmVuQ291bnQgPSAwO1xuICAgICAgICB2YXIgcHJvcENvdW50ID0gMDtcbiAgICAgICAgdmFyIGdyYW5kY2hpbGRyZW5Db3VudCA9IDA7XG4gICAgICAgIF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRydXRoeUNoaWxkcmVuQ291bnQgKz0gMTtcbiAgICAgICAgICBpZiAoY2hpbGQucHJvcHNbcHJvcF0pIHtcbiAgICAgICAgICAgIHByb3BDb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChjaGlsZC5wcm9wcy5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGdyYW5kY2hpbGRyZW5Db3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9wQ291bnQgPT09IHRydXRoeUNoaWxkcmVuQ291bnQgJiYgZ3JhbmRjaGlsZHJlbkNvdW50ID09PSAwIHx8IHByb3BDb3VudCA9PT0gMCAmJiBncmFuZGNoaWxkcmVuQ291bnQgPT09IHRydXRoeUNoaWxkcmVuQ291bnQgfHwgcHJvcENvdW50ID09PSAwICYmIGdyYW5kY2hpbGRyZW5Db3VudCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiYFwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcImAgcmVxdWlyZXMgY2hpbGRyZW4gdG8gYWxsIGhhdmUgcHJvcCBcXHUyMDFDXCIpLmNvbmNhdChwcm9wLCBcIlxcdTIwMUQsIGFsbCBoYXZlIGNoaWxkcmVuLCBvciBhbGwgaGF2ZSBuZWl0aGVyLlwiKSk7XG4gICAgICB9O1xuICAgICAgdmFsaWRhdG9yLmlzUmVxdWlyZWQgPSB2YWxpZGF0b3I7XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBcImNoaWxkcmVuSGF2ZVByb3BYb3JDaGlsZHJlbldpdGhQcm9wOlwiLmNvbmNhdChwcm9wKSwgcHJvcCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9oZWxwZXJzL3JlbmRlcmFibGVDaGlsZHJlbi5qc1xudmFyIHJlcXVpcmVfcmVuZGVyYWJsZUNoaWxkcmVuID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9oZWxwZXJzL3JlbmRlcmFibGVDaGlsZHJlbi5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSByZW5kZXJhYmxlQ2hpbGRyZW47XG4gICAgdmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJhYmxlQ2hpbGRyZW4oY2hpbGRyZW5Qcm9wKSB7XG4gICAgICByZXR1cm4gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuUHJvcCkuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZCA9PT0gMCB8fCBjaGlsZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvY2hpbGRyZW5PZi5qc1xudmFyIHJlcXVpcmVfY2hpbGRyZW5PZiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvY2hpbGRyZW5PZi5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjaGlsZHJlbk9mO1xuICAgIHZhciBfcmVuZGVyYWJsZUNoaWxkcmVuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlbmRlcmFibGVDaGlsZHJlbigpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIGlmIChpICUgMikge1xuICAgICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZHJlbihwcm9wVHlwZSwgY2hpbGRyZW4sIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlc3RbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yO1xuICAgICAgY2hpbGRyZW4uc29tZShmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBlcnJvciA9IHByb3BUeXBlLmFwcGx5KHZvaWQgMCwgW19vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZFxuICAgICAgICB9KSwgXCJjaGlsZHJlblwiXS5jb25jYXQocmVzdCkpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlcnJvciB8fCBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGlsZHJlbk9mKHByb3BUeXBlKSB7XG4gICAgICBmdW5jdGlvbiBjaGlsZHJlbk9mUHJvcFR5cGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gXCJjaGlsZHJlblwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgJyBpcyB1c2luZyB0aGUgY2hpbGRyZW5PZiB2YWxpZGF0b3Igb24gbm9uLWNoaWxkcmVuIHByb3AgXCInKS5jb25jYXQocHJvcE5hbWUsICdcIicpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSAoMCwgX3JlbmRlcmFibGVDaGlsZHJlbltcImRlZmF1bHRcIl0pKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjIgPiAzID8gX2xlbjIgLSAzIDogMCksIF9rZXkyID0gMzsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIHJlc3RbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQ2hpbGRyZW4uYXBwbHkodm9pZCAwLCBbcHJvcFR5cGUsIGNoaWxkcmVuLCBwcm9wcywgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuT2ZQcm9wVHlwZS5pc1JlcXVpcmVkID0gZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gXCJjaGlsZHJlblwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgJyBpcyB1c2luZyB0aGUgY2hpbGRyZW5PZiB2YWxpZGF0b3Igb24gbm9uLWNoaWxkcmVuIHByb3AgXCInKS5jb25jYXQocHJvcE5hbWUsICdcIicpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSAoMCwgX3JlbmRlcmFibGVDaGlsZHJlbltcImRlZmF1bHRcIl0pKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCJgIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBub2RlIG9mIHR5cGUgXCIpLmNvbmNhdChwcm9wVHlwZS50eXBlTmFtZSB8fCBwcm9wVHlwZS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMyA/IF9sZW4zIC0gMyA6IDApLCBfa2V5MyA9IDM7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gM10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUNoaWxkcmVuLmFwcGx5KHZvaWQgMCwgW3Byb3BUeXBlLCBjaGlsZHJlbiwgcHJvcHMsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKGNoaWxkcmVuT2ZQcm9wVHlwZSwgXCJjaGlsZHJlbk9mXCIsIHByb3BUeXBlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9PYmplY3QuanNcbnZhciByZXF1aXJlX1RvT2JqZWN0ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvT2JqZWN0LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlX2dldF9pbnRyaW5zaWMoKTtcbiAgICB2YXIgJE9iamVjdCA9IEdldEludHJpbnNpYyhcIiVPYmplY3QlXCIpO1xuICAgIHZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZV9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gVG9PYmplY3QodmFsdWUpIHtcbiAgICAgIFJlcXVpcmVPYmplY3RDb2VyY2libGUodmFsdWUpO1xuICAgICAgcmV0dXJuICRPYmplY3QodmFsdWUpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvbWF4U2FmZUludGVnZXIuanNcbnZhciByZXF1aXJlX21heFNhZmVJbnRlZ2VyID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL21heFNhZmVJbnRlZ2VyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlX2dldF9pbnRyaW5zaWMoKTtcbiAgICB2YXIgJE1hdGggPSBHZXRJbnRyaW5zaWMoXCIlTWF0aCVcIik7XG4gICAgdmFyICROdW1iZXIgPSBHZXRJbnRyaW5zaWMoXCIlTnVtYmVyJVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAkTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgJE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvYWJzLmpzXG52YXIgcmVxdWlyZV9hYnMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvYWJzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlX2dldF9pbnRyaW5zaWMoKTtcbiAgICB2YXIgJGFicyA9IEdldEludHJpbnNpYyhcIiVNYXRoLmFicyVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gYWJzKHgpIHtcbiAgICAgIHJldHVybiAkYWJzKHgpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvZmxvb3IuanNcbnZhciByZXF1aXJlX2Zsb29yID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL2Zsb29yLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsb29yKHgpIHtcbiAgICAgIHJldHVybiAkZmxvb3IoeCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLWFic3RyYWN0LW5wbS0xLjE5LjUtNTI0YTg3ZDI2Mi01NTE5OWIwZjE3LnppcC9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9yZWdleFRlc3Rlci5qc1xudmFyIHJlcXVpcmVfcmVnZXhUZXN0ZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvcmVnZXhUZXN0ZXIuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGNhbGxCb3VuZCA9IHJlcXVpcmVfY2FsbEJvdW5kKCk7XG4gICAgdmFyICRleGVjID0gY2FsbEJvdW5kKFwiUmVnRXhwLnByb3RvdHlwZS5leGVjXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZ2V4VGVzdGVyKHJlZ2V4KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdGVzdChzKSB7XG4gICAgICAgIHJldHVybiAkZXhlYyhyZWdleCwgcykgIT09IG51bGw7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNQcmltaXRpdmUuanNcbnZhciByZXF1aXJlX2lzUHJpbWl0aXZlMiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLWFic3RyYWN0LW5wbS0xLjE5LjUtNTI0YTg3ZDI2Mi01NTE5OWIwZjE3LnppcC9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc1ByaW1pdGl2ZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtdG8tcHJpbWl0aXZlLW5wbS0xLjIuMS1iN2E3ZWFjNmM1LTRlYWQ2NjcxYTIuemlwL25vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvaGVscGVycy9pc1ByaW1pdGl2ZS5qc1xudmFyIHJlcXVpcmVfaXNQcmltaXRpdmUzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtdG8tcHJpbWl0aXZlLW5wbS0xLjIuMS1iN2E3ZWFjNmM1LTRlYWQ2NjcxYTIuemlwL25vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvaGVscGVycy9pc1ByaW1pdGl2ZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvaXMtY2FsbGFibGUtbnBtLTEuMi40LTAzZmMxNzQ1OWMtMWEyOGQ1N2RjNC56aXAvbm9kZV9tb2R1bGVzL2lzLWNhbGxhYmxlL2luZGV4LmpzXG52YXIgcmVxdWlyZV9pc19jYWxsYWJsZSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2lzLWNhbGxhYmxlLW5wbS0xLjIuNC0wM2ZjMTc0NTljLTFhMjhkNTdkYzQuemlwL25vZGVfbW9kdWxlcy9pcy1jYWxsYWJsZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgICB2YXIgcmVmbGVjdEFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xuICAgIHZhciBiYWRBcnJheUxpa2U7XG4gICAgdmFyIGlzQ2FsbGFibGVNYXJrZXI7XG4gICAgaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcbiAgICAgICAgcmVmbGVjdEFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IDQyO1xuICAgICAgICB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBpZiAoXyAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuICAgICAgICAgIHJlZmxlY3RBcHBseSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmbGVjdEFwcGx5ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzc1xcYi87XG4gICAgdmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIHZhciBmbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICAgIHZhciBnZW5DbGFzcyA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIjtcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIGRvY3VtZW50RG90QWxsID0gdHlwZW9mIGRvY3VtZW50ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBkb2N1bWVudC5hbGwgPT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYWxsICE9PSB2b2lkIDAgPyBkb2N1bWVudC5hbGwgOiB7fTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZWZsZWN0QXBwbHkgPyBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IGRvY3VtZW50RG90QWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAhdmFsdWUucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpO1xuICAgIH0gOiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IGRvY3VtZW50RG90QWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAhdmFsdWUucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhhc1RvU3RyaW5nVGFnKSB7XG4gICAgICAgIHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgICAgIHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2hhcy10b3N0cmluZ3RhZy1ucG0tMS4wLjAtYjFmY2YzYWI1NS1jYzEyZWIyOGNiLnppcC9ub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzXG52YXIgcmVxdWlyZV9zaGFtczIgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9oYXMtdG9zdHJpbmd0YWctbnBtLTEuMC4wLWIxZmNmM2FiNTUtY2MxMmViMjhjYi56aXAvbm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaGFzU3ltYm9scyA9IHJlcXVpcmVfc2hhbXMoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuICAgICAgcmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvaXMtZGF0ZS1vYmplY3QtbnBtLTEuMC41LTg4ZjNkMDhiNWUtYmFhOTA3N2NkZi56aXAvbm9kZV9tb2R1bGVzL2lzLWRhdGUtb2JqZWN0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9pc19kYXRlX29iamVjdCA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2lzLWRhdGUtb2JqZWN0LW5wbS0xLjAuNS04OGYzZDA4YjVlLWJhYTkwNzdjZGYuemlwL25vZGVfbW9kdWxlcy9pcy1kYXRlLW9iamVjdC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZ2V0RGF5ID0gRGF0ZS5wcm90b3R5cGUuZ2V0RGF5O1xuICAgIHZhciB0cnlEYXRlT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RGF0ZUdldERheUNhbGwodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdldERheS5jYWxsKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgdmFyIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiO1xuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmVfc2hhbXMyKCkoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RhdGVPYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5RGF0ZU9iamVjdCh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gZGF0ZUNsYXNzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9pcy1zeW1ib2wtbnBtLTEuMC40LWViOWJhYWM3MDMtOTI4MDU4MTJlZi56aXAvbm9kZV9tb2R1bGVzL2lzLXN5bWJvbC9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfc3ltYm9sID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvaXMtc3ltYm9sLW5wbS0xLjAuNC1lYjliYWFjNzAzLTkyODA1ODEyZWYuemlwL25vZGVfbW9kdWxlcy9pcy1zeW1ib2wvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICB2YXIgaGFzU3ltYm9scyA9IHJlcXVpcmVfaGFzX3N5bWJvbHMoKSgpO1xuICAgIGlmIChoYXNTeW1ib2xzKSB7XG4gICAgICBzeW1Ub1N0ciA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICBzeW1TdHJpbmdSZWdleCA9IC9eU3ltYm9sXFwoLipcXCkkLztcbiAgICAgIGlzU3ltYm9sT2JqZWN0ID0gZnVuY3Rpb24gaXNSZWFsU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUudmFsdWVPZigpICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeW1TdHJpbmdSZWdleC50ZXN0KHN5bVRvU3RyLmNhbGwodmFsdWUpKTtcbiAgICAgIH07XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvU3RyLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgU3ltYm9sXVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN5bVRvU3RyO1xuICAgIHZhciBzeW1TdHJpbmdSZWdleDtcbiAgICB2YXIgaXNTeW1ib2xPYmplY3Q7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy10by1wcmltaXRpdmUtbnBtLTEuMi4xLWI3YTdlYWM2YzUtNGVhZDY2NzFhMi56aXAvbm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9lczIwMTUuanNcbnZhciByZXF1aXJlX2VzMjAxNSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLXRvLXByaW1pdGl2ZS1ucG0tMS4yLjEtYjdhN2VhYzZjNS00ZWFkNjY3MWEyLnppcC9ub2RlX21vZHVsZXMvZXMtdG8tcHJpbWl0aXZlL2VzMjAxNS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiO1xuICAgIHZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmVfaXNQcmltaXRpdmUzKCk7XG4gICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7XG4gICAgdmFyIGlzRGF0ZSA9IHJlcXVpcmVfaXNfZGF0ZV9vYmplY3QoKTtcbiAgICB2YXIgaXNTeW1ib2wgPSByZXF1aXJlX2lzX3N5bWJvbCgpO1xuICAgIHZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XG4gICAgICBpZiAodHlwZW9mIE8gPT09IFwidW5kZWZpbmVkXCIgfHwgTyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgbWV0aG9kIG9uIFwiICsgTyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhpbnQgIT09IFwic3RyaW5nXCIgfHwgaGludCAhPT0gXCJudW1iZXJcIiAmJiBoaW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hpbnQgbXVzdCBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCInKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZXRob2ROYW1lcyA9IGhpbnQgPT09IFwic3RyaW5nXCIgPyBbXCJ0b1N0cmluZ1wiLCBcInZhbHVlT2ZcIl0gOiBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIl07XG4gICAgICB2YXIgbWV0aG9kLCByZXN1bHQsIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbWV0aG9kID0gT1ttZXRob2ROYW1lc1tpXV07XG4gICAgICAgIGlmIChpc0NhbGxhYmxlKG1ldGhvZCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBtZXRob2QuY2FsbChPKTtcbiAgICAgICAgICBpZiAoaXNQcmltaXRpdmUocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBkZWZhdWx0IHZhbHVlXCIpO1xuICAgIH07XG4gICAgdmFyIEdldE1ldGhvZCA9IGZ1bmN0aW9uIEdldE1ldGhvZDIoTywgUCkge1xuICAgICAgdmFyIGZ1bmMgPSBPW1BdO1xuICAgICAgaWYgKGZ1bmMgIT09IG51bGwgJiYgdHlwZW9mIGZ1bmMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGZ1bmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW5jICsgXCIgcmV0dXJuZWQgZm9yIHByb3BlcnR5IFwiICsgUCArIFwiIG9mIG9iamVjdCBcIiArIE8gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCkge1xuICAgICAgaWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG4gICAgICB2YXIgaGludCA9IFwiZGVmYXVsdFwiO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0gPT09IFN0cmluZykge1xuICAgICAgICAgIGhpbnQgPSBcInN0cmluZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1sxXSA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgaGludCA9IFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleG90aWNUb1ByaW07XG4gICAgICBpZiAoaGFzU3ltYm9scykge1xuICAgICAgICBpZiAoU3ltYm9sLnRvUHJpbWl0aXZlKSB7XG4gICAgICAgICAgZXhvdGljVG9QcmltID0gR2V0TWV0aG9kKGlucHV0LCBTeW1ib2wudG9QcmltaXRpdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3ltYm9sKGlucHV0KSkge1xuICAgICAgICAgIGV4b3RpY1RvUHJpbSA9IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBleG90aWNUb1ByaW0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bmFibGUgdG8gY29udmVydCBleG90aWMgb2JqZWN0IHRvIHByaW1pdGl2ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChoaW50ID09PSBcImRlZmF1bHRcIiAmJiAoaXNEYXRlKGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpKSB7XG4gICAgICAgIGhpbnQgPSBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09IFwiZGVmYXVsdFwiID8gXCJudW1iZXJcIiA6IGhpbnQpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9QcmltaXRpdmUuanNcbnZhciByZXF1aXJlX1RvUHJpbWl0aXZlID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvUHJpbWl0aXZlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmVfZXMyMDE1KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gdG9QcmltaXRpdmUoaW5wdXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9QcmltaXRpdmUoaW5wdXQpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9OdW1iZXIuanNcbnZhciByZXF1aXJlX1RvTnVtYmVyID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvTnVtYmVyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlX2dldF9pbnRyaW5zaWMoKTtcbiAgICB2YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYyhcIiVUeXBlRXJyb3IlXCIpO1xuICAgIHZhciAkTnVtYmVyID0gR2V0SW50cmluc2ljKFwiJU51bWJlciVcIik7XG4gICAgdmFyICRSZWdFeHAgPSBHZXRJbnRyaW5zaWMoXCIlUmVnRXhwJVwiKTtcbiAgICB2YXIgJHBhcnNlSW50ZWdlciA9IEdldEludHJpbnNpYyhcIiVwYXJzZUludCVcIik7XG4gICAgdmFyIGNhbGxCb3VuZCA9IHJlcXVpcmVfY2FsbEJvdW5kKCk7XG4gICAgdmFyIHJlZ2V4VGVzdGVyID0gcmVxdWlyZV9yZWdleFRlc3RlcigpO1xuICAgIHZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmVfaXNQcmltaXRpdmUyKCk7XG4gICAgdmFyICRzdHJTbGljZSA9IGNhbGxCb3VuZChcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7XG4gICAgdmFyIGlzQmluYXJ5ID0gcmVnZXhUZXN0ZXIoL14wYlswMV0rJC9pKTtcbiAgICB2YXIgaXNPY3RhbCA9IHJlZ2V4VGVzdGVyKC9eMG9bMC03XSskL2kpO1xuICAgIHZhciBpc0ludmFsaWRIZXhMaXRlcmFsID0gcmVnZXhUZXN0ZXIoL15bLStdMHhbMC05YS1mXSskL2kpO1xuICAgIHZhciBub25XUyA9IFtcIlxceDg1XCIsIFwiXFx1MjAwQlwiLCBcIlxcdUZGRkVcIl0uam9pbihcIlwiKTtcbiAgICB2YXIgbm9uV1NyZWdleCA9IG5ldyAkUmVnRXhwKFwiW1wiICsgbm9uV1MgKyBcIl1cIiwgXCJnXCIpO1xuICAgIHZhciBoYXNOb25XUyA9IHJlZ2V4VGVzdGVyKG5vbldTcmVnZXgpO1xuICAgIHZhciB3cyA9IFtcbiAgICAgIFwiXHRcXG5cXHZcXGZcXHIgXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcIixcbiAgICAgIFwiXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcIixcbiAgICAgIFwiXFx1MjAyOVxcdUZFRkZcIlxuICAgIF0uam9pbihcIlwiKTtcbiAgICB2YXIgdHJpbVJlZ2V4ID0gbmV3IFJlZ0V4cChcIiheW1wiICsgd3MgKyBcIl0rKXwoW1wiICsgd3MgKyBcIl0rJClcIiwgXCJnXCIpO1xuICAgIHZhciAkcmVwbGFjZSA9IGNhbGxCb3VuZChcIlN0cmluZy5wcm90b3R5cGUucmVwbGFjZVwiKTtcbiAgICB2YXIgJHRyaW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICRyZXBsYWNlKHZhbHVlLCB0cmltUmVnZXgsIFwiXCIpO1xuICAgIH07XG4gICAgdmFyIFRvUHJpbWl0aXZlID0gcmVxdWlyZV9Ub1ByaW1pdGl2ZSgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvTnVtYmVyKGFyZ3VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBpc1ByaW1pdGl2ZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IFRvUHJpbWl0aXZlKGFyZ3VtZW50LCAkTnVtYmVyKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIG51bWJlclwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDb252ZXJzaW9uIGZyb20gJ0JpZ0ludCcgdG8gJ251bWJlcicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaXNCaW5hcnkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFRvTnVtYmVyKCRwYXJzZUludGVnZXIoJHN0clNsaWNlKHZhbHVlLCAyKSwgMikpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2N0YWwodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFRvTnVtYmVyKCRwYXJzZUludGVnZXIoJHN0clNsaWNlKHZhbHVlLCAyKSwgOCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyaW1tZWQgPSAkdHJpbSh2YWx1ZSk7XG4gICAgICAgIGlmICh0cmltbWVkICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBUb051bWJlcih0cmltbWVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICROdW1iZXIodmFsdWUpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNOYU4uanNcbnZhciByZXF1aXJlX2lzTmFOID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzTmFOLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBpc05hTjIoYSkge1xuICAgICAgcmV0dXJuIGEgIT09IGE7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLWFic3RyYWN0LW5wbS0xLjE5LjUtNTI0YTg3ZDI2Mi01NTE5OWIwZjE3LnppcC9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc0Zpbml0ZS5qc1xudmFyIHJlcXVpcmVfaXNGaW5pdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvaXNGaW5pdGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyICRpc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYSAhPT0gYTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgJiYgISRpc05hTih4KSAmJiB4ICE9PSBJbmZpbml0eSAmJiB4ICE9PSAtSW5maW5pdHk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLWFic3RyYWN0LW5wbS0xLjE5LjUtNTI0YTg3ZDI2Mi01NTE5OWIwZjE3LnppcC9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9zaWduLmpzXG52YXIgcmVxdWlyZV9zaWduID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL3NpZ24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gc2lnbihudW1iZXIpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gMCA/IDEgOiAtMTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvSW50ZWdlck9ySW5maW5pdHkuanNcbnZhciByZXF1aXJlX1RvSW50ZWdlck9ySW5maW5pdHkgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9JbnRlZ2VyT3JJbmZpbml0eS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYWJzID0gcmVxdWlyZV9hYnMoKTtcbiAgICB2YXIgZmxvb3IgPSByZXF1aXJlX2Zsb29yKCk7XG4gICAgdmFyIFRvTnVtYmVyID0gcmVxdWlyZV9Ub051bWJlcigpO1xuICAgIHZhciAkaXNOYU4gPSByZXF1aXJlX2lzTmFOKCk7XG4gICAgdmFyICRpc0Zpbml0ZSA9IHJlcXVpcmVfaXNGaW5pdGUoKTtcbiAgICB2YXIgJHNpZ24gPSByZXF1aXJlX3NpZ24oKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBUb0ludGVnZXJPckluZmluaXR5KHZhbHVlKSB7XG4gICAgICB2YXIgbnVtYmVyID0gVG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKCRpc05hTihudW1iZXIpIHx8IG51bWJlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmICghJGlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkc2lnbihudW1iZXIpICogZmxvb3IoYWJzKG51bWJlcikpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9MZW5ndGguanNcbnZhciByZXF1aXJlX1RvTGVuZ3RoID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvTGVuZ3RoLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZV9tYXhTYWZlSW50ZWdlcigpO1xuICAgIHZhciBUb0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZV9Ub0ludGVnZXJPckluZmluaXR5KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gVG9MZW5ndGgoYXJndW1lbnQpIHtcbiAgICAgIHZhciBsZW4gPSBUb0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KTtcbiAgICAgIGlmIChsZW4gPD0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZXMtYWJzdHJhY3QtbnBtLTEuMTkuNS01MjRhODdkMjYyLTU1MTk5YjBmMTcuemlwL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL0lzQ2FsbGFibGUuanNcbnZhciByZXF1aXJlX0lzQ2FsbGFibGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1hYnN0cmFjdC1ucG0tMS4xOS41LTUyNGE4N2QyNjItNTUxOTliMGYxNy56aXAvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSXNDYWxsYWJsZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9hcnJheS5wcm90b3R5cGUuZmluZC1ucG0tMi4yLjAtYjFjYTE0ZjA1ZC00M2MxOTE3N2NjLnppcC9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLmZpbmQvaW1wbGVtZW50YXRpb24uanNcbnZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uNSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2FycmF5LnByb3RvdHlwZS5maW5kLW5wbS0yLjIuMC1iMWNhMTRmMDVkLTQzYzE5MTc3Y2MuemlwL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUuZmluZC9pbXBsZW1lbnRhdGlvbi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgVG9PYmplY3QgPSByZXF1aXJlX1RvT2JqZWN0KCk7XG4gICAgdmFyIFRvTGVuZ3RoID0gcmVxdWlyZV9Ub0xlbmd0aCgpO1xuICAgIHZhciBJc0NhbGxhYmxlID0gcmVxdWlyZV9Jc0NhbGxhYmxlKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gZmluZChwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBsaXN0ID0gVG9PYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gVG9MZW5ndGgobGlzdC5sZW5ndGgpO1xuICAgICAgaWYgKCFJc0NhbGxhYmxlKHByZWRpY2F0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5I2ZpbmQ6IHByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICB2YXIgdGhpc0FyZztcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlLmFwcGx5KHRoaXNBcmcsIFt2YWx1ZSwgaSwgbGlzdF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9hcnJheS5wcm90b3R5cGUuZmluZC1ucG0tMi4yLjAtYjFjYTE0ZjA1ZC00M2MxOTE3N2NjLnppcC9ub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLmZpbmQvcG9seWZpbGwuanNcbnZhciByZXF1aXJlX3BvbHlmaWxsMyA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2FycmF5LnByb3RvdHlwZS5maW5kLW5wbS0yLjIuMC1iMWNhMTRmMDVkLTQzYzE5MTc3Y2MuemlwL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUuZmluZC9wb2x5ZmlsbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcbiAgICAgIHZhciBpbXBsZW1lbnRlZCA9IEFycmF5LnByb3RvdHlwZS5maW5kICYmIFssIDFdLmZpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkgIT09IDE7XG4gICAgICByZXR1cm4gaW1wbGVtZW50ZWQgPyBBcnJheS5wcm90b3R5cGUuZmluZCA6IHJlcXVpcmVfaW1wbGVtZW50YXRpb241KCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2VzLXNoaW0tdW5zY29wYWJsZXMtbnBtLTEuMC4wLTA2MTg2NTkzZjEtODNlOTVjYWRiYi56aXAvbm9kZV9tb2R1bGVzL2VzLXNoaW0tdW5zY29wYWJsZXMvaW5kZXguanNcbnZhciByZXF1aXJlX2VzX3NoaW1fdW5zY29wYWJsZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9lcy1zaGltLXVuc2NvcGFibGVzLW5wbS0xLjAuMC0wNjE4NjU5M2YxLTgzZTk1Y2FkYmIuemlwL25vZGVfbW9kdWxlcy9lcy1zaGltLXVuc2NvcGFibGVzL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBoYXMgPSByZXF1aXJlX3NyYygpO1xuICAgIHZhciBoYXNVbnNjb3BhYmxlcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLnVuc2NvcGFibGVzID09PSBcInN5bWJvbFwiO1xuICAgIHZhciBtYXAgPSBoYXNVbnNjb3BhYmxlcyAmJiBBcnJheS5wcm90b3R5cGVbU3ltYm9sLnVuc2NvcGFibGVzXTtcbiAgICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltVW5zY29wYWJsZXMobWV0aG9kKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCAhbWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwibWV0aG9kIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXMoQXJyYXkucHJvdG90eXBlLCBtZXRob2QpKSB7XG4gICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwibWV0aG9kIG11c3QgYmUgb24gQXJyYXkucHJvdG90eXBlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc1Vuc2NvcGFibGVzKSB7XG4gICAgICAgIG1hcFttZXRob2RdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvYXJyYXkucHJvdG90eXBlLmZpbmQtbnBtLTIuMi4wLWIxY2ExNGYwNWQtNDNjMTkxNzdjYy56aXAvbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5maW5kL3NoaW0uanNcbnZhciByZXF1aXJlX3NoaW0zID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvYXJyYXkucHJvdG90eXBlLmZpbmQtbnBtLTIuMi4wLWIxY2ExNGYwNWQtNDNjMTkxNzdjYy56aXAvbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5maW5kL3NoaW0uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnRpZXMoKTtcbiAgICB2YXIgc2hpbVVuc2NvcGFibGVzID0gcmVxdWlyZV9lc19zaGltX3Vuc2NvcGFibGVzKCk7XG4gICAgdmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZV9wb2x5ZmlsbDMoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltQXJyYXlQcm90b3R5cGVGaW5kKCkge1xuICAgICAgdmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcbiAgICAgIGRlZmluZShBcnJheS5wcm90b3R5cGUsIHsgZmluZDogcG9seWZpbGwgfSwge1xuICAgICAgICBmaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQgIT09IHBvbHlmaWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNoaW1VbnNjb3BhYmxlcyhcImZpbmRcIik7XG4gICAgICByZXR1cm4gcG9seWZpbGw7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2FycmF5LnByb3RvdHlwZS5maW5kLW5wbS0yLjIuMC1iMWNhMTRmMDVkLTQzYzE5MTc3Y2MuemlwL25vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUuZmluZC9pbmRleC5qc1xudmFyIHJlcXVpcmVfYXJyYXlfcHJvdG90eXBlID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvYXJyYXkucHJvdG90eXBlLmZpbmQtbnBtLTIuMi4wLWIxY2ExNGYwNWQtNDNjMTkxNzdjYy56aXAvbm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5maW5kL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzKCk7XG4gICAgdmFyIGNhbGxCb3VuZCA9IHJlcXVpcmVfY2FsbEJvdW5kKCk7XG4gICAgdmFyIFJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlX1JlcXVpcmVPYmplY3RDb2VyY2libGUoKTtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uNSgpO1xuICAgIHZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmVfcG9seWZpbGwzKCk7XG4gICAgdmFyIHNoaW0gPSByZXF1aXJlX3NoaW0zKCk7XG4gICAgdmFyICRzbGljZSA9IGNhbGxCb3VuZChcIkFycmF5LnByb3RvdHlwZS5zbGljZVwiKTtcbiAgICB2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuICAgIHZhciBib3VuZEZpbmRTaGltID0gZnVuY3Rpb24gZmluZChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFycmF5KTtcbiAgICAgIHZhciBhcmdzID0gJHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gcG9seWZpbGwuYXBwbHkoYXJyYXksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lKGJvdW5kRmluZFNoaW0sIHtcbiAgICAgIGdldFBvbHlmaWxsLFxuICAgICAgaW1wbGVtZW50YXRpb24sXG4gICAgICBzaGltXG4gICAgfSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gYm91bmRGaW5kU2hpbTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2Z1bmN0aW9ucy1oYXZlLW5hbWVzLW5wbS0xLjIuMy1lNWNmMWUyMjA4LWMzZjFmNWJhMjAuemlwL25vZGVfbW9kdWxlcy9mdW5jdGlvbnMtaGF2ZS1uYW1lcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfZnVuY3Rpb25zX2hhdmVfbmFtZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9mdW5jdGlvbnMtaGF2ZS1uYW1lcy1ucG0tMS4yLjMtZTVjZjFlMjIwOC1jM2YxZjViYTIwLnppcC9ub2RlX21vZHVsZXMvZnVuY3Rpb25zLWhhdmUtbmFtZXMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IGZ1bmN0aW9uIGZ1bmN0aW9uc0hhdmVOYW1lczIoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGZ1bmN0aW9uIGYoKSB7XG4gICAgICB9Lm5hbWUgPT09IFwic3RyaW5nXCI7XG4gICAgfTtcbiAgICB2YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgaWYgKGdPUEQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdPUEQoW10sIFwibGVuZ3RoXCIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBnT1BEID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb25zSGF2ZU5hbWVzLmZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcyA9IGZ1bmN0aW9uIGZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcygpIHtcbiAgICAgIGlmICghZnVuY3Rpb25zSGF2ZU5hbWVzKCkgfHwgIWdPUEQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGRlc2MgPSBnT1BEKGZ1bmN0aW9uKCkge1xuICAgICAgfSwgXCJuYW1lXCIpO1xuICAgICAgcmV0dXJuICEhZGVzYyAmJiAhIWRlc2MuY29uZmlndXJhYmxlO1xuICAgIH07XG4gICAgdmFyICRiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG4gICAgZnVuY3Rpb25zSGF2ZU5hbWVzLmJvdW5kRnVuY3Rpb25zSGF2ZU5hbWVzID0gZnVuY3Rpb24gYm91bmRGdW5jdGlvbnNIYXZlTmFtZXMoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25zSGF2ZU5hbWVzKCkgJiYgdHlwZW9mICRiaW5kID09PSBcImZ1bmN0aW9uXCIgJiYgZnVuY3Rpb24gZigpIHtcbiAgICAgIH0uYmluZCgpLm5hbWUgIT09IFwiXCI7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbnNIYXZlTmFtZXM7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS1ucG0tMS4xLjUtZTc3NmE2NDJiYi1hY2QyMWQ3MzNhLnppcC9ub2RlX21vZHVsZXMvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvaW1wbGVtZW50YXRpb24uanNcbnZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uNiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lLW5wbS0xLjEuNS1lNzc2YTY0MmJiLWFjZDIxZDczM2EuemlwL25vZGVfbW9kdWxlcy9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9pbXBsZW1lbnRhdGlvbi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgSXNDYWxsYWJsZSA9IHJlcXVpcmVfSXNDYWxsYWJsZSgpO1xuICAgIHZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSByZXF1aXJlX2Z1bmN0aW9uc19oYXZlX25hbWVzKCkoKTtcbiAgICB2YXIgY2FsbEJvdW5kID0gcmVxdWlyZV9jYWxsQm91bmQoKTtcbiAgICB2YXIgJGZ1bmN0aW9uVG9TdHJpbmcgPSBjYWxsQm91bmQoXCJGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmdcIik7XG4gICAgdmFyICRzdHJpbmdNYXRjaCA9IGNhbGxCb3VuZChcIlN0cmluZy5wcm90b3R5cGUubWF0Y2hcIik7XG4gICAgdmFyIGNsYXNzUmVnZXggPSAvXmNsYXNzIC87XG4gICAgdmFyIGlzQ2xhc3MgPSBmdW5jdGlvbiBpc0NsYXNzQ29uc3RydWN0b3IoZm4pIHtcbiAgICAgIGlmIChJc0NhbGxhYmxlKGZuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG1hdGNoID0gJHN0cmluZ01hdGNoKCRmdW5jdGlvblRvU3RyaW5nKGZuKSwgY2xhc3NSZWdleCk7XG4gICAgICAgIHJldHVybiAhIW1hdGNoO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW14oXFxzXSopXFxzKi87XG4gICAgdmFyIGZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICAgIGlmICghaXNDbGFzcyh0aGlzKSAmJiAhSXNDYWxsYWJsZSh0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgc2hhbSBnZXR0ZXIgY2FsbGVkIG9uIG5vbi1mdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzID09PSBmdW5jdGlvblByb3RvKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIHN0ciA9ICRmdW5jdGlvblRvU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIG1hdGNoID0gJHN0cmluZ01hdGNoKHN0ciwgcmVnZXgpO1xuICAgICAgdmFyIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS1ucG0tMS4xLjUtZTc3NmE2NDJiYi1hY2QyMWQ3MzNhLnppcC9ub2RlX21vZHVsZXMvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvcG9seWZpbGwuanNcbnZhciByZXF1aXJlX3BvbHlmaWxsNCA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lLW5wbS0xLjEuNS1lNzc2YTY0MmJiLWFjZDIxZDczM2EuemlwL25vZGVfbW9kdWxlcy9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9wb2x5ZmlsbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uNigpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS1ucG0tMS4xLjUtZTc3NmE2NDJiYi1hY2QyMWQ3MzNhLnppcC9ub2RlX21vZHVsZXMvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvc2hpbS5qc1xudmFyIHJlcXVpcmVfc2hpbTQgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS1ucG0tMS4xLjUtZTc3NmE2NDJiYi1hY2QyMWQ3MzNhLnppcC9ub2RlX21vZHVsZXMvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvc2hpbS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnRpZXMoKS5zdXBwb3J0c0Rlc2NyaXB0b3JzO1xuICAgIHZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSByZXF1aXJlX2Z1bmN0aW9uc19oYXZlX25hbWVzKCkoKTtcbiAgICB2YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlX3BvbHlmaWxsNCgpO1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgVHlwZUVyciA9IFR5cGVFcnJvcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTmFtZSgpIHtcbiAgICAgIHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG4gICAgICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgICAgIHJldHVybiBwb2x5ZmlsbDtcbiAgICAgIH1cbiAgICAgIGlmICghc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycihcIlNoaW1taW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lIHN1cHBvcnQgcmVxdWlyZXMgRVM1IHByb3BlcnR5IGRlc2NyaXB0b3Igc3VwcG9ydC5cIik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICAgIGRlZmluZVByb3BlcnR5KGZ1bmN0aW9uUHJvdG8sIFwibmFtZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwb2x5ZmlsbC5jYWxsKHRoaXMpO1xuICAgICAgICAgIGlmICh0aGlzICE9PSBmdW5jdGlvblByb3RvKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvbHlmaWxsO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS1ucG0tMS4xLjUtZTc3NmE2NDJiYi1hY2QyMWQ3MzNhLnppcC9ub2RlX21vZHVsZXMvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvaW5kZXguanNcbnZhciByZXF1aXJlX2Z1bmN0aW9uX3Byb3RvdHlwZSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lLW5wbS0xLjEuNS1lNzc2YTY0MmJiLWFjZDIxZDczM2EuemlwL25vZGVfbW9kdWxlcy9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydGllcygpO1xuICAgIHZhciBjYWxsQmluZCA9IHJlcXVpcmVfY2FsbF9iaW5kKCk7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjYoKTtcbiAgICB2YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlX3BvbHlmaWxsNCgpO1xuICAgIHZhciBzaGltID0gcmVxdWlyZV9zaGltNCgpO1xuICAgIHZhciBib3VuZCA9IGNhbGxCaW5kKGltcGxlbWVudGF0aW9uKTtcbiAgICBkZWZpbmUoYm91bmQsIHtcbiAgICAgIGdldFBvbHlmaWxsLFxuICAgICAgaW1wbGVtZW50YXRpb24sXG4gICAgICBzaGltXG4gICAgfSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gYm91bmQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2hlbHBlcnMvZ2V0Q29tcG9uZW50TmFtZS5qc1xudmFyIHJlcXVpcmVfZ2V0Q29tcG9uZW50TmFtZSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvaGVscGVycy9nZXRDb21wb25lbnROYW1lLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGdldENvbXBvbmVudE5hbWU7XG4gICAgdmFyIF9mdW5jdGlvblByb3RvdHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9mdW5jdGlvbl9wcm90b3R5cGUoKSk7XG4gICAgdmFyIF9yZWFjdElzID0gcmVxdWlyZV9yZWFjdF9pcygpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB7XG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8ICgwLCBfZnVuY3Rpb25Qcm90b3R5cGVbXCJkZWZhdWx0XCJdKShDb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCgwLCBfcmVhY3RJcy5pc0ZvcndhcmRSZWYpKHtcbiAgICAgICAgdHlwZTogQ29tcG9uZW50LFxuICAgICAgICAkJHR5cGVvZjogX3JlYWN0SXMuRWxlbWVudFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudC5kaXNwbGF5TmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICgoMCwgX3JlYWN0SXMuaXNNZW1vKShDb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvY2hpbGRyZW5PZlR5cGUuanNcbnZhciByZXF1aXJlX2NoaWxkcmVuT2ZUeXBlID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9jaGlsZHJlbk9mVHlwZS5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gICAgdmFyIF9hcnJheVByb3RvdHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hcnJheV9wcm90b3R5cGUoKSk7XG4gICAgdmFyIF9nZXRDb21wb25lbnROYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2dldENvbXBvbmVudE5hbWUoKSk7XG4gICAgdmFyIF9yZW5kZXJhYmxlQ2hpbGRyZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVuZGVyYWJsZUNoaWxkcmVuKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9ubHlUeXBlcyh0eXBlcywgY2hpbGRyZW4sIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkICYmICgwLCBfYXJyYXlQcm90b3R5cGVbXCJkZWZhdWx0XCJdKSh0eXBlcywgZnVuY3Rpb24oVHlwZSkge1xuICAgICAgICAgIHJldHVybiBUeXBlID09PSBcIipcIiB8fCBjaGlsZC50eXBlID09PSBUeXBlO1xuICAgICAgICB9KTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciB0eXBlTmFtZXMgPSB0eXBlcy5tYXAoX2dldENvbXBvbmVudE5hbWVbXCJkZWZhdWx0XCJdKS5qb2luKFwiLCBvciBcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiYFwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcImAgb25seSBhY2NlcHRzIGNoaWxkcmVuIG9mIHR5cGUgXCIpLmNvbmNhdCh0eXBlTmFtZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlcXVpcmVkKHR5cGVzLCBjaGlsZHJlbiwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgdHlwZU5hbWVzID0gdHlwZXMubWFwKF9nZXRDb21wb25lbnROYW1lW1wiZGVmYXVsdFwiXSkuam9pbihcIiwgb3IgXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCJgIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBub2RlIG9mIHR5cGUgXCIpLmNvbmNhdCh0eXBlTmFtZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGlsZHJlbk9mVHlwZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgdHlwZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2hpbGRyZW5PZlR5cGU6IGF0IGxlYXN0IDEgdHlwZSBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRvcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG9ubHlUeXBlcyh0eXBlcywgKDAsIF9yZW5kZXJhYmxlQ2hpbGRyZW5bXCJkZWZhdWx0XCJdKShwcm9wc1twcm9wTmFtZV0pLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRvci5pc1JlcXVpcmVkID0gZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9ICgwLCBfcmVuZGVyYWJsZUNoaWxkcmVuW1wiZGVmYXVsdFwiXSkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIGlzUmVxdWlyZWQodHlwZXMsIGNoaWxkcmVuLCBjb21wb25lbnROYW1lKSB8fCBvbmx5VHlwZXModHlwZXMsIGNoaWxkcmVuLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBcImNoaWxkcmVuT2ZUeXBlXCIsIHR5cGVzKTtcbiAgICB9XG4gICAgdmFyIF9kZWZhdWx0ID0gY2hpbGRyZW5PZlR5cGU7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvaGVscGVycy9pc0ludGVnZXIuanNcbnZhciByZXF1aXJlX2lzSW50ZWdlciA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvaGVscGVycy9pc0ludGVnZXIuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIGZpbml0ZSA9IGlzRmluaXRlO1xuICAgIHZhciBfZGVmYXVsdCA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm51bWJlclwiICYmIGZpbml0ZSh4KSAmJiBmbG9vcih4KSA9PT0geDtcbiAgICB9O1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2ludGVnZXIuanNcbnZhciByZXF1aXJlX2ludGVnZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2ludGVnZXIuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICAgIHZhciBfaXNJbnRlZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2lzSW50ZWdlcigpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZEludGVnZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsIHx8ICEoMCwgX2lzSW50ZWdlcltcImRlZmF1bHRcIl0pKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KHByb3BOYW1lLCBcIiBpbiBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIG11c3QgYmUgYW4gaW50ZWdlclwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIGludGVnZXIocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZXN0W19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1aXJlZEludGVnZXIuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lXS5jb25jYXQocmVzdCkpO1xuICAgIH07XG4gICAgdmFsaWRhdG9yLmlzUmVxdWlyZWQgPSByZXF1aXJlZEludGVnZXI7XG4gICAgdmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQyKCkge1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgXCJpbnRlZ2VyXCIpO1xuICAgIH07XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC1pcy1ucG0tMS4xLjUtNDhhODYyNjAyYi05ODliMThjNGNiLnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzXG52YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjcgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QtaXMtbnBtLTEuMS41LTQ4YTg2MjYwMmItOTg5YjE4YzRjYi56aXAvbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDEgLyBhID09PSAxIC8gYjtcbiAgICAgIH1cbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QtaXMtbnBtLTEuMS41LTQ4YTg2MjYwMmItOTg5YjE4YzRjYi56aXAvbm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qc1xudmFyIHJlcXVpcmVfcG9seWZpbGw1ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LWlzLW5wbS0xLjEuNS00OGE4NjI2MDJiLTk4OWIxOGM0Y2IuemlwL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjcoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LWlzLW5wbS0xLjEuNS00OGE4NjI2MDJiLTk4OWIxOGM0Y2IuemlwL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qc1xudmFyIHJlcXVpcmVfc2hpbTUgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QtaXMtbnBtLTEuMS41LTQ4YTg2MjYwMmItOTg5YjE4YzRjYi56aXAvbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmVfcG9seWZpbGw1KCk7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnRpZXMoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG4gICAgICB2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuICAgICAgZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuICAgICAgICBpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb2x5ZmlsbDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LWlzLW5wbS0xLjEuNS00OGE4NjI2MDJiLTk4OWIxOGM0Y2IuemlwL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW5kZXguanNcbnZhciByZXF1aXJlX29iamVjdF9pcyA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC1pcy1ucG0tMS4xLjUtNDhhODYyNjAyYi05ODliMThjNGNiLnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzKCk7XG4gICAgdmFyIGNhbGxCaW5kID0gcmVxdWlyZV9jYWxsX2JpbmQoKTtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uNygpO1xuICAgIHZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmVfcG9seWZpbGw1KCk7XG4gICAgdmFyIHNoaW0gPSByZXF1aXJlX3NoaW01KCk7XG4gICAgdmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcbiAgICBkZWZpbmUocG9seWZpbGwsIHtcbiAgICAgIGdldFBvbHlmaWxsLFxuICAgICAgaW1wbGVtZW50YXRpb24sXG4gICAgICBzaGltXG4gICAgfSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcG9seWZpbGw7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL25vbk5lZ2F0aXZlTnVtYmVyLmpzXG52YXIgcmVxdWlyZV9ub25OZWdhdGl2ZU51bWJlciA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvbm9uTmVnYXRpdmVOdW1iZXIuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICAgIHZhciBfb2JqZWN0SXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfb2JqZWN0X2lzKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTm9uTmVnYXRpdmUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHgpICYmIHggPj0gMCAmJiAhKDAsIF9vYmplY3RJc1tcImRlZmF1bHRcIl0pKHgsIC0wKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9uTmVnYXRpdmVOdW1iZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc05vbk5lZ2F0aXZlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2VFcnJvcihcIlwiLmNvbmNhdChwcm9wTmFtZSwgXCIgaW4gXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcIiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclwiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVpcmVkTm9uTmVnYXRpdmVOdW1iZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoaXNOb25OZWdhdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IoXCJcIi5jb25jYXQocHJvcE5hbWUsIFwiIGluIFwiKS5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXJcIikpO1xuICAgIH1cbiAgICBub25OZWdhdGl2ZU51bWJlci5pc1JlcXVpcmVkID0gcmVxdWlyZWROb25OZWdhdGl2ZU51bWJlcjtcbiAgICB2YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdDIoKSB7XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkobm9uTmVnYXRpdmVOdW1iZXIsIFwibm9uTmVnYXRpdmVOdW1iZXJcIik7XG4gICAgfTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9ub25OZWdhdGl2ZUludGVnZXIuanNcbnZhciByZXF1aXJlX25vbk5lZ2F0aXZlSW50ZWdlciA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvbm9uTmVnYXRpdmVJbnRlZ2VyLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgICB2YXIgX2FuZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hbmQoKSk7XG4gICAgdmFyIF9pbnRlZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2ludGVnZXIoKSk7XG4gICAgdmFyIF9ub25OZWdhdGl2ZU51bWJlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9ub25OZWdhdGl2ZU51bWJlcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICB2YXIgX2RlZmF1bHQgPSAoMCwgX2FuZFtcImRlZmF1bHRcIl0pKFsoMCwgX2ludGVnZXJbXCJkZWZhdWx0XCJdKSgpLCAoMCwgX25vbk5lZ2F0aXZlTnVtYmVyW1wiZGVmYXVsdFwiXSkoKV0sIFwibm9uTmVnYXRpdmVJbnRlZ2VyXCIpO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2hlbHBlcnMvdHlwZU9mLmpzXG52YXIgcmVxdWlyZV90eXBlT2YgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2hlbHBlcnMvdHlwZU9mLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHR5cGVPZjtcbiAgICB2YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iajIpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajI7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqMikge1xuICAgICAgICAgIHJldHVybiBvYmoyICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmoyLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqMiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqMjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGVPZihjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgfVxuICAgICAgaWYgKF90eXBlb2YoY2hpbGQpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBfdHlwZW9mKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICgvKiBAX19QVVJFX18gKi8gX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLnR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9vYmplY3QuanNcbnZhciByZXF1aXJlX29iamVjdDMgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL29iamVjdC5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gICAgdmFyIF9pc1BsYWluT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2lzUGxhaW5PYmplY3QyKCkpO1xuICAgIHZhciBfdHlwZU9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3R5cGVPZigpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICB2YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgICBwcm9wOiBcInByb3BcIixcbiAgICAgIGNvbnRleHQ6IFwiY29udGV4dFwiLFxuICAgICAgY2hpbGRDb250ZXh0OiBcImNoaWxkIGNvbnRleHRcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gb2JqZWN0KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICgoMCwgX2lzUGxhaW5PYmplY3RbXCJkZWZhdWx0XCJdKShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSB8fCBsb2NhdGlvbjtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBcIi5jb25jYXQobG9jYXRpb25OYW1lLCBcIiBgXCIpLmNvbmNhdChwcm9wRnVsbE5hbWUsIFwiYCBvZiB0eXBlIGBcIikuY29uY2F0KCgwLCBfdHlwZU9mW1wiZGVmYXVsdFwiXSkocHJvcFZhbHVlKSwgXCJgIHN1cHBsaWVkIHRvIGBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiYCwgZXhwZWN0ZWQgYG9iamVjdGAuXCIpKTtcbiAgICB9XG4gICAgb2JqZWN0LmlzUmVxdWlyZWQgPSBmdW5jdGlvbiBvYmplY3RSZXF1aXJlZChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSB8fCBsb2NhdGlvbjtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJUaGUgXCIuY29uY2F0KGxvY2F0aW9uTmFtZSwgXCIgYFwiKS5jb25jYXQocHJvcEZ1bGxOYW1lLCBcImAgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluIGBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgXCIpLmNvbmNhdChwcm9wVmFsdWUsIFwiYC5cIikpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDUgPyBfbGVuIC0gNSA6IDApLCBfa2V5ID0gNTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZXN0W19rZXkgLSA1XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3QuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lXS5jb25jYXQocmVzdCkpO1xuICAgIH07XG4gICAgdmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQyKCkge1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKG9iamVjdCwgXCJvYmplY3RcIik7XG4gICAgfTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC93aXRoU2hhcGUuanNcbnZhciByZXF1aXJlX3dpdGhTaGFwZSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvd2l0aFNoYXBlLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdpdGhTaGFwZTtcbiAgICB2YXIgX2FuZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hbmQoKSk7XG4gICAgdmFyIF9zaGFwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zaGFwZSgpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aXRoU2hhcGUodHlwZSwgc2hhcGVUeXBlcykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInR5cGUgbXVzdCBiZSBhIHZhbGlkIFByb3BUeXBlXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHNoYXBlVmFsaWRhdG9yID0gKDAsIF9zaGFwZVtcImRlZmF1bHRcIl0pKHNoYXBlVHlwZXMpO1xuICAgICAgcmV0dXJuICgwLCBfYW5kW1wiZGVmYXVsdFwiXSkoW3R5cGUsIHNoYXBlVmFsaWRhdG9yXSwgXCJ3aXRoU2hhcGVcIik7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9zZXF1ZW5jZU9mLmpzXG52YXIgcmVxdWlyZV9zZXF1ZW5jZU9mID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9zZXF1ZW5jZU9mLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNlcXVlbmNlT2ZWYWxpZGF0b3I7XG4gICAgdmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlX3Byb3BfdHlwZXMoKTtcbiAgICB2YXIgX2FuZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hbmQoKSk7XG4gICAgdmFyIF9iZXR3ZWVuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2JldHdlZW4oKSk7XG4gICAgdmFyIF9ub25OZWdhdGl2ZUludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfbm9uTmVnYXRpdmVJbnRlZ2VyKCkpO1xuICAgIHZhciBfb2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX29iamVjdDMoKSk7XG4gICAgdmFyIF93aXRoU2hhcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd2l0aFNoYXBlKCkpO1xuICAgIHZhciBfdHlwZU9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3R5cGVPZigpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIGlmIChpICUgMikge1xuICAgICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIG1pblZhbGlkYXRvciA9IF9ub25OZWdhdGl2ZUludGVnZXJbXCJkZWZhdWx0XCJdO1xuICAgIHZhciBtYXhWYWxpZGF0b3IgPSAoMCwgX2FuZFtcImRlZmF1bHRcIl0pKFtfbm9uTmVnYXRpdmVJbnRlZ2VyW1wiZGVmYXVsdFwiXSwgKDAsIF9iZXR3ZWVuW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgZ3RlOiAxXG4gICAgfSldKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKG1pbiwgbWF4KSB7XG4gICAgICBpZiAodHlwZW9mIG1heCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbWluICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1pbiA8PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IoXCJtaW4gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4XCIpO1xuICAgIH1cbiAgICB2YXIgc3BlY2lmaWVyU2hhcGUgPSB7XG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcihwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdcInZhbGlkYXRvclwiIG11c3QgYmUgYSBwcm9wVHlwZSB2YWxpZGF0b3IgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBtaW46IGZ1bmN0aW9uIG1pbihwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1pblZhbGlkYXRvcihwcm9wcywgcHJvcE5hbWUpIHx8IHZhbGlkYXRlUmFuZ2UocHJvcHMubWluLCBwcm9wcy5tYXgpO1xuICAgICAgfSxcbiAgICAgIG1heDogZnVuY3Rpb24gbWF4KHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gbWF4VmFsaWRhdG9yKHByb3BzLCBwcm9wTmFtZSkgfHwgdmFsaWRhdGVSYW5nZShwcm9wcy5taW4sIHByb3BzLm1heCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRNaW5NYXgoX3JlZikge1xuICAgICAgdmFyIG1pbiA9IF9yZWYubWluLCBtYXggPSBfcmVmLm1heDtcbiAgICAgIHZhciBtaW5pbXVtO1xuICAgICAgdmFyIG1heGltdW07XG4gICAgICBpZiAodHlwZW9mIG1pbiAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWF4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG1pbmltdW0gPSAxO1xuICAgICAgICBtYXhpbXVtID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbmltdW0gPSB0eXBlb2YgbWluID09PSBcIm51bWJlclwiID8gbWluIDogMTtcbiAgICAgICAgbWF4aW11bSA9IHR5cGVvZiBtYXggPT09IFwibnVtYmVyXCIgPyBtYXggOiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbmltdW0sXG4gICAgICAgIG1heGltdW1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNodW5rQnlUeXBlKGl0ZW1zKSB7XG4gICAgICB2YXIgY2h1bmsgPSBbXTtcbiAgICAgIHZhciBsYXN0VHlwZTtcbiAgICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoZnVuY3Rpb24oY2h1bmtzLCBpdGVtKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZSA9ICgwLCBfdHlwZU9mW1wiZGVmYXVsdFwiXSkoaXRlbSk7XG4gICAgICAgIGlmICghbGFzdFR5cGUgfHwgaXRlbVR5cGUgPT09IGxhc3RUeXBlKSB7XG4gICAgICAgICAgY2h1bmsucHVzaChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgY2h1bmsgPSBbaXRlbV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFR5cGUgPSBpdGVtVHlwZTtcbiAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgIH0sIFtdKS5jb25jYXQoY2h1bmsubGVuZ3RoID4gMCA/IFtjaHVua10gOiBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2h1bmtzKHNwZWNpZmllcnMsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgdmFyIGl0ZW1zID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIGNodW5rcyA9IGNodW5rQnlUeXBlKGl0ZW1zKTtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiA0ID8gX2xlbiAtIDQgOiAwKSwgX2tleSA9IDQ7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVzdFtfa2V5IC0gNF0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmllcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIF9zcGVjaWZpZXJzJGkgPSBzcGVjaWZpZXJzW2ldLCB2YWxpZGF0b3IgPSBfc3BlY2lmaWVycyRpLnZhbGlkYXRvciwgbWluID0gX3NwZWNpZmllcnMkaS5taW4sIG1heCA9IF9zcGVjaWZpZXJzJGkubWF4O1xuICAgICAgICB2YXIgX2dldE1pbk1heCA9IGdldE1pbk1heCh7XG4gICAgICAgICAgbWluLFxuICAgICAgICAgIG1heFxuICAgICAgICB9KSwgbWluaW11bSA9IF9nZXRNaW5NYXgubWluaW11bSwgbWF4aW11bSA9IF9nZXRNaW5NYXgubWF4aW11bTtcbiAgICAgICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDAgJiYgbWluaW11bSA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcnJheU9mVmFsaWRhdG9yID0gKDAsIF9wcm9wVHlwZXMuYXJyYXlPZikodmFsaWRhdG9yKS5pc1JlcXVpcmVkO1xuICAgICAgICB2YXIgY2h1bmsgPSBjaHVua3Muc2hpZnQoKTtcbiAgICAgICAgdmFyIGNodW5rRXJyb3IgPSBhcnJheU9mVmFsaWRhdG9yLmFwcGx5KHZvaWQgMCwgW19vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBwcm9wTmFtZSwgY2h1bmspKSwgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIGlmIChjaHVua0Vycm9yKSB7XG4gICAgICAgICAgaWYgKG1pbmltdW0gPT09IDApIHtcbiAgICAgICAgICAgIGNodW5rcy51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2h1bmtFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsubGVuZ3RoIDwgbWluaW11bSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogc3BlY2lmaWVyIGluZGV4IFwiKS5jb25jYXQoaSwgXCIgcmVxdWlyZXMgYSBtaW5pbXVtIG9mIFwiKS5jb25jYXQobWluLCBcIiBpdGVtcywgYnV0IG9ubHkgaGFzIFwiKS5jb25jYXQoY2h1bmsubGVuZ3RoLCBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBtYXhpbXVtKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBzcGVjaWZpZXIgaW5kZXggXCIpLmNvbmNhdChpLCBcIiByZXF1aXJlcyBhIG1heGltdW0gb2YgXCIpLmNvbmNhdChtYXgsIFwiIGl0ZW1zLCBidXQgaGFzIFwiKS5jb25jYXQoY2h1bmsubGVuZ3RoLCBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCI6IGFmdGVyIGFsbCBcIikuY29uY2F0KHNwZWNpZmllcnMubGVuZ3RoLCBcIiBzcGVjaWZpZXJzIG1hdGNoZWQsIFwiKS5jb25jYXQoY2h1bmtzLmxlbmd0aCwgXCIgdHlwZXMgb2YgaXRlbXMgd2VyZSByZW1haW5pbmcuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3BlY2lmaWVyVmFsaWRhdG9yID0gKDAsIF93aXRoU2hhcGVbXCJkZWZhdWx0XCJdKSgoMCwgX29iamVjdFtcImRlZmF1bHRcIl0pKCksIHNwZWNpZmllclNoYXBlKS5pc1JlcXVpcmVkO1xuICAgIGZ1bmN0aW9uIHNlcXVlbmNlT2ZWYWxpZGF0b3IoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNwZWNpZmllcnMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgc3BlY2lmaWVyc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic2VxdWVuY2VPZjogYXQgbGVhc3Qgb25lIHNwZWNpZmllciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvcnMgPSBzcGVjaWZpZXJzLm1hcChmdW5jdGlvbihzcGVjaWZpZXIsIGkpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllclZhbGlkYXRvcih7XG4gICAgICAgICAgc3BlY2lmaWVyXG4gICAgICAgIH0sIFwic3BlY2lmaWVyXCIsIFwic2VxdWVuY2VPZiBzcGVjaWZpZXJcIiwgXCJzdWVxdWVuY2VPZiBzcGVjaWZpZXIsIGluZGV4IFwiLmNvbmNhdChpKSwgXCJzcGVjaWZpZXIsIGluZGV4IFwiLmNvbmNhdChpKSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnJvcnMuc29tZShCb29sZWFuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxuICAgICAgc2VxdWVuY2VPZjogYWxsIHNwZWNpZmllcnMgbXVzdCBtYXRjaCB0aGUgYXBwcm9wcmlhdGUgc2hhcGUuXFxuXFxuICAgICAgRXJyb3JzOlxcbiAgICAgICAgXCIuY29uY2F0KGVycm9ycy5tYXAoZnVuY3Rpb24oZSwgaSkge1xuICAgICAgICAgIHJldHVybiBcIiAtIEFyZ3VtZW50IGluZGV4IFwiLmNvbmNhdChpLCBcIjogXCIpLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICB9KS5qb2luKFwiLFxcbiAgICAgICAgXCIpLCBcIlxcbiAgICBcIikpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIHNlcXVlbmNlT2YocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMyA+IDIgPyBfbGVuMyAtIDIgOiAwKSwgX2tleTMgPSAyOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MyAtIDJdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBfcHJvcFR5cGVzLmFycmF5LmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUNodW5rcy5hcHBseSh2b2lkIDAsIFtzcGVjaWZpZXJzLCBwcm9wcywgcHJvcE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9O1xuICAgICAgdmFsaWRhdG9yLmlzUmVxdWlyZWQgPSBmdW5jdGlvbiBzZXF1ZW5jZU9mUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuNCA+IDMgPyBfbGVuNCAtIDMgOiAwKSwgX2tleTQgPSAzOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5NCAtIDNdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBfcHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQuYXBwbHkoX3Byb3BUeXBlcy5hcnJheSwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUNodW5rcy5hcHBseSh2b2lkIDAsIFtzcGVjaWZpZXJzLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgXCJzZXF1ZW5jZU9mXCIsIHNwZWNpZmllcnMpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvY2hpbGRyZW5TZXF1ZW5jZU9mLmpzXG52YXIgcmVxdWlyZV9jaGlsZHJlblNlcXVlbmNlT2YgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2NoaWxkcmVuU2VxdWVuY2VPZi5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjaGlsZHJlblNlcXVlbmNlT2ZWYWxpZGF0b3I7XG4gICAgdmFyIF9zZXF1ZW5jZU9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3NlcXVlbmNlT2YoKSk7XG4gICAgdmFyIF9yZW5kZXJhYmxlQ2hpbGRyZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVuZGVyYWJsZUNoaWxkcmVuKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICAgIGlmIChlbnVtZXJhYmxlT25seSlcbiAgICAgICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGlsZHJlblNlcXVlbmNlT2ZWYWxpZGF0b3IoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3BlY2lmaWVycyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc3BlY2lmaWVyc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXEgPSBfc2VxdWVuY2VPZltcImRlZmF1bHRcIl0uYXBwbHkodm9pZCAwLCBzcGVjaWZpZXJzKTtcbiAgICAgIHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbiBjaGlsZHJlblNlcXVlbmNlT2YocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gXCJjaGlsZHJlblwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgJyBpcyB1c2luZyB0aGUgY2hpbGRyZW5TZXF1ZW5jZU9mIHZhbGlkYXRvciBvbiBub24tY2hpbGRyZW4gcHJvcCBcIicpLmNvbmNhdChwcm9wTmFtZSwgJ1wiJykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIHZhciBjaGlsZHJlbiA9ICgwLCBfcmVuZGVyYWJsZUNoaWxkcmVuW1wiZGVmYXVsdFwiXSkocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VxLmFwcGx5KHZvaWQgMCwgW19vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIH0pLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoaWxkcmVuU2VxdWVuY2VPZlJlcXVpcmVkKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09IFwiY2hpbGRyZW5cIikge1xuICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsICcgaXMgdXNpbmcgdGhlIGNoaWxkcmVuU2VxdWVuY2VPZiB2YWxpZGF0b3Igb24gbm9uLWNoaWxkcmVuIHByb3AgXCInKS5jb25jYXQocHJvcE5hbWUsICdcIicpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSAoMCwgX3JlbmRlcmFibGVDaGlsZHJlbltcImRlZmF1bHRcIl0pKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogcmVuZGVyYWJsZSBjaGlsZHJlbiBhcmUgcmVxdWlyZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjMgPiAzID8gX2xlbjMgLSAzIDogMCksIF9rZXkzID0gMzsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIHJlc3RbX2tleTMgLSAzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcS5pc1JlcXVpcmVkLmFwcGx5KHNlcSwgW19vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIH0pLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBcImNoaWxkcmVuU2VxdWVuY2VPZlwiLCBzcGVjaWZpZXJzKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9pcy1yZWdleC1ucG0tMS4xLjQtY2NhMTkzZWYxMS0zNjIzOTliMzM1LnppcC9ub2RlX21vZHVsZXMvaXMtcmVnZXgvaW5kZXguanNcbnZhciByZXF1aXJlX2lzX3JlZ2V4ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvaXMtcmVnZXgtbnBtLTEuMS40LWNjYTE5M2VmMTEtMzYyMzk5YjMzNS56aXAvbm9kZV9tb2R1bGVzL2lzLXJlZ2V4L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjYWxsQm91bmQgPSByZXF1aXJlX2NhbGxCb3VuZCgpO1xuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmVfc2hhbXMyKCkoKTtcbiAgICB2YXIgaGFzO1xuICAgIHZhciAkZXhlYztcbiAgICB2YXIgaXNSZWdleE1hcmtlcjtcbiAgICB2YXIgYmFkU3RyaW5naWZpZXI7XG4gICAgaWYgKGhhc1RvU3RyaW5nVGFnKSB7XG4gICAgICBoYXMgPSBjYWxsQm91bmQoXCJPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XCIpO1xuICAgICAgJGV4ZWMgPSBjYWxsQm91bmQoXCJSZWdFeHAucHJvdG90eXBlLmV4ZWNcIik7XG4gICAgICBpc1JlZ2V4TWFya2VyID0ge307XG4gICAgICB0aHJvd1JlZ2V4TWFya2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IGlzUmVnZXhNYXJrZXI7XG4gICAgICB9O1xuICAgICAgYmFkU3RyaW5naWZpZXIgPSB7XG4gICAgICAgIHRvU3RyaW5nOiB0aHJvd1JlZ2V4TWFya2VyLFxuICAgICAgICB2YWx1ZU9mOiB0aHJvd1JlZ2V4TWFya2VyXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wudG9QcmltaXRpdmUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgYmFkU3RyaW5naWZpZXJbU3ltYm9sLnRvUHJpbWl0aXZlXSA9IHRocm93UmVnZXhNYXJrZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0aHJvd1JlZ2V4TWFya2VyO1xuICAgIHZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO1xuICAgIHZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICB2YXIgcmVnZXhDbGFzcyA9IFwiW29iamVjdCBSZWdFeHBdXCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gaGFzVG9TdHJpbmdUYWcgPyBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsIFwibGFzdEluZGV4XCIpO1xuICAgICAgdmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzKGRlc2NyaXB0b3IsIFwidmFsdWVcIik7XG4gICAgICBpZiAoIWhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAkZXhlYyh2YWx1ZSwgYmFkU3RyaW5naWZpZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZSA9PT0gaXNSZWdleE1hcmtlcjtcbiAgICAgIH1cbiAgICB9IDogZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvY29tcG9uZW50V2l0aE5hbWUuanNcbnZhciByZXF1aXJlX2NvbXBvbmVudFdpdGhOYW1lID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9jb21wb25lbnRXaXRoTmFtZS5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21wb25lbnRXaXRoTmFtZTtcbiAgICB2YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuICAgIHZhciBfaXNSZWdleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9pc19yZWdleCgpKTtcbiAgICB2YXIgX2FycmF5UHJvdG90eXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FycmF5X3Byb3RvdHlwZSgpKTtcbiAgICB2YXIgX2dldENvbXBvbmVudE5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZ2V0Q29tcG9uZW50TmFtZSgpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpcEhPQ3MoZnVsbE5hbWUsIG5hbWVzT2ZIT0NzVG9TdHJpcCkge1xuICAgICAgdmFyIGlubmVyTmFtZSA9IGZ1bGxOYW1lO1xuICAgICAgd2hpbGUgKC9cXChbXigpXSpcXCkvZy50ZXN0KGlubmVyTmFtZSkpIHtcbiAgICAgICAgdmFyIEhPQyA9IGlubmVyTmFtZTtcbiAgICAgICAgdmFyIHByZXZpb3VzSE9DID0gdm9pZCAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcHJldmlvdXNIT0MgPSBIT0M7XG4gICAgICAgICAgSE9DID0gcHJldmlvdXNIT0MucmVwbGFjZSgvXFwoW14oKV0qXFwpL2csIFwiXCIpO1xuICAgICAgICB9IHdoaWxlIChwcmV2aW91c0hPQyAhPT0gSE9DKTtcbiAgICAgICAgaWYgKG5hbWVzT2ZIT0NzVG9TdHJpcC5pbmRleE9mKEhPQykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGlubmVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lck5hbWUgPSBpbm5lck5hbWUucmVwbGFjZShSZWdFeHAoXCJeXCIuY29uY2F0KEhPQywgXCJcXFxcKHxcXFxcKSRcIiksIFwiZ1wiKSwgXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5uZXJOYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNOYW1lKG5hbWUsIG5hbWVzT2ZIT0NzVG9TdHJpcCwgcHJvcFZhbHVlLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDUgPyBfbGVuIC0gNSA6IDApLCBfa2V5ID0gNTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZXN0W19rZXkgLSA1XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfYXJyYXlQcm90b3R5cGVbXCJkZWZhdWx0XCJdKShwcm9wVmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaGFzTmFtZS5hcHBseSh2b2lkIDAsIFtuYW1lLCBuYW1lc09mSE9Dc1RvU3RyaXAsIGl0ZW0sIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgICB9KSwgQm9vbGVhbikgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghLyogQF9fUFVSRV9fICovIF9yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIi5cIikuY29uY2F0KHByb3BOYW1lLCBcIiBpcyBub3QgYSB2YWxpZCBSZWFjdCBlbGVtZW50XCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gcHJvcFZhbHVlLnR5cGU7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZUZyb21UeXBlID0gKDAsIF9nZXRDb21wb25lbnROYW1lW1wiZGVmYXVsdFwiXSkodHlwZSk7XG4gICAgICB2YXIgaW5uZXJDb21wb25lbnROYW1lID0gbmFtZXNPZkhPQ3NUb1N0cmlwLmxlbmd0aCA+IDAgPyBzdHJpcEhPQ3MoY29tcG9uZW50TmFtZUZyb21UeXBlLCBuYW1lc09mSE9Dc1RvU3RyaXApIDogY29tcG9uZW50TmFtZUZyb21UeXBlO1xuICAgICAgaWYgKCgwLCBfaXNSZWdleFtcImRlZmF1bHRcIl0pKG5hbWUpICYmICFuYW1lLnRlc3QoaW5uZXJDb21wb25lbnROYW1lKSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIuXCIpLmNvbmNhdChwcm9wTmFtZSwgXCJgIG9ubHkgYWNjZXB0cyBjb21wb25lbnRzIG1hdGNoaW5nIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gXCIpLmNvbmNhdChuYW1lKSk7XG4gICAgICB9XG4gICAgICBpZiAoISgwLCBfaXNSZWdleFtcImRlZmF1bHRcIl0pKG5hbWUpICYmIGlubmVyQ29tcG9uZW50TmFtZSAhPT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIuXCIpLmNvbmNhdChwcm9wTmFtZSwgXCJgIG9ubHkgYWNjZXB0cyBjb21wb25lbnRzIG5hbWVkIFwiKS5jb25jYXQobmFtZSwgXCIsIGdvdCBcIikuY29uY2F0KGlubmVyQ29tcG9uZW50TmFtZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBvbmVudFdpdGhOYW1lKG5hbWUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiAmJiAhKDAsIF9pc1JlZ2V4W1wiZGVmYXVsdFwiXSkobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIHJlZ2V4XCIpO1xuICAgICAgfVxuICAgICAgdmFyIHBhc3NlZE9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICAgIGlmIChwYXNzZWRPcHRpb25zLmxlbmd0aCA+IDEgfHwgcGFzc2VkT3B0aW9ucy5sZW5ndGggPT09IDEgJiYgcGFzc2VkT3B0aW9uc1swXSAhPT0gXCJzdHJpcEhPQ3NcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIG9ubHkgb3B0aW9ucyBzdXBwb3J0ZWQgYXJlOiBcXHUyMDFDc3RyaXBIT0NzXFx1MjAxRCwgZ290OiBcXHUyMDFDXCIuY29uY2F0KHBhc3NlZE9wdGlvbnMuam9pbihcIlxcdTIwMUQsIFxcdTIwMUNcIiksIFwiXFx1MjAxRFwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgX29wdGlvbnMkc3RyaXBIT0NzID0gb3B0aW9ucy5zdHJpcEhPQ3MsIG5hbWVzT2ZIT0NzVG9TdHJpcCA9IF9vcHRpb25zJHN0cmlwSE9DcyA9PT0gdm9pZCAwID8gW10gOiBfb3B0aW9ucyRzdHJpcEhPQ3M7XG4gICAgICB2YXIgYWxsSE9DTmFtZXNBcmVWYWxpZCA9IG5hbWVzT2ZIT0NzVG9TdHJpcC5ldmVyeShmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gXCJzdHJpbmdcIiB8fCAvWygpXS9nLnRlc3QoeCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC9eKD86W2Etel1bYS16QS1aMC05XSt8W0EtWl1bYS16XVthLXpBLVowLTldKykkLy50ZXN0KHgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWFsbEhPQ05hbWVzQXJlVmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV2ZXJ5IHByb3ZpZGVkIEhPQyBuYW1lIG11c3QgYmUgYSBzdHJpbmcgd2l0aCBubyBwYXJlbnMsIGFuZCBpbiBjYW1lbENhc2VcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjb21wb25lbnRXaXRoTmFtZVZhbGlkYXRvcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4yID4gMyA/IF9sZW4yIC0gMyA6IDApLCBfa2V5MiA9IDM7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICByZXN0W19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNOYW1lLmFwcGx5KHZvaWQgMCwgW25hbWUsIG5hbWVzT2ZIT0NzVG9TdHJpcCwgcHJvcFZhbHVlLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudFdpdGhOYW1lVmFsaWRhdG9yLmlzUmVxdWlyZWQgPSBmdW5jdGlvbiBjb21wb25lbnRXaXRoTmFtZVJlcXVpcmVkKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIuXCIpLmNvbmNhdChwcm9wTmFtZSwgXCJgIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBjb21wb25lbnQgbmFtZWQgXCIpLmNvbmNhdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMyA/IF9sZW4zIC0gMyA6IDApLCBfa2V5MyA9IDM7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gM10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNOYW1lLmFwcGx5KHZvaWQgMCwgW25hbWUsIG5hbWVzT2ZIT0NzVG9TdHJpcCwgcHJvcFZhbHVlLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkoY29tcG9uZW50V2l0aE5hbWVWYWxpZGF0b3IsIFwiY29tcG9uZW50V2l0aE5hbWU6XCIuY29uY2F0KG5hbWUpLCBuYW1lKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2Rpc2FsbG93ZWRJZi5qc1xudmFyIHJlcXVpcmVfZGlzYWxsb3dlZElmID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9kaXNhbGxvd2VkSWYuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZGlzYWxsb3dlZElmO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FsbG93ZWRJZihwcm9wVHlwZSwgb3RoZXJQcm9wTmFtZSwgb3RoZXJQcm9wVHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wVHlwZSAhPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBwcm9wVHlwZS5pc1JlcXVpcmVkICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImEgcHJvcFR5cGUgdmFsaWRhdG9yIGlzIHJlcXVpcmVkOyBwcm9wVHlwZSB2YWxpZGF0b3JzIG11c3QgYWxzbyBwcm92aWRlIGAuaXNSZXF1aXJlZGBcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG90aGVyUHJvcE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm90aGVyIHByb3AgbmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvdGhlclByb3BUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm90aGVyIHByb3AgdHlwZSB2YWxpZGF0b3IgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkaXNhbGxvd2VkSWZSZXF1aXJlZChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIHJlc3RbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlLmlzUmVxdWlyZWQuYXBwbHkocHJvcFR5cGUsIFtwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHNbb3RoZXJQcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlckVycm9yID0gb3RoZXJQcm9wVHlwZS5hcHBseSh2b2lkIDAsIFtwcm9wcywgb3RoZXJQcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgICAgaWYgKG90aGVyRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwicHJvcCBcXHUyMDFDXCIuY29uY2F0KHByb3BOYW1lLCBcIlxcdTIwMUQgaXMgZGlzYWxsb3dlZCB3aGVuIFxcdTIwMUNcIikuY29uY2F0KG90aGVyUHJvcE5hbWUsIFwiXFx1MjAxRCBtYXRjaGVzIHRoZSBwcm92aWRlZCB2YWxpZGF0b3JcIikpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIGRpc2FsbG93ZWRJZlByb3BUeXBlKHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIHJlc3RbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc2FsbG93ZWRJZlJlcXVpcmVkLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9IGRpc2FsbG93ZWRJZlJlcXVpcmVkO1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgXCJkaXNhbGxvd2VkSWZcIiwge1xuICAgICAgICBwcm9wVHlwZSxcbiAgICAgICAgb3RoZXJQcm9wTmFtZSxcbiAgICAgICAgb3RoZXJQcm9wVHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9lbGVtZW50VHlwZS5qc1xudmFyIHJlcXVpcmVfZWxlbWVudFR5cGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2VsZW1lbnRUeXBlLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGVsZW1lbnRUeXBlVmFsaWRhdG9yO1xuICAgIHZhciBfcHJvcFR5cGVzID0gcmVxdWlyZV9wcm9wX3R5cGVzKCk7XG4gICAgdmFyIF9yZWFjdElzID0gcmVxdWlyZV9yZWFjdF9pcygpO1xuICAgIHZhciBfYW5kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FuZCgpKTtcbiAgICB2YXIgX2dldENvbXBvbmVudE5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZ2V0Q29tcG9uZW50TmFtZSgpKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmoyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmoyO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iajIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqMiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqMi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iajIgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajI7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUeXBlTmFtZShUeXBlKSB7XG4gICAgICBpZiAodHlwZW9mIFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFR5cGU7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9ICgwLCBfZ2V0Q29tcG9uZW50TmFtZVtcImRlZmF1bHRcIl0pKFR5cGUpO1xuICAgICAgcmV0dXJuIHR5cGUgfHwgXCJBbm9ueW1vdXMgQ29tcG9uZW50XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRWxlbWVudFR5cGUoVHlwZSwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BzW3Byb3BOYW1lXS50eXBlO1xuICAgICAgaWYgKHR5cGUgPT09IFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIi5cIikuY29uY2F0KHByb3BOYW1lLCBcIiBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCBvZiB0eXBlIFwiKS5jb25jYXQoZ2V0VHlwZU5hbWUoVHlwZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFR5cGVWYWxpZGF0b3IoVHlwZSkge1xuICAgICAgaWYgKFR5cGUgPT09IFwiKlwiKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3dyYXBWYWxpZGF0b3JbXCJkZWZhdWx0XCJdKShfcHJvcFR5cGVzLmVsZW1lbnQsIFwiZWxlbWVudFR5cGUoKilcIiwgVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoISgwLCBfcmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUpKFR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGUgbXVzdCBiZSBhIFJlYWN0IENvbXBvbmVudCwgYW4gSFRNTCBlbGVtZW50IHRhZyBuYW1lLCBvciBcIipcIi4gR290IGFuICcuY29uY2F0KF90eXBlb2YoVHlwZSkpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVsZW1lbnRUeXBlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRWxlbWVudFR5cGUuYXBwbHkodm9pZCAwLCBbVHlwZSwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgZWxlbWVudFR5cGUuaXNSZXF1aXJlZCA9IGVsZW1lbnRUeXBlO1xuICAgICAgdmFyIHR5cGVOYW1lID0gZ2V0VHlwZU5hbWUoVHlwZSk7XG4gICAgICB2YXIgdmFsaWRhdG9yTmFtZSA9IFwiZWxlbWVudFR5cGUoXCIuY29uY2F0KHR5cGVOYW1lLCBcIilcIik7XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkoKDAsIF9hbmRbXCJkZWZhdWx0XCJdKShbX3Byb3BUeXBlcy5lbGVtZW50LCBlbGVtZW50VHlwZV0sIHZhbGlkYXRvck5hbWUpLCB2YWxpZGF0b3JOYW1lLCBUeXBlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL29yLmpzXG52YXIgcmVxdWlyZV9vciA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvb3IuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gb3I7XG4gICAgdmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlX3Byb3BfdHlwZXMoKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcilcbiAgICAgICAgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKVxuICAgICAgICByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKVxuICAgICAgICBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25lT2ZUeXBlVmFsaWRhdG9yKHZhbGlkYXRvcnMpIHtcbiAgICAgIHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbiBvbmVPZlR5cGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICByZXN0W19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcnMgPSB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHYuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoIDwgdmFsaWRhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogaW52YWxpZCB2YWx1ZSBzdXBwbGllZCB0byBcIikuY29uY2F0KHByb3BOYW1lLCBcIi5cIikpO1xuICAgICAgfTtcbiAgICAgIHZhbGlkYXRvci5pc1JlcXVpcmVkID0gZnVuY3Rpb24gb25lT2ZUeXBlUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBtaXNzaW5nIHZhbHVlIGZvciByZXF1aXJlZCBcIikuY29uY2F0KHByb3BOYW1lLCBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcnMgPSB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHYuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSB2YWxpZGF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBpbnZhbGlkIHZhbHVlIFwiKS5jb25jYXQoZXJyb3JzLCBcIiBzdXBwbGllZCB0byByZXF1aXJlZCBcIikuY29uY2F0KHByb3BOYW1lLCBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiAoMCwgX3dyYXBWYWxpZGF0b3JbXCJkZWZhdWx0XCJdKSh2YWxpZGF0b3IsIFwib25lT2ZUeXBlXCIsIHZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcih2YWxpZGF0b3JzKSB7XG4gICAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogXCJvclwiO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcjogMiBvciBtb3JlIHZhbGlkYXRvcnMgYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkYXRvcnMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvcjogMiBvciBtb3JlIHZhbGlkYXRvcnMgYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkYXRvciA9IG9uZU9mVHlwZVZhbGlkYXRvcihbKDAsIF9wcm9wVHlwZXMuYXJyYXlPZikob25lT2ZUeXBlVmFsaWRhdG9yKHZhbGlkYXRvcnMpKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh2YWxpZGF0b3JzKSkpO1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgbmFtZSwgdmFsaWRhdG9ycyk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9leHBsaWNpdE51bGwuanNcbnZhciByZXF1aXJlX2V4cGxpY2l0TnVsbCA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvZXhwbGljaXROdWxsLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmoyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmoyO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iajIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqMiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqMi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iajIgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajI7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHBsaWNpdE51bGwocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogcHJvcCBcXHUyMDFDXCIpLmNvbmNhdChwcm9wTmFtZSwgXCJcXHUyMDFEIG11c3QgYmUgbnVsbCBvciB1bmRlZmluZWQ7IHJlY2VpdmVkIFwiKS5jb25jYXQoX3R5cGVvZihwcm9wc1twcm9wTmFtZV0pKSk7XG4gICAgfVxuICAgIGV4cGxpY2l0TnVsbC5pc1JlcXVpcmVkID0gZnVuY3Rpb24gZXhwbGljaXROdWxsUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCI6IHByb3AgXFx1MjAxQ1wiKS5jb25jYXQocHJvcE5hbWUsIFwiXFx1MjAxRCBtdXN0IGJlIG51bGw7IHJlY2VpdmVkIFwiKS5jb25jYXQoX3R5cGVvZihwcm9wc1twcm9wTmFtZV0pKSk7XG4gICAgfTtcbiAgICB2YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdDIoKSB7XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkoZXhwbGljaXROdWxsLCBcImV4cGxpY2l0TnVsbFwiKTtcbiAgICB9O1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2VtcHR5LmpzXG52YXIgcmVxdWlyZV9lbXB0eSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvZW1wdHkuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICAgIHZhciBfcHJvcFR5cGVzID0gcmVxdWlyZV9wcm9wX3R5cGVzKCk7XG4gICAgdmFyIF9vciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9vcigpKTtcbiAgICB2YXIgX2V4cGxpY2l0TnVsbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9leHBsaWNpdE51bGwoKSk7XG4gICAgdmFyIF93aXRoU2hhcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd2l0aFNoYXBlKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIHZhciBhcnJheU9mVmFsaWRhdG9yO1xuICAgIHZhciB2YWxpZGF0b3IgPSAoMCwgX29yW1wiZGVmYXVsdFwiXSkoW1xuICAgICAgX2V4cGxpY2l0TnVsbFtcImRlZmF1bHRcIl0sXG4gICAgICAoMCwgX3Byb3BUeXBlcy5vbmVPZikoW2ZhbHNlLCBcIlwiLCBOYU5dKSxcbiAgICAgICgwLCBfd2l0aFNoYXBlW1wiZGVmYXVsdFwiXSkoX3Byb3BUeXBlcy5hcnJheSwge1xuICAgICAgICBsZW5ndGg6ICgwLCBfcHJvcFR5cGVzLm9uZU9mKShbMF0pLmlzUmVxdWlyZWRcbiAgICAgIH0pLmlzUmVxdWlyZWQsXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5T2ZWYWxpZGF0b3IuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGFycmF5T2ZWYWxpZGF0b3IgPSAoMCwgX3Byb3BUeXBlcy5hcnJheU9mKSh2YWxpZGF0b3IpLmlzUmVxdWlyZWQ7XG4gICAgdmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQyKCkge1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgXCJlbXB0eVwiKTtcbiAgICB9O1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL2tleXNPZi5qc1xudmFyIHJlcXVpcmVfa2V5c09mID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9rZXlzT2YuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0ga2V5c09mVmFsaWRhdG9yO1xuICAgIHZhciBfaXNQcmltaXRpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfaXNQcmltaXRpdmUoKSk7XG4gICAgdmFyIF93cmFwVmFsaWRhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3dyYXBWYWxpZGF0b3IoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtleXNPZlZhbGlkYXRvcihwcm9wVHlwZSkge1xuICAgICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IFwia2V5c09mXCI7XG4gICAgICBpZiAodHlwZW9mIHByb3BUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHRvIGtleXNPZiBtdXN0IGJlIGEgdmFsaWQgUHJvcFR5cGUgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24ga2V5c09mKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gNSA/IF9sZW4gLSA1IDogMCksIF9rZXkgPSA1OyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5IC0gNV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsIHx8ICgwLCBfaXNQcmltaXRpdmVbXCJkZWZhdWx0XCJdKShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0RXJyb3IgPSBudWxsO1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wVmFsdWUpLnNvbWUoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgZmlyc3RFcnJvciA9IHByb3BUeXBlLmFwcGx5KHZvaWQgMCwgW19kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBrZXkpLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBcIihcIi5jb25jYXQocHJvcEZ1bGxOYW1lLCBcIikuXCIpLmNvbmNhdChrZXkpXS5jb25jYXQocmVzdCkpO1xuICAgICAgICAgIHJldHVybiBmaXJzdEVycm9yICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlyc3RFcnJvciB8fCBudWxsO1xuICAgICAgfTtcbiAgICAgIHZhbGlkYXRvci5pc1JlcXVpcmVkID0gZnVuY3Rpb24ga2V5ZWRCeVJlcXVpcmVkKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogXCIpLmNvbmNhdChwcm9wTmFtZSwgXCIgaXMgcmVxdWlyZWQsIGJ1dCB2YWx1ZSBpcyBcIikuY29uY2F0KHByb3BWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdG9yLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBuYW1lLCBwcm9wVHlwZSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9tdXR1YWxseUV4Y2x1c2l2ZVByb3BzLmpzXG52YXIgcmVxdWlyZV9tdXR1YWxseUV4Y2x1c2l2ZVByb3BzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9tdXR1YWxseUV4Y2x1c2l2ZVByb3BzLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IG11dHVhbGx5RXhjbHVzaXZlT2ZUeXBlO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICAgIGlmIChlbnVtZXJhYmxlT25seSlcbiAgICAgICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdXR1YWxseUV4Y2x1c2l2ZU9mVHlwZShwcm9wVHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wVHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhIHByb3BUeXBlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGV4Y2x1c2l2ZVByb3BzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgZXhjbHVzaXZlUHJvcHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2x1c2l2ZVByb3BzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0IGxlYXN0IG9uZSBwcm9wIHRoYXQgaXMgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggdGhpcyBwcm9wVHlwZSBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wTGlzdCA9IGV4Y2x1c2l2ZVByb3BzLmpvaW4oXCIsIG9yIFwiKTtcbiAgICAgIHZhciBtYXAgPSBleGNsdXNpdmVQcm9wcy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFjYyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIHByb3AsIHRydWUpKTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIHZhciBjb3VudFByb3BzID0gZnVuY3Rpb24gY291bnRQcm9wczIoY291bnQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ICsgKG1hcFtwcm9wXSA/IDEgOiAwKTtcbiAgICAgIH07XG4gICAgICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24gbXV0dWFsbHlFeGNsdXNpdmVQcm9wcyhwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGV4Y2x1c2l2ZVByb3BDb3VudCA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIHJldHVybiBwcm9wc1twcm9wXSAhPSBudWxsO1xuICAgICAgICB9KS5yZWR1Y2UoY291bnRQcm9wcywgMCk7XG4gICAgICAgIGlmIChleGNsdXNpdmVQcm9wQ291bnQgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkEgXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgb2YgdGhlc2UgcHJvcHM6IFwiKS5jb25jYXQocHJvcExpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjIgPiAzID8gX2xlbjIgLSAzIDogMCksIF9rZXkyID0gMzsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIHJlc3RbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BUeXBlLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIG11dHVhbGx5RXhjbHVzaXZlUHJvcHNSZXF1aXJlZChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGV4Y2x1c2l2ZVByb3BDb3VudCA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIHJldHVybiBwcm9wID09PSBwcm9wTmFtZSB8fCBwcm9wc1twcm9wXSAhPSBudWxsO1xuICAgICAgICB9KS5yZWR1Y2UoY291bnRQcm9wcywgMCk7XG4gICAgICAgIGlmIChleGNsdXNpdmVQcm9wQ291bnQgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkEgXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgb2YgdGhlc2UgcHJvcHM6IFwiKS5jb25jYXQocHJvcExpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjMgPiAzID8gX2xlbjMgLSAzIDogMCksIF9rZXkzID0gMzsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIHJlc3RbX2tleTMgLSAzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BUeXBlLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBcIm11dHVhbGx5RXhjbHVzaXZlUHJvcHM6XCIuY29uY2F0KHByb3BMaXN0KSwgZXhjbHVzaXZlUHJvcHMpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvbXV0dWFsbHlFeGNsdXNpdmVUcnVlUHJvcHMuanNcbnZhciByZXF1aXJlX211dHVhbGx5RXhjbHVzaXZlVHJ1ZVByb3BzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9tdXR1YWxseUV4Y2x1c2l2ZVRydWVQcm9wcy5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtdXR1YWxseUV4Y2x1c2l2ZVRydWU7XG4gICAgdmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlX3Byb3BfdHlwZXMoKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdXR1YWxseUV4Y2x1c2l2ZVRydWUoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZXhjbHVzaXZlUHJvcHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGV4Y2x1c2l2ZVByb3BzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2x1c2l2ZVByb3BzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0IGxlYXN0IG9uZSBwcm9wIHRoYXQgaXMgbXV0dWFsbHkgZXhjbHVzaXZlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFleGNsdXNpdmVQcm9wcy5ldmVyeShmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhbGwgZXhjbHVzaXZlIHRydWUgcHJvcHMgbXVzdCBiZSBzdHJpbmdzXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzTGlzdCA9IGV4Y2x1c2l2ZVByb3BzLmpvaW4oXCIsIG9yIFwiKTtcbiAgICAgIHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbiBtdXR1YWxseUV4Y2x1c2l2ZVRydWVQcm9wcyhwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGNvdW50UHJvcHMgPSBmdW5jdGlvbiBjb3VudFByb3BzMihjb3VudCwgcHJvcCkge1xuICAgICAgICAgIHJldHVybiBjb3VudCArIChwcm9wc1twcm9wXSA/IDEgOiAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV4Y2x1c2l2ZVByb3BDb3VudCA9IGV4Y2x1c2l2ZVByb3BzLnJlZHVjZShjb3VudFByb3BzLCAwKTtcbiAgICAgICAgaWYgKGV4Y2x1c2l2ZVByb3BDb3VudCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiQSBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgY2Fubm90IGhhdmUgbW9yZSB0aGFuIG9uZSBvZiB0aGVzZSBib29sZWFuIHByb3BzIGJlIHRydWU6IFwiKS5jb25jYXQocHJvcHNMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4yID4gMyA/IF9sZW4yIC0gMyA6IDApLCBfa2V5MiA9IDM7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICByZXN0W19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcHJvcFR5cGVzLmJvb2wuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgfTtcbiAgICAgIHZhbGlkYXRvci5pc1JlcXVpcmVkID0gZnVuY3Rpb24gbXV0dWFsbHlFeGNsdXNpdmVUcnVlUHJvcHNSZXF1aXJlZChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGNvdW50UHJvcHMgPSBmdW5jdGlvbiBjb3VudFByb3BzMihjb3VudCwgcHJvcCkge1xuICAgICAgICAgIHJldHVybiBjb3VudCArIChwcm9wc1twcm9wXSA/IDEgOiAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV4Y2x1c2l2ZVByb3BDb3VudCA9IGV4Y2x1c2l2ZVByb3BzLnJlZHVjZShjb3VudFByb3BzLCAwKTtcbiAgICAgICAgaWYgKGV4Y2x1c2l2ZVByb3BDb3VudCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiQSBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgY2Fubm90IGhhdmUgbW9yZSB0aGFuIG9uZSBvZiB0aGVzZSBib29sZWFuIHByb3BzIGJlIHRydWU6IFwiKS5jb25jYXQocHJvcHNMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMyA/IF9sZW4zIC0gMyA6IDApLCBfa2V5MyA9IDM7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gM10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZC5hcHBseShfcHJvcFR5cGVzLmJvb2wsIFtwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgXCJtdXR1YWxseUV4Y2x1c2l2ZVRydWVQcm9wczogXCIuY29uY2F0KHByb3BzTGlzdCksIGV4Y2x1c2l2ZVByb3BzKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL25DaGlsZHJlbi5qc1xudmFyIHJlcXVpcmVfbkNoaWxkcmVuID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9uQ2hpbGRyZW4uanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbkNoaWxkcmVuO1xuICAgIHZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG4gICAgdmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlX3Byb3BfdHlwZXMoKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuQ2hpbGRyZW4obikge1xuICAgICAgdmFyIHByb3BUeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBfcHJvcFR5cGVzLm5vZGU7XG4gICAgICBpZiAodHlwZW9mIG4gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4obikgfHwgbiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImEgbm9uLW5lZ2F0aXZlIG51bWJlciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbiBuQ2hpbGRyZW5WYWxpZGF0b3IocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gXCJjaGlsZHJlblwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgaXMgdXNpbmcgdGhlIG5DaGlsZHJlbiB2YWxpZGF0b3Igb24gYSBub24tY2hpbGRyZW4gcHJvcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBjaGlsZHJlbkNvdW50ID0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChjaGlsZHJlbik7XG4gICAgICAgIGlmIChjaGlsZHJlbkNvdW50ICE9PSBuKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIGV4cGVjdHMgdG8gcmVjZWl2ZSBcIikuY29uY2F0KG4sIFwiIGNoaWxkcmVuLCBidXQgcmVjZWl2ZWQgXCIpLmNvbmNhdChjaGlsZHJlbkNvdW50LCBcIiBjaGlsZHJlbi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICByZXN0W19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcFR5cGUuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgfTtcbiAgICAgIHZhbGlkYXRvci5pc1JlcXVpcmVkID0gdmFsaWRhdG9yO1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKHZhbGlkYXRvciwgXCJuQ2hpbGRyZW46XCIuY29uY2F0KG4pLCBuKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL251bWVyaWNTdHJpbmcuanNcbnZhciByZXF1aXJlX251bWVyaWNTdHJpbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL251bWVyaWNTdHJpbmcuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICAgIHZhciBfcHJvcFR5cGVzID0gcmVxdWlyZV9wcm9wX3R5cGVzKCk7XG4gICAgdmFyIF93cmFwVmFsaWRhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3dyYXBWYWxpZGF0b3IoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgdmFyIHZhbGlkTnVtZXJpY0NoYXJzID0gL15bLStdPyg/OlsxLTldWzAtOV0qKD86XFwuWzAtOV0rKT98MHwwXFwuWzAtOV0rKSQvO1xuICAgIHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbiBudW1lcmljU3RyaW5nKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZXN0W19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJpbmdFcnJvciA9IF9wcm9wVHlwZXMuc3RyaW5nLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIGlmIChzdHJpbmdFcnJvcikge1xuICAgICAgICByZXR1cm4gc3RyaW5nRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcGFzc2VzUmVnZXggPSB2YWxpZE51bWVyaWNDaGFycy50ZXN0KHZhbHVlKTtcbiAgICAgIGlmIChwYXNzZXNSZWdleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsICc6IHByb3AgXCInKS5jb25jYXQocHJvcE5hbWUsICdcIiAodmFsdWUgXCInKS5jb25jYXQodmFsdWUsICdcIikgbXVzdCBiZSBhIG51bWVyaWMgc3RyaW5nOlxcbiAgICAtIHN0YXJ0aW5nIHdpdGggYW4gb3B0aW9uYWwgKyBvciAtXFxuICAgIC0gdGhhdCBkb2VzIG5vdCBoYXZlIGEgbGVhZGluZyB6ZXJvXFxuICAgIC0gd2l0aCBhbiBvcHRpb25hbCBkZWNpbWFsIHBhcnQgKHRoYXQgY29udGFpbnMgb25seSBvbmUgZGVjaW1hbCBwb2ludCwgaWYgcHJlc2VudClcXG4gICAgLSB0aGF0IG90aGVyd2lzZSBvbmx5IGNvbnRhaW5zIGRpZ2l0cyAoMC05KVxcbiAgICAtIG5vdCArLU5hTiwgb3IgKy1JbmZpbml0eVxcbiAgJykpO1xuICAgIH07XG4gICAgdmFsaWRhdG9yLmlzUmVxdWlyZWQgPSBmdW5jdGlvbiBudW1lcmljU3RyaW5nUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCI6IFwiKS5jb25jYXQocHJvcE5hbWUsIFwiIGlzIHJlcXVpcmVkXCIpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHJlc3RbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRhdG9yLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICB9O1xuICAgIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0MigpIHtcbiAgICAgIHJldHVybiAoMCwgX3dyYXBWYWxpZGF0b3JbXCJkZWZhdWx0XCJdKSh2YWxpZGF0b3IsIFwibnVtZXJpY1N0cmluZ1wiKTtcbiAgICB9O1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL3ByZWRpY2F0ZS5qc1xudmFyIHJlcXVpcmVfcHJlZGljYXRlID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9wcmVkaWNhdGUuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcHJlZGljYXRlO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWRpY2F0ZShmbikge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImBmbmAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJgbWVzc2FnZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVxdWlyZWRWYWxpZGF0b3IocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmbihwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJgXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiYCByZXF1aXJlcyB0aGF0IGBcIikuY29uY2F0KHByb3BOYW1lLCBcImAgcGFzcyBhIHByZWRpY2F0ZSBmdW5jdGlvblwiKS5jb25jYXQobWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiBcIlwiLCBcIi5cIikpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdmFsaWRhdG9yKHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVpcmVkVmFsaWRhdG9yLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRvci5pc1JlcXVpcmVkID0gcmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBcInByZWRpY2F0ZVwiLCBmbik7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9yYW5nZS5qc1xudmFyIHJlcXVpcmVfcmFuZ2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL3JhbmdlLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHJhbmdlO1xuICAgIHZhciBfYW5kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FuZCgpKTtcbiAgICB2YXIgX2JldHdlZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYmV0d2VlbigpKTtcbiAgICB2YXIgX2ludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfaW50ZWdlcigpKTtcbiAgICB2YXIgX2lzSW50ZWdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9pc0ludGVnZXIoKSk7XG4gICAgdmFyIF93cmFwVmFsaWRhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3dyYXBWYWxpZGF0b3IoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBNYXRoLnBvdygyLCA1MykgLSAxO1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRMZW5ndGgoeCkge1xuICAgICAgcmV0dXJuICgwLCBfaXNJbnRlZ2VyW1wiZGVmYXVsdFwiXSkoeCkgJiYgTWF0aC5hYnMoeCkgPCBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZShtaW4sIG1heCkge1xuICAgICAgaWYgKCFpc1ZhbGlkTGVuZ3RoKG1pbikgfHwgIWlzVmFsaWRMZW5ndGgobWF4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJyYW5nZVwiIHJlcXVpcmVzIHR3byBpbnRlZ2VyczogJy5jb25jYXQobWluLCBcIiBhbmQgXCIpLmNvbmNhdChtYXgsIFwiIGdpdmVuXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm1pbiBhbmQgbWF4IG11c3Qgbm90IGJlIHRoZSBzYW1lXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKCgwLCBfYW5kW1wiZGVmYXVsdFwiXSkoWygwLCBfaW50ZWdlcltcImRlZmF1bHRcIl0pKCksICgwLCBfYmV0d2VlbltcImRlZmF1bHRcIl0pKHtcbiAgICAgICAgZ3RlOiBtaW4sXG4gICAgICAgIGx0OiBtYXhcbiAgICAgIH0pXSwgXCJyYW5nZVwiKSwgXCJyYW5nZVwiLCB7XG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL3JlZi5qc1xudmFyIHJlcXVpcmVfcmVmID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9yZWYuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICAgIHZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG4gICAgdmFyIF9pc1BsYWluT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2lzUGxhaW5PYmplY3QyKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIHZhciBpc1Byb3RvdHlwZU9mID0gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mO1xuICAgIGZ1bmN0aW9uIGlzTmV3UmVmKHByb3ApIHtcbiAgICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0W1wiZGVmYXVsdFwiXSkocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG93blByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhwcm9wKTtcbiAgICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSAmJiBvd25Qcm9wZXJ0aWVzWzBdID09PSBcImN1cnJlbnRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDYWxsYmFja1JlZihwcm9wKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHByb3AgPT09IFwiZnVuY3Rpb25cIiAmJiAhaXNQcm90b3R5cGVPZi5jYWxsKF9yZWFjdC5Db21wb25lbnQsIHByb3ApICYmICghX3JlYWN0LlB1cmVDb21wb25lbnQgfHwgIWlzUHJvdG90eXBlT2YuY2FsbChfcmVhY3QuUHVyZUNvbXBvbmVudCwgcHJvcCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZFJlZihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoaXNDYWxsYmFja1JlZihwcm9wVmFsdWUpIHx8IGlzTmV3UmVmKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChwcm9wTmFtZSwgXCIgaW4gXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcIiBtdXN0IGJlIGEgcmVmXCIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVmKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVzdFtfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWlyZWRSZWYuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgIH1cbiAgICByZWYuaXNSZXF1aXJlZCA9IHJlcXVpcmVkUmVmO1xuICAgIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0MigpIHtcbiAgICAgIHJldHVybiAoMCwgX3dyYXBWYWxpZGF0b3JbXCJkZWZhdWx0XCJdKShyZWYsIFwicmVmXCIpO1xuICAgIH07XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvcmVxdWlyZWRCeS5qc1xudmFyIHJlcXVpcmVfcmVxdWlyZWRCeSA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvcmVxdWlyZWRCeS5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnZXRSZXF1aXJlZEJ5O1xuICAgIHZhciBfb2JqZWN0SXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfb2JqZWN0X2lzKCkpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJlcXVpcmVkQnkocmVxdWlyZWRCeVByb3BOYW1lLCBwcm9wVHlwZSkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIGZ1bmN0aW9uIHJlcXVpcmVkQnkocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGlmIChwcm9wc1tyZXF1aXJlZEJ5UHJvcE5hbWVdKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICBpZiAoKDAsIF9vYmplY3RJc1tcImRlZmF1bHRcIl0pKHByb3BWYWx1ZSwgZGVmYXVsdFZhbHVlKSB8fCB0eXBlb2YgcHJvcFZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogd2hlbiBcIikuY29uY2F0KHJlcXVpcmVkQnlQcm9wTmFtZSwgXCIgaXMgdHJ1ZSwgcHJvcCBcXHUyMDFDXCIpLmNvbmNhdChwcm9wTmFtZSwgXCJcXHUyMDFEIG11c3QgYmUgcHJlc2VudC5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BUeXBlLmFwcGx5KHZvaWQgMCwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJlcXVpcmVkQnkuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIHJlcXVpcmVkQnlSZXF1aXJlZChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKCgwLCBfb2JqZWN0SXNbXCJkZWZhdWx0XCJdKShwcm9wVmFsdWUsIGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogcHJvcCBcXHUyMDFDXCIpLmNvbmNhdChwcm9wTmFtZSwgXCJcXHUyMDFEIG11c3QgYmUgcHJlc2VudC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcFR5cGUuaXNSZXF1aXJlZC5hcHBseShwcm9wVHlwZSwgW3Byb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkocmVxdWlyZWRCeSwgXCJyZXF1aXJlZEJ5IFxcdTIwMUNcIi5jb25jYXQocmVxdWlyZWRCeVByb3BOYW1lLCBcIlxcdTIwMURcIiksIFtyZXF1aXJlZEJ5UHJvcE5hbWUsIGRlZmF1bHRWYWx1ZV0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvcmVzdHJpY3RlZFByb3AuanNcbnZhciByZXF1aXJlX3Jlc3RyaWN0ZWRQcm9wID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9yZXN0cmljdGVkUHJvcC5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gICAgdmFyIF93cmFwVmFsaWRhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3dyYXBWYWxpZGF0b3IoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3VzdG9tTWVzc2FnZVdyYXBwZXIobWVzc3NhZ2VGdW5jdGlvbikge1xuICAgICAgZnVuY3Rpb24gcmVzdHJpY3RlZFByb3AocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc3NhZ2VGdW5jdGlvbiAmJiB0eXBlb2YgbWVzc3NhZ2VGdW5jdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDQgPyBfbGVuIC0gNCA6IDApLCBfa2V5ID0gNDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgcmVzdFtfa2V5IC0gNF0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKG1lc3NzYWdlRnVuY3Rpb24uYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbl0uY29uY2F0KHJlc3QpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJUaGUgXCIuY29uY2F0KHByb3BOYW1lLCBcIiBcIikuY29uY2F0KGxvY2F0aW9uLCBcIiBvbiBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIGlzIG5vdCBhbGxvd2VkLlwiKSk7XG4gICAgICB9XG4gICAgICByZXN0cmljdGVkUHJvcC5pc1JlcXVpcmVkID0gcmVzdHJpY3RlZFByb3A7XG4gICAgICByZXR1cm4gcmVzdHJpY3RlZFByb3A7XG4gICAgfVxuICAgIHZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0MigpIHtcbiAgICAgIHZhciBtZXNzc2FnZUZ1bmN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgcmV0dXJuICgwLCBfd3JhcFZhbGlkYXRvcltcImRlZmF1bHRcIl0pKGN1c3RvbU1lc3NhZ2VXcmFwcGVyKG1lc3NzYWdlRnVuY3Rpb24pLCBcInJlc3RyaWN0ZWRQcm9wXCIpO1xuICAgIH07XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvc3RyaW5nRW5kc1dpdGguanNcbnZhciByZXF1aXJlX3N0cmluZ0VuZHNXaXRoID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9zdHJpbmdFbmRzV2l0aC5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzdHJpbmdFbmRzV2l0aFZhbGlkYXRvcjtcbiAgICB2YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmVfcHJvcF90eXBlcygpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ0VuZHNXaXRoVmFsaWRhdG9yKGVuZCkge1xuICAgICAgaWYgKHR5cGVvZiBlbmQgIT09IFwic3RyaW5nXCIgfHwgZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYSBub24tZW1wdHkgc3RyaW5nIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIHN0cmluZ0VuZHNXaXRoKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ0Vycm9yID0gX3Byb3BUeXBlcy5zdHJpbmcuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgICBpZiAoc3RyaW5nRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9wVmFsdWUuZW5kc1dpdGgoZW5kKSB8fCBwcm9wVmFsdWUubGVuZ3RoIDw9IGVuZC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIjogXCIpLmNvbmNhdChwcm9wTmFtZSwgJyBkb2VzIG5vdCBlbmQgd2l0aCBcIicpLmNvbmNhdChlbmQsICdcIicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIHJlcXVpcmVkU3RyaW5nRW5kc1dpdGgoKSB7XG4gICAgICAgIHZhciBzdHJpbmdFcnJvciA9IF9wcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQuYXBwbHkoX3Byb3BUeXBlcy5zdHJpbmcsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzdHJpbmdFcnJvcikge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdG9yLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodmFsaWRhdG9yLCBcInN0cmluZ0VuZHNXaXRoOiBcIi5jb25jYXQoZW5kKSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9zdHJpbmdTdGFydHNXaXRoLmpzXG52YXIgcmVxdWlyZV9zdHJpbmdTdGFydHNXaXRoID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC9zdHJpbmdTdGFydHNXaXRoLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHN0cmluZ1N0YXJ0c1dpdGhWYWxpZGF0b3I7XG4gICAgdmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlX3Byb3BfdHlwZXMoKTtcbiAgICB2YXIgX3dyYXBWYWxpZGF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd3JhcFZhbGlkYXRvcigpKTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdTdGFydHNXaXRoVmFsaWRhdG9yKHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSBcInN0cmluZ1wiIHx8IHN0YXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYSBub24tZW1wdHkgc3RyaW5nIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIHN0cmluZ1N0YXJ0c1dpdGgocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICByZXN0W19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5nRXJyb3IgPSBfcHJvcFR5cGVzLnN0cmluZy5hcHBseSh2b2lkIDAsIFtwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIGlmIChzdHJpbmdFcnJvcikge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3BWYWx1ZS5zdGFydHNXaXRoKHN0YXJ0KSB8fCBwcm9wVmFsdWUubGVuZ3RoIDw9IHN0YXJ0Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiOiBcIikuY29uY2F0KHByb3BOYW1lLCAnIGRvZXMgbm90IHN0YXJ0IHdpdGggXCInKS5jb25jYXQoc3RhcnQsICdcIicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIHJlcXVpcmVkU3RyaW5nU3RhcnRzV2l0aCgpIHtcbiAgICAgICAgdmFyIHN0cmluZ0Vycm9yID0gX3Byb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZC5hcHBseShfcHJvcFR5cGVzLnN0cmluZywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHN0cmluZ0Vycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ0Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3IuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiAoMCwgX3dyYXBWYWxpZGF0b3JbXCJkZWZhdWx0XCJdKSh2YWxpZGF0b3IsIFwic3RyaW5nU3RhcnRzV2l0aDogXCIuY29uY2F0KHN0YXJ0KSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC91bmlxdWVBcnJheS5qc1xudmFyIHJlcXVpcmVfdW5pcXVlQXJyYXkgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9haXJibmItcHJvcC10eXBlcy12aXJ0dWFsLTJkYmFjZDQxMmIvMC9jYWNoZS9haXJibmItcHJvcC10eXBlcy1ucG0tMi4xNi4wLWQ3OTRmNTI3MWMtMzkzYTU5ODhiOS56aXAvbm9kZV9tb2R1bGVzL2FpcmJuYi1wcm9wLXR5cGVzL2J1aWxkL3VuaXF1ZUFycmF5LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgICB2YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmVfcHJvcF90eXBlcygpO1xuICAgIHZhciBfd3JhcFZhbGlkYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwVmFsaWRhdG9yKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuaXF1ZUNvdW50V2l0aFNldChhcnIpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KGFycikuc2l6ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5pcXVlQ291bnRMZWdhY3koYXJyKSB7XG4gICAgICB2YXIgc2VlbiA9IFtdO1xuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgIHNlZW4ucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2Vlbi5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBnZXRVbmlxdWVDb3VudCA9IHR5cGVvZiBTZXQgPT09IFwiZnVuY3Rpb25cIiA/IHVuaXF1ZUNvdW50V2l0aFNldCA6IHVuaXF1ZUNvdW50TGVnYWN5O1xuICAgIGZ1bmN0aW9uIHJlcXVpcmVkVW5pcXVlQXJyYXkocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlc3RbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IF9wcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZC5hcHBseShfcHJvcFR5cGVzLmFycmF5LCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO1xuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHVuaXF1ZUNvdW50ID0gZ2V0VW5pcXVlQ291bnQocHJvcFZhbHVlKTtcbiAgICAgIGlmICh1bmlxdWVDb3VudCAhPT0gcHJvcFZhbHVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IoXCJcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCI6IHZhbHVlcyBtdXN0IGJlIHVuaXF1ZS4gXCIpLmNvbmNhdChwcm9wVmFsdWUubGVuZ3RoIC0gdW5pcXVlQ291bnQsIFwiIGR1cGxpY2F0ZSB2YWx1ZXMgZm91bmQuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmlxdWVBcnJheShwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICByZXN0W19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVpcmVkVW5pcXVlQXJyYXkuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lXS5jb25jYXQocmVzdCkpO1xuICAgIH1cbiAgICB1bmlxdWVBcnJheS5pc1JlcXVpcmVkID0gcmVxdWlyZWRVbmlxdWVBcnJheTtcbiAgICB2YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdDIoKSB7XG4gICAgICByZXR1cm4gKDAsIF93cmFwVmFsaWRhdG9yW1wiZGVmYXVsdFwiXSkodW5pcXVlQXJyYXksIFwidW5pcXVlQXJyYXlcIik7XG4gICAgfTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC91bmlxdWVBcnJheU9mLmpzXG52YXIgcmVxdWlyZV91bmlxdWVBcnJheU9mID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9idWlsZC91bmlxdWVBcnJheU9mLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHVuaXF1ZUFycmF5T2ZUeXBlVmFsaWRhdG9yO1xuICAgIHZhciBfcHJvcFR5cGVzID0gcmVxdWlyZV9wcm9wX3R5cGVzKCk7XG4gICAgdmFyIF9hbmQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYW5kKCkpO1xuICAgIHZhciBfdW5pcXVlQXJyYXkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfdW5pcXVlQXJyYXkoKSk7XG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgICAgaWYgKGVudW1lcmFibGVPbmx5KVxuICAgICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgIH0pO1xuICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICBpZiAoaSAlIDIpIHtcbiAgICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciB1bmlxdWUgPSAoMCwgX3VuaXF1ZUFycmF5W1wiZGVmYXVsdFwiXSkoKTtcbiAgICBmdW5jdGlvbiB1bmlxdWVBcnJheU9mVHlwZVZhbGlkYXRvcih0eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgdmFsaWRhdG9yIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG1hcHBlciA9IG51bGw7XG4gICAgICB2YXIgbmFtZSA9IFwidW5pcXVlQXJyYXlPZlR5cGVcIjtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN0WzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBtYXBwZXIgPSByZXN0WzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN0WzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbmFtZSA9IHJlc3RbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNpbmdsZSBpbnB1dCBtdXN0IGVpdGhlciBiZSBzdHJpbmcgb3IgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN0WzBdID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlc3RbMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBtYXBwZXIgPSByZXN0WzBdO1xuICAgICAgICAgIG5hbWUgPSByZXN0WzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtdWx0aXBsZSBpbnB1dHMgbXVzdCBiZSBpbiBbZnVuY3Rpb24sIHN0cmluZ10gb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdC5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvbmx5IFtdLCBbbmFtZV0sIFttYXBwZXJdLCBhbmQgW21hcHBlciwgbmFtZV0gYXJlIHZhbGlkIGlucHV0c1wiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVuaXF1ZUFycmF5T2ZNYXBwZWQocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZXMgPSBwcm9wVmFsdWUubWFwKG1hcHBlcik7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pcXVlLmFwcGx5KHZvaWQgMCwgW19vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBwcm9wTmFtZSwgdmFsdWVzKSksIHByb3BOYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgICAgdW5pcXVlQXJyYXlPZk1hcHBlZC5pc1JlcXVpcmVkID0gZnVuY3Rpb24gaXNSZXF1aXJlZChwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMiA/IF9sZW4zIC0gMiA6IDApLCBfa2V5MyA9IDI7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkzIC0gMl0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBfcHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQuYXBwbHkoX3Byb3BUeXBlcy5hcnJheSwgW3Byb3BzLCBwcm9wTmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pcXVlQXJyYXlPZk1hcHBlZC5hcHBseSh2b2lkIDAsIFtwcm9wcywgcHJvcE5hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9O1xuICAgICAgdmFyIGFycmF5VmFsaWRhdG9yID0gKDAsIF9wcm9wVHlwZXMuYXJyYXlPZikodHlwZSk7XG4gICAgICB2YXIgdW5pcXVlVmFsaWRhdG9yID0gbWFwcGVyID8gdW5pcXVlQXJyYXlPZk1hcHBlZCA6IHVuaXF1ZTtcbiAgICAgIHZhciB2YWxpZGF0b3IgPSAoMCwgX2FuZFtcImRlZmF1bHRcIl0pKFthcnJheVZhbGlkYXRvciwgdW5pcXVlVmFsaWRhdG9yXSwgbmFtZSk7XG4gICAgICB2YWxpZGF0b3IuaXNSZXF1aXJlZCA9ICgwLCBfYW5kW1wiZGVmYXVsdFwiXSkoW3VuaXF1ZVZhbGlkYXRvci5pc1JlcXVpcmVkLCBhcnJheVZhbGlkYXRvci5pc1JlcXVpcmVkXSwgXCJcIi5jb25jYXQobmFtZSwgXCIuaXNSZXF1aXJlZFwiKSk7XG4gICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvaW5kZXguanNcbnZhciByZXF1aXJlX2J1aWxkMiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvYnVpbGQvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIF9wcm9wVHlwZXNFeGFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9idWlsZCgpKTtcbiAgICB2YXIgX2FuZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hbmQoKSk7XG4gICAgdmFyIF9iZXR3ZWVuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2JldHdlZW4oKSk7XG4gICAgdmFyIF9ib29sZWFuU29tZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9ib29sZWFuU29tZSgpKTtcbiAgICB2YXIgX2NoaWxkcmVuSGF2ZVByb3BYb3JDaGlsZHJlbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jaGlsZHJlbkhhdmVQcm9wWG9yQ2hpbGRyZW4oKSk7XG4gICAgdmFyIF9jaGlsZHJlbk9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NoaWxkcmVuT2YoKSk7XG4gICAgdmFyIF9jaGlsZHJlbk9mVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jaGlsZHJlbk9mVHlwZSgpKTtcbiAgICB2YXIgX2NoaWxkcmVuU2VxdWVuY2VPZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jaGlsZHJlblNlcXVlbmNlT2YoKSk7XG4gICAgdmFyIF9jb21wb25lbnRXaXRoTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jb21wb25lbnRXaXRoTmFtZSgpKTtcbiAgICB2YXIgX2Rpc2FsbG93ZWRJZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9kaXNhbGxvd2VkSWYoKSk7XG4gICAgdmFyIF9lbGVtZW50VHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9lbGVtZW50VHlwZSgpKTtcbiAgICB2YXIgX2VtcHR5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2VtcHR5KCkpO1xuICAgIHZhciBfZXhwbGljaXROdWxsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2V4cGxpY2l0TnVsbCgpKTtcbiAgICB2YXIgX2ludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfaW50ZWdlcigpKTtcbiAgICB2YXIgX2tleXNPZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9rZXlzT2YoKSk7XG4gICAgdmFyIF9tdXR1YWxseUV4Y2x1c2l2ZVByb3BzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX211dHVhbGx5RXhjbHVzaXZlUHJvcHMoKSk7XG4gICAgdmFyIF9tdXR1YWxseUV4Y2x1c2l2ZVRydWVQcm9wcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9tdXR1YWxseUV4Y2x1c2l2ZVRydWVQcm9wcygpKTtcbiAgICB2YXIgX25DaGlsZHJlbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9uQ2hpbGRyZW4oKSk7XG4gICAgdmFyIF9ub25OZWdhdGl2ZUludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfbm9uTmVnYXRpdmVJbnRlZ2VyKCkpO1xuICAgIHZhciBfbm9uTmVnYXRpdmVOdW1iZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfbm9uTmVnYXRpdmVOdW1iZXIoKSk7XG4gICAgdmFyIF9udW1lcmljU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX251bWVyaWNTdHJpbmcoKSk7XG4gICAgdmFyIF9vYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfb2JqZWN0MygpKTtcbiAgICB2YXIgX29yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX29yKCkpO1xuICAgIHZhciBfcHJlZGljYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3ByZWRpY2F0ZSgpKTtcbiAgICB2YXIgX3JhbmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JhbmdlKCkpO1xuICAgIHZhciBfcmVmID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlZigpKTtcbiAgICB2YXIgX3JlcXVpcmVkQnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVxdWlyZWRCeSgpKTtcbiAgICB2YXIgX3Jlc3RyaWN0ZWRQcm9wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3Jlc3RyaWN0ZWRQcm9wKCkpO1xuICAgIHZhciBfc2VxdWVuY2VPZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zZXF1ZW5jZU9mKCkpO1xuICAgIHZhciBfc2hhcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2hhcGUoKSk7XG4gICAgdmFyIF9zdHJpbmdFbmRzV2l0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zdHJpbmdFbmRzV2l0aCgpKTtcbiAgICB2YXIgX3N0cmluZ1N0YXJ0c1dpdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc3RyaW5nU3RhcnRzV2l0aCgpKTtcbiAgICB2YXIgX3VuaXF1ZUFycmF5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3VuaXF1ZUFycmF5KCkpO1xuICAgIHZhciBfdW5pcXVlQXJyYXlPZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV91bmlxdWVBcnJheU9mKCkpO1xuICAgIHZhciBfdmFsdWVzT2YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfdmFsdWVzT2YoKSk7XG4gICAgdmFyIF93aXRoU2hhcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfd2l0aFNoYXBlKCkpO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07XG4gICAgfVxuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGFuZDogX2FuZFtcImRlZmF1bHRcIl0sXG4gICAgICBiZXR3ZWVuOiBfYmV0d2VlbltcImRlZmF1bHRcIl0sXG4gICAgICBib29sZWFuU29tZTogX2Jvb2xlYW5Tb21lW1wiZGVmYXVsdFwiXSxcbiAgICAgIGNoaWxkcmVuSGF2ZVByb3BYb3JDaGlsZHJlbjogX2NoaWxkcmVuSGF2ZVByb3BYb3JDaGlsZHJlbltcImRlZmF1bHRcIl0sXG4gICAgICBjaGlsZHJlbk9mOiBfY2hpbGRyZW5PZltcImRlZmF1bHRcIl0sXG4gICAgICBjaGlsZHJlbk9mVHlwZTogX2NoaWxkcmVuT2ZUeXBlW1wiZGVmYXVsdFwiXSxcbiAgICAgIGNoaWxkcmVuU2VxdWVuY2VPZjogX2NoaWxkcmVuU2VxdWVuY2VPZltcImRlZmF1bHRcIl0sXG4gICAgICBjb21wb25lbnRXaXRoTmFtZTogX2NvbXBvbmVudFdpdGhOYW1lW1wiZGVmYXVsdFwiXSxcbiAgICAgIGRpc2FsbG93ZWRJZjogX2Rpc2FsbG93ZWRJZltcImRlZmF1bHRcIl0sXG4gICAgICBlbGVtZW50VHlwZTogX2VsZW1lbnRUeXBlW1wiZGVmYXVsdFwiXSxcbiAgICAgIGVtcHR5OiBfZW1wdHlbXCJkZWZhdWx0XCJdLFxuICAgICAgZXhwbGljaXROdWxsOiBfZXhwbGljaXROdWxsW1wiZGVmYXVsdFwiXSxcbiAgICAgIGZvcmJpZEV4dHJhUHJvcHM6IF9wcm9wVHlwZXNFeGFjdFtcImRlZmF1bHRcIl0sXG4gICAgICBpbnRlZ2VyOiBfaW50ZWdlcltcImRlZmF1bHRcIl0sXG4gICAgICBrZXlzT2Y6IF9rZXlzT2ZbXCJkZWZhdWx0XCJdLFxuICAgICAgbXV0dWFsbHlFeGNsdXNpdmVQcm9wczogX211dHVhbGx5RXhjbHVzaXZlUHJvcHNbXCJkZWZhdWx0XCJdLFxuICAgICAgbXV0dWFsbHlFeGNsdXNpdmVUcnVlUHJvcHM6IF9tdXR1YWxseUV4Y2x1c2l2ZVRydWVQcm9wc1tcImRlZmF1bHRcIl0sXG4gICAgICBuQ2hpbGRyZW46IF9uQ2hpbGRyZW5bXCJkZWZhdWx0XCJdLFxuICAgICAgbm9uTmVnYXRpdmVJbnRlZ2VyOiBfbm9uTmVnYXRpdmVJbnRlZ2VyW1wiZGVmYXVsdFwiXSxcbiAgICAgIG5vbk5lZ2F0aXZlTnVtYmVyOiBfbm9uTmVnYXRpdmVOdW1iZXJbXCJkZWZhdWx0XCJdLFxuICAgICAgbnVtZXJpY1N0cmluZzogX251bWVyaWNTdHJpbmdbXCJkZWZhdWx0XCJdLFxuICAgICAgb2JqZWN0OiBfb2JqZWN0W1wiZGVmYXVsdFwiXSxcbiAgICAgIG9yOiBfb3JbXCJkZWZhdWx0XCJdLFxuICAgICAgcHJlZGljYXRlOiBfcHJlZGljYXRlW1wiZGVmYXVsdFwiXSxcbiAgICAgIHJhbmdlOiBfcmFuZ2VbXCJkZWZhdWx0XCJdLFxuICAgICAgcmVmOiBfcmVmW1wiZGVmYXVsdFwiXSxcbiAgICAgIHJlcXVpcmVkQnk6IF9yZXF1aXJlZEJ5W1wiZGVmYXVsdFwiXSxcbiAgICAgIHJlc3RyaWN0ZWRQcm9wOiBfcmVzdHJpY3RlZFByb3BbXCJkZWZhdWx0XCJdLFxuICAgICAgc2VxdWVuY2VPZjogX3NlcXVlbmNlT2ZbXCJkZWZhdWx0XCJdLFxuICAgICAgc2hhcGU6IF9zaGFwZVtcImRlZmF1bHRcIl0sXG4gICAgICBzdHJpbmdFbmRzV2l0aDogX3N0cmluZ0VuZHNXaXRoW1wiZGVmYXVsdFwiXSxcbiAgICAgIHN0cmluZ1N0YXJ0c1dpdGg6IF9zdHJpbmdTdGFydHNXaXRoW1wiZGVmYXVsdFwiXSxcbiAgICAgIHVuaXF1ZUFycmF5OiBfdW5pcXVlQXJyYXlbXCJkZWZhdWx0XCJdLFxuICAgICAgdW5pcXVlQXJyYXlPZjogX3VuaXF1ZUFycmF5T2ZbXCJkZWZhdWx0XCJdLFxuICAgICAgdmFsdWVzT2Y6IF92YWx1ZXNPZltcImRlZmF1bHRcIl0sXG4gICAgICB3aXRoU2hhcGU6IF93aXRoU2hhcGVbXCJkZWZhdWx0XCJdXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL2FpcmJuYi1wcm9wLXR5cGVzLXZpcnR1YWwtMmRiYWNkNDEyYi8wL2NhY2hlL2FpcmJuYi1wcm9wLXR5cGVzLW5wbS0yLjE2LjAtZDc5NGY1MjcxYy0zOTNhNTk4OGI5LnppcC9ub2RlX21vZHVsZXMvYWlyYm5iLXByb3AtdHlwZXMvaW5kZXguanNcbnZhciByZXF1aXJlX2FpcmJuYl9wcm9wX3R5cGVzID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vYWlyYm5iLXByb3AtdHlwZXMtdmlydHVhbC0yZGJhY2Q0MTJiLzAvY2FjaGUvYWlyYm5iLXByb3AtdHlwZXMtbnBtLTIuMTYuMC1kNzk0ZjUyNzFjLTM5M2E1OTg4YjkuemlwL25vZGVfbW9kdWxlcy9haXJibmItcHJvcC10eXBlcy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmYWxzZSA/IG51bGwgOiByZXF1aXJlX2J1aWxkMigpO1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvY29uc29saWRhdGVkLWV2ZW50cy1ucG0tMi4wLjItNGExMjcwMDZjNi0zZmZiOWZhMjY0LnppcC9ub2RlX21vZHVsZXMvY29uc29saWRhdGVkLWV2ZW50cy9saWIvaW5kZXguanNcbnZhciByZXF1aXJlX2xpYiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2NvbnNvbGlkYXRlZC1ldmVudHMtbnBtLTIuMC4yLTRhMTI3MDA2YzYtM2ZmYjlmYTI2NC56aXAvbm9kZV9tb2R1bGVzL2NvbnNvbGlkYXRlZC1ldmVudHMvbGliL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB2YXIgQ0FOX1VTRV9ET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG4gICAgZnVuY3Rpb24gdGVzdFBhc3NpdmVFdmVudExpc3RlbmVycygpIHtcbiAgICAgIGlmICghQ0FOX1VTRV9ET00pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCAhd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgfHwgIU9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldDtcbiAgICAgICAgICB9KClcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gbm9vcDIoKSB7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVFdmVudFN1cHBvcnRcIiwgbm9vcCwgb3B0cyk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVFdmVudFN1cHBvcnRcIiwgbm9vcCwgb3B0cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xuICAgIH1cbiAgICB2YXIgbWVtb2l6ZWQgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gY2FuVXNlUGFzc2l2ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgaWYgKG1lbW9pemVkID09PSB2b2lkIDApIHtcbiAgICAgICAgbWVtb2l6ZWQgPSB0ZXN0UGFzc2l2ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50T3B0aW9ucyhldmVudE9wdGlvbnMpIHtcbiAgICAgIGlmICghZXZlbnRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAoIWNhblVzZVBhc3NpdmVFdmVudExpc3RlbmVycygpKSB7XG4gICAgICAgIHJldHVybiAhIWV2ZW50T3B0aW9ucy5jYXB0dXJlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50T3B0aW9ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gZXZlbnRPcHRpb25zS2V5KG5vcm1hbGl6ZWRFdmVudE9wdGlvbnMpIHtcbiAgICAgIGlmICghbm9ybWFsaXplZEV2ZW50T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChub3JtYWxpemVkRXZlbnRPcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAxMDA7XG4gICAgICB9XG4gICAgICB2YXIgY2FwdHVyZSA9IG5vcm1hbGl6ZWRFdmVudE9wdGlvbnMuY2FwdHVyZSA8PCAwO1xuICAgICAgdmFyIHBhc3NpdmUgPSBub3JtYWxpemVkRXZlbnRPcHRpb25zLnBhc3NpdmUgPDwgMTtcbiAgICAgIHZhciBvbmNlID0gbm9ybWFsaXplZEV2ZW50T3B0aW9ucy5vbmNlIDw8IDI7XG4gICAgICByZXR1cm4gY2FwdHVyZSArIHBhc3NpdmUgKyBvbmNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0RXZlbnRIYW5kbGVycyhldmVudEhhbmRsZXJzKSB7XG4gICAgICBpZiAoZXZlbnRIYW5kbGVycy5oYW5kbGVycyA9PT0gZXZlbnRIYW5kbGVycy5uZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVycy5uZXh0SGFuZGxlcnMgPSBldmVudEhhbmRsZXJzLmhhbmRsZXJzLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRhcmdldEV2ZW50SGFuZGxlcnModGFyZ2V0KSB7XG4gICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgfVxuICAgIFRhcmdldEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLmdldEV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlcnMoZXZlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBrZXkgPSBTdHJpbmcoZXZlbnROYW1lKSArIFwiIFwiICsgU3RyaW5nKGV2ZW50T3B0aW9uc0tleShvcHRpb25zKSk7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHNba2V5XSkge1xuICAgICAgICAgIHRoaXMuZXZlbnRzW2tleV0gPSB7XG4gICAgICAgICAgICBoYW5kbGVyczogW10sXG4gICAgICAgICAgICBoYW5kbGVFdmVudDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmV2ZW50c1trZXldLm5leHRIYW5kbGVycyA9IHRoaXMuZXZlbnRzW2tleV0uaGFuZGxlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RXZlbnRIYW5kbGVycztcbiAgICB9KCk7XG4gICAgVGFyZ2V0RXZlbnRIYW5kbGVycy5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50TmFtZSwgb3B0aW9ucywgZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmdldEV2ZW50SGFuZGxlcnMoZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgZXZlbnRIYW5kbGVycy5oYW5kbGVycyA9IGV2ZW50SGFuZGxlcnMubmV4dEhhbmRsZXJzO1xuICAgICAgICBldmVudEhhbmRsZXJzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZUV2ZW50O1xuICAgIH0oKTtcbiAgICBUYXJnZXRFdmVudEhhbmRsZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5nZXRFdmVudEhhbmRsZXJzKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRFdmVudEhhbmRsZXJzKGV2ZW50SGFuZGxlcnMpO1xuICAgICAgICBpZiAoZXZlbnRIYW5kbGVycy5uZXh0SGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXZlbnRIYW5kbGVycy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzLCBldmVudE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXJzLmhhbmRsZUV2ZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEhhbmRsZXJzLm5leHRIYW5kbGVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlMigpIHtcbiAgICAgICAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dEV2ZW50SGFuZGxlcnMoZXZlbnRIYW5kbGVycyk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBldmVudEhhbmRsZXJzLm5leHRIYW5kbGVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMubmV4dEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycy5uZXh0SGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcnMuaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuaGFuZGxlRXZlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bnN1YnNjcmliZTI7XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZDtcbiAgICB9KCk7XG4gICAgdmFyIEVWRU5UX0hBTkRMRVJTX0tFWSA9IFwiX19jb25zb2xpZGF0ZWRfZXZlbnRzX2hhbmRsZXJzX19cIjtcbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgaWYgKCF0YXJnZXRbRVZFTlRfSEFORExFUlNfS0VZXSkge1xuICAgICAgICB0YXJnZXRbRVZFTlRfSEFORExFUlNfS0VZXSA9IG5ldyBUYXJnZXRFdmVudEhhbmRsZXJzKHRhcmdldCk7XG4gICAgICB9XG4gICAgICB2YXIgbm9ybWFsaXplZEV2ZW50T3B0aW9ucyA9IG5vcm1hbGl6ZUV2ZW50T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0YXJnZXRbRVZFTlRfSEFORExFUlNfS0VZXS5hZGQoZXZlbnROYW1lLCBsaXN0ZW5lciwgbm9ybWFsaXplZEV2ZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QudmFsdWVzLW5wbS0xLjEuNS1mMWRlN2YzNzQyLTBmMTdlOTk3NDEuemlwL25vZGVfbW9kdWxlcy9vYmplY3QudmFsdWVzL2ltcGxlbWVudGF0aW9uLmpzXG52YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjggPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QudmFsdWVzLW5wbS0xLjEuNS1mMWRlN2YzNzQyLTBmMTdlOTk3NDEuemlwL25vZGVfbW9kdWxlcy9vYmplY3QudmFsdWVzL2ltcGxlbWVudGF0aW9uLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZV9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCk7XG4gICAgdmFyIGNhbGxCb3VuZCA9IHJlcXVpcmVfY2FsbEJvdW5kKCk7XG4gICAgdmFyICRpc0VudW1lcmFibGUgPSBjYWxsQm91bmQoXCJPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXCIpO1xuICAgIHZhciAkcHVzaCA9IGNhbGxCb3VuZChcIkFycmF5LnByb3RvdHlwZS5wdXNoXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbHVlcyhPKSB7XG4gICAgICB2YXIgb2JqID0gUmVxdWlyZU9iamVjdENvZXJjaWJsZShPKTtcbiAgICAgIHZhciB2YWxzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICgkaXNFbnVtZXJhYmxlKG9iaiwga2V5KSkge1xuICAgICAgICAgICRwdXNoKHZhbHMsIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHM7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC52YWx1ZXMtbnBtLTEuMS41LWYxZGU3ZjM3NDItMGYxN2U5OTc0MS56aXAvbm9kZV9tb2R1bGVzL29iamVjdC52YWx1ZXMvcG9seWZpbGwuanNcbnZhciByZXF1aXJlX3BvbHlmaWxsNiA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL29iamVjdC52YWx1ZXMtbnBtLTEuMS41LWYxZGU3ZjM3NDItMGYxN2U5OTc0MS56aXAvbm9kZV9tb2R1bGVzL29iamVjdC52YWx1ZXMvcG9seWZpbGwuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjgoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgT2JqZWN0LnZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LnZhbHVlcyA6IGltcGxlbWVudGF0aW9uO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QudmFsdWVzLW5wbS0xLjEuNS1mMWRlN2YzNzQyLTBmMTdlOTk3NDEuemlwL25vZGVfbW9kdWxlcy9vYmplY3QudmFsdWVzL3NoaW0uanNcbnZhciByZXF1aXJlX3NoaW02ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LnZhbHVlcy1ucG0tMS4xLjUtZjFkZTdmMzc0Mi0wZjE3ZTk5NzQxLnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LnZhbHVlcy9zaGltLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmVfcG9seWZpbGw2KCk7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnRpZXMoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltVmFsdWVzKCkge1xuICAgICAgdmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcbiAgICAgIGRlZmluZShPYmplY3QsIHsgdmFsdWVzOiBwb2x5ZmlsbCB9LCB7XG4gICAgICAgIHZhbHVlczogZnVuY3Rpb24gdGVzdFZhbHVlcygpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyAhPT0gcG9seWZpbGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvbHlmaWxsO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9vYmplY3QudmFsdWVzLW5wbS0xLjEuNS1mMWRlN2YzNzQyLTBmMTdlOTk3NDEuemlwL25vZGVfbW9kdWxlcy9vYmplY3QudmFsdWVzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9vYmplY3Q0ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvb2JqZWN0LnZhbHVlcy1ucG0tMS4xLjUtZjFkZTdmMzc0Mi0wZjE3ZTk5NzQxLnppcC9ub2RlX21vZHVsZXMvb2JqZWN0LnZhbHVlcy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydGllcygpO1xuICAgIHZhciBjYWxsQmluZCA9IHJlcXVpcmVfY2FsbF9iaW5kKCk7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjgoKTtcbiAgICB2YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlX3BvbHlmaWxsNigpO1xuICAgIHZhciBzaGltID0gcmVxdWlyZV9zaGltNigpO1xuICAgIHZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE9iamVjdCk7XG4gICAgZGVmaW5lKHBvbHlmaWxsLCB7XG4gICAgICBnZXRQb2x5ZmlsbCxcbiAgICAgIGltcGxlbWVudGF0aW9uLFxuICAgICAgc2hpbVxuICAgIH0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBvbHlmaWxsO1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZG9jdW1lbnQuY29udGFpbnMtbnBtLTEuMC4yLWIxODY3OTk2MDctZGJiOGMxZjZlYy56aXAvbm9kZV9tb2R1bGVzL2RvY3VtZW50LmNvbnRhaW5zL2ltcGxlbWVudGF0aW9uLmpzXG52YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjkgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9kb2N1bWVudC5jb250YWlucy1ucG0tMS4wLjItYjE4Njc5OTYwNy1kYmI4YzFmNmVjLnppcC9ub2RlX21vZHVsZXMvZG9jdW1lbnQuY29udGFpbnMvaW1wbGVtZW50YXRpb24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gY29udGFpbnMob3RoZXIpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IDEgKFxcdTIwMURvdGhlclxcdTIwMUMpIHRvIE5vZGUuY29udGFpbnMgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSBvdGhlcjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG5vZGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9kb2N1bWVudC5jb250YWlucy1ucG0tMS4wLjItYjE4Njc5OTYwNy1kYmI4YzFmNmVjLnppcC9ub2RlX21vZHVsZXMvZG9jdW1lbnQuY29udGFpbnMvcG9seWZpbGwuanNcbnZhciByZXF1aXJlX3BvbHlmaWxsNyA9IF9fY29tbW9uSlMoe1xuICBcInBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL2NhY2hlL2RvY3VtZW50LmNvbnRhaW5zLW5wbS0xLjAuMi1iMTg2Nzk5NjA3LWRiYjhjMWY2ZWMuemlwL25vZGVfbW9kdWxlcy9kb2N1bWVudC5jb250YWlucy9wb2x5ZmlsbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlX2ltcGxlbWVudGF0aW9uOSgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoZG9jdW1lbnQuY29udGFpbnMpIHtcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuY29udGFpbnMuY2FsbChkb2N1bWVudCwgXCJcIikgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZG9jdW1lbnQuY29udGFpbnMtbnBtLTEuMC4yLWIxODY3OTk2MDctZGJiOGMxZjZlYy56aXAvbm9kZV9tb2R1bGVzL2RvY3VtZW50LmNvbnRhaW5zL3NoaW0uanNcbnZhciByZXF1aXJlX3NoaW03ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZG9jdW1lbnQuY29udGFpbnMtbnBtLTEuMC4yLWIxODY3OTk2MDctZGJiOGMxZjZlYy56aXAvbm9kZV9tb2R1bGVzL2RvY3VtZW50LmNvbnRhaW5zL3NoaW0uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnRpZXMoKTtcbiAgICB2YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlX3BvbHlmaWxsNygpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1Db250YWlucygpIHtcbiAgICAgIHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRlZmluZShkb2N1bWVudCwgeyBjb250YWluczogcG9seWZpbGwgfSwgeyBjb250YWluczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNvbnRhaW5zICE9PSBwb2x5ZmlsbDtcbiAgICAgICAgfSB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgZGVmaW5lKEVsZW1lbnQucHJvdG90eXBlLCB7IGNvbnRhaW5zOiBwb2x5ZmlsbCB9LCB7IGNvbnRhaW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5jb250YWlucyAhPT0gcG9seWZpbGw7XG4gICAgICAgICAgfSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvbHlmaWxsO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9jYWNoZS9kb2N1bWVudC5jb250YWlucy1ucG0tMS4wLjItYjE4Njc5OTYwNy1kYmI4YzFmNmVjLnppcC9ub2RlX21vZHVsZXMvZG9jdW1lbnQuY29udGFpbnMvaW5kZXguanNcbnZhciByZXF1aXJlX2RvY3VtZW50ID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vY2FjaGUvZG9jdW1lbnQuY29udGFpbnMtbnBtLTEuMC4yLWIxODY3OTk2MDctZGJiOGMxZjZlYy56aXAvbm9kZV9tb2R1bGVzL2RvY3VtZW50LmNvbnRhaW5zL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzKCk7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbjkoKTtcbiAgICB2YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlX3BvbHlmaWxsNygpO1xuICAgIHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG4gICAgdmFyIHNoaW0gPSByZXF1aXJlX3NoaW03KCk7XG4gICAgdmFyIGJvdW5kQ29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhub2RlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsLmFwcGx5KG5vZGUsIFtvdGhlcl0pO1xuICAgIH07XG4gICAgZGVmaW5lKGJvdW5kQ29udGFpbnMsIHtcbiAgICAgIGdldFBvbHlmaWxsLFxuICAgICAgaW1wbGVtZW50YXRpb24sXG4gICAgICBzaGltXG4gICAgfSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gYm91bmRDb250YWlucztcbiAgfVxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LW91dHNpZGUtY2xpY2staGFuZGxlci12aXJ0dWFsLTdiZGRjYWI0NTgvMC9jYWNoZS9yZWFjdC1vdXRzaWRlLWNsaWNrLWhhbmRsZXItbnBtLTEuMy4wLTdmYTBkMTk2YTMtYzNhZmMzY2UxYy56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LW91dHNpZGUtY2xpY2staGFuZGxlci9idWlsZC9PdXRzaWRlQ2xpY2tIYW5kbGVyLmpzXG52YXIgcmVxdWlyZV9PdXRzaWRlQ2xpY2tIYW5kbGVyID0gX19jb21tb25KUyh7XG4gIFwicG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vcmVhY3Qtb3V0c2lkZS1jbGljay1oYW5kbGVyLXZpcnR1YWwtN2JkZGNhYjQ1OC8wL2NhY2hlL3JlYWN0LW91dHNpZGUtY2xpY2staGFuZGxlci1ucG0tMS4zLjAtN2ZhMGQxOTZhMy1jM2FmYzNjZTFjLnppcC9ub2RlX21vZHVsZXMvcmVhY3Qtb3V0c2lkZS1jbGljay1oYW5kbGVyL2J1aWxkL091dHNpZGVDbGlja0hhbmRsZXIuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcilcbiAgICAgICAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICBpZiAocHJvdG9Qcm9wcylcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIGlmIChzdGF0aWNQcm9wcylcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgIH07XG4gICAgfSgpO1xuICAgIHZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG4gICAgdmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG4gICAgdmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlX3Byb3BfdHlwZXMoKTtcbiAgICB2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuICAgIHZhciBfYWlyYm5iUHJvcFR5cGVzID0gcmVxdWlyZV9haXJibmJfcHJvcF90eXBlcygpO1xuICAgIHZhciBfY29uc29saWRhdGVkRXZlbnRzID0gcmVxdWlyZV9saWIoKTtcbiAgICB2YXIgX29iamVjdCA9IHJlcXVpcmVfb2JqZWN0NCgpO1xuICAgIHZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG4gICAgdmFyIF9kb2N1bWVudCA9IHJlcXVpcmVfZG9jdW1lbnQoKTtcbiAgICB2YXIgX2RvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvY3VtZW50KTtcbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgICBpZiAoIXNlbGYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgIH1cbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7XG4gICAgICBpZiAoc3VwZXJDbGFzcylcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gICAgfVxuICAgIHZhciBESVNQTEFZID0ge1xuICAgICAgQkxPQ0s6IFwiYmxvY2tcIixcbiAgICAgIEZMRVg6IFwiZmxleFwiLFxuICAgICAgSU5MSU5FOiBcImlubGluZVwiLFxuICAgICAgSU5MSU5FX0JMT0NLOiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgQ09OVEVOVFM6IFwiY29udGVudHNcIlxuICAgIH07XG4gICAgdmFyIHByb3BUeXBlcyA9ICgwLCBfYWlyYm5iUHJvcFR5cGVzLmZvcmJpZEV4dHJhUHJvcHMpKHtcbiAgICAgIGNoaWxkcmVuOiBfcHJvcFR5cGVzMltcImRlZmF1bHRcIl0ubm9kZS5pc1JlcXVpcmVkLFxuICAgICAgb25PdXRzaWRlQ2xpY2s6IF9wcm9wVHlwZXMyW1wiZGVmYXVsdFwiXS5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBkaXNhYmxlZDogX3Byb3BUeXBlczJbXCJkZWZhdWx0XCJdLmJvb2wsXG4gICAgICB1c2VDYXB0dXJlOiBfcHJvcFR5cGVzMltcImRlZmF1bHRcIl0uYm9vbCxcbiAgICAgIGRpc3BsYXk6IF9wcm9wVHlwZXMyW1wiZGVmYXVsdFwiXS5vbmVPZigoMCwgX29iamVjdDJbXCJkZWZhdWx0XCJdKShESVNQTEFZKSlcbiAgICB9KTtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0ge1xuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgdXNlQ2FwdHVyZTogdHJ1ZSxcbiAgICAgIGRpc3BsYXk6IERJU1BMQVkuQkxPQ0tcbiAgICB9O1xuICAgIHZhciBPdXRzaWRlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oX1JlYWN0JENvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKE91dHNpZGVDbGlja0hhbmRsZXIyLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgICAgIGZ1bmN0aW9uIE91dHNpZGVDbGlja0hhbmRsZXIyKCkge1xuICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE91dHNpZGVDbGlja0hhbmRsZXIyKTtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gT3V0c2lkZUNsaWNrSGFuZGxlcjIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPdXRzaWRlQ2xpY2tIYW5kbGVyMikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpO1xuICAgICAgICBfdGhpcy5vbk1vdXNlRG93biA9IF90aGlzLm9uTW91c2VEb3duLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbk1vdXNlVXAgPSBfdGhpcy5vbk1vdXNlVXAuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLnNldENoaWxkTm9kZVJlZiA9IF90aGlzLnNldENoaWxkTm9kZVJlZi5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuICAgICAgX2NyZWF0ZUNsYXNzKE91dHNpZGVDbGlja0hhbmRsZXIyLCBbe1xuICAgICAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsIGRpc2FibGVkID0gX3Byb3BzLmRpc2FibGVkLCB1c2VDYXB0dXJlID0gX3Byb3BzLnVzZUNhcHR1cmU7XG4gICAgICAgICAgICBpZiAoIWRpc2FibGVkKVxuICAgICAgICAgICAgICB0aGlzLmFkZE1vdXNlRG93bkV2ZW50TGlzdGVuZXIodXNlQ2FwdHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21wb25lbnREaWRNb3VudDtcbiAgICAgICAgfSgpXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShfcmVmMikge1xuICAgICAgICAgICAgdmFyIHByZXZEaXNhYmxlZCA9IF9yZWYyLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLCBkaXNhYmxlZCA9IF9wcm9wczIuZGlzYWJsZWQsIHVzZUNhcHR1cmUgPSBfcHJvcHMyLnVzZUNhcHR1cmU7XG4gICAgICAgICAgICBpZiAocHJldkRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xuICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNb3VzZURvd25FdmVudExpc3RlbmVyKHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21wb25lbnREaWRVcGRhdGU7XG4gICAgICAgIH0oKVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgIH0oKVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwib25Nb3VzZURvd25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgICAgIHZhciB1c2VDYXB0dXJlID0gdGhpcy5wcm9wcy51c2VDYXB0dXJlO1xuICAgICAgICAgICAgdmFyIGlzRGVzY2VuZGFudE9mUm9vdCA9IHRoaXMuY2hpbGROb2RlICYmICgwLCBfZG9jdW1lbnQyW1wiZGVmYXVsdFwiXSkodGhpcy5jaGlsZE5vZGUsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaXNEZXNjZW5kYW50T2ZSb290KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZU1vdXNlVXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1vdXNlVXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1vdXNlVXAgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlTW91c2VVcCA9ICgwLCBfY29uc29saWRhdGVkRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIpKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXAsIHsgY2FwdHVyZTogdXNlQ2FwdHVyZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9uTW91c2VEb3duO1xuICAgICAgICB9KClcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm9uTW91c2VVcFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgICAgIHZhciBvbk91dHNpZGVDbGljayA9IHRoaXMucHJvcHMub25PdXRzaWRlQ2xpY2s7XG4gICAgICAgICAgICB2YXIgaXNEZXNjZW5kYW50T2ZSb290ID0gdGhpcy5jaGlsZE5vZGUgJiYgKDAsIF9kb2N1bWVudDJbXCJkZWZhdWx0XCJdKSh0aGlzLmNoaWxkTm9kZSwgZS50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlTW91c2VVcCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1vdXNlVXAoKTtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNb3VzZVVwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNEZXNjZW5kYW50T2ZSb290KSB7XG4gICAgICAgICAgICAgIG9uT3V0c2lkZUNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb25Nb3VzZVVwO1xuICAgICAgICB9KClcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldENoaWxkTm9kZVJlZlwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gc2V0Q2hpbGROb2RlUmVmKHJlZikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGUgPSByZWY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZXRDaGlsZE5vZGVSZWY7XG4gICAgICAgIH0oKVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiYWRkTW91c2VEb3duRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gYWRkTW91c2VEb3duRXZlbnRMaXN0ZW5lcih1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1vdXNlRG93biA9ICgwLCBfY29uc29saWRhdGVkRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIpKGRvY3VtZW50LCBcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLCB7IGNhcHR1cmU6IHVzZUNhcHR1cmUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhZGRNb3VzZURvd25FdmVudExpc3RlbmVyO1xuICAgICAgICB9KClcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZU1vdXNlRG93bilcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNb3VzZURvd24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZU1vdXNlVXApXG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlTW91c2VVcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG4gICAgICAgIH0oKVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHMsIGNoaWxkcmVuID0gX3Byb3BzMy5jaGlsZHJlbiwgZGlzcGxheSA9IF9wcm9wczMuZGlzcGxheTtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgcmVmOiB0aGlzLnNldENoaWxkTm9kZVJlZixcbiAgICAgICAgICAgICAgc3R5bGU6IGRpc3BsYXkgIT09IERJU1BMQVkuQkxPQ0sgJiYgKDAsIF9vYmplY3QyW1wiZGVmYXVsdFwiXSkoRElTUExBWSkuaW5jbHVkZXMoZGlzcGxheSkgPyB7IGRpc3BsYXkgfSA6IHZvaWQgMFxuICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVuZGVyO1xuICAgICAgICB9KClcbiAgICAgIH1dKTtcbiAgICAgIHJldHVybiBPdXRzaWRlQ2xpY2tIYW5kbGVyMjtcbiAgICB9KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBPdXRzaWRlQ2xpY2tIYW5kbGVyO1xuICAgIE91dHNpZGVDbGlja0hhbmRsZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuICAgIE91dHNpZGVDbGlja0hhbmRsZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuICB9XG59KTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvLnlhcm4vX192aXJ0dWFsX18vcmVhY3Qtb3V0c2lkZS1jbGljay1oYW5kbGVyLXZpcnR1YWwtN2JkZGNhYjQ1OC8wL2NhY2hlL3JlYWN0LW91dHNpZGUtY2xpY2staGFuZGxlci1ucG0tMS4zLjAtN2ZhMGQxOTZhMy1jM2FmYzNjZTFjLnppcC9ub2RlX21vZHVsZXMvcmVhY3Qtb3V0c2lkZS1jbGljay1oYW5kbGVyL2luZGV4LmpzXG52YXIgcmVxdWlyZV9yZWFjdF9vdXRzaWRlX2NsaWNrX2hhbmRsZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1vdXRzaWRlLWNsaWNrLWhhbmRsZXItdmlydHVhbC03YmRkY2FiNDU4LzAvY2FjaGUvcmVhY3Qtb3V0c2lkZS1jbGljay1oYW5kbGVyLW5wbS0xLjMuMC03ZmEwZDE5NmEzLWMzYWZjM2NlMWMuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1vdXRzaWRlLWNsaWNrLWhhbmRsZXIvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9PdXRzaWRlQ2xpY2tIYW5kbGVyKCk7XG4gIH1cbn0pO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9wYWNrYWdlcy91aS9zcmMvaW5kZXgudHNcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgQm9keTE6ICgpID0+IEJvZHkxLFxuICBCb2R5MjogKCkgPT4gQm9keTIsXG4gIEJvZHkzOiAoKSA9PiBCb2R5MyxcbiAgQm90dG9uOiAoKSA9PiBCb3R0b24sXG4gIEJ1dHRvbjogKCkgPT4gQnV0dG9uLFxuICBCdXR0b25FbGVtZW50OiAoKSA9PiBCdXR0b25FbGVtZW50LFxuICBDYXB0aW9uOiAoKSA9PiBDYXB0aW9uLFxuICBTZWxlY3Q6ICgpID0+IFNlbGVjdCxcbiAgU3VidGl0bGUxOiAoKSA9PiBTdWJ0aXRsZTEsXG4gIFN1YnRpdGxlMjogKCkgPT4gU3VidGl0bGUyLFxuICBTdWJ0aXRsZTM6ICgpID0+IFN1YnRpdGxlMyxcbiAgU3VidGl0bGU0OiAoKSA9PiBTdWJ0aXRsZTQsXG4gIFN3aXRjaEJ1dHRvbjogKCkgPT4gU3dpdGNoQnV0dG9uLFxuICBUaXRsZTE6ICgpID0+IFRpdGxlMSxcbiAgVGl0bGUyOiAoKSA9PiBUaXRsZTIsXG4gIFRpdGxlMzogKCkgPT4gVGl0bGUzLFxuICBUb2dnbGVCdXR0b246ICgpID0+IFRvZ2dsZUJ1dHRvblxufSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL0J1dHRvbi9pbmRleC50c3hcbnZhciBpbXBvcnRfcmVhY3QxNiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBpbXBvcnRfc3R5bGVkMiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkBlbW90aW9uL3N0eWxlZFwiKSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL3R5cG9ncmFwaHkvVGl0bGUxLnRzeFxudmFyIGltcG9ydF9yZWFjdDMgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL3R5cG9ncmFwaHkvQmFzZVR5cG9ncmFwaHkvaW5kZXgudHN4XG52YXIgaW1wb3J0X3JlYWN0MiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBpbXBvcnRfc3R5bGVkID0gX190b01vZHVsZShyZXF1aXJlKFwiQGVtb3Rpb24vc3R5bGVkXCIpKTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9CYXNlVHlwb2dyYXBoeS90ZXh0U3R5bGVzLnRzXG52YXIgaW1wb3J0X3JlYWN0ID0gX190b01vZHVsZShyZXF1aXJlKFwiQGVtb3Rpb24vcmVhY3RcIikpO1xudmFyIHRpdGxlMSA9IGltcG9ydF9yZWFjdC5jc3NgXG4gICAgZm9udC1zaXplOiA0MHB4O1xuICAgIGxpbmUtaGVpZ2h0OiA2MHB4O1xuYDtcbnZhciB0aXRsZTIgPSBpbXBvcnRfcmVhY3QuY3NzYFxuICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICBsaW5lLWhlaWdodDogNTRweDtcbmA7XG52YXIgdGl0bGUzID0gaW1wb3J0X3JlYWN0LmNzc2BcbiAgICBmb250LXNpemU6IDMycHg7XG4gICAgbGluZS1oZWlnaHQ6IDQ4cHg7XG5gO1xudmFyIHN1YnRpdGxlMSA9IGltcG9ydF9yZWFjdC5jc3NgXG4gICAgZm9udC1zaXplOiAzMnB4O1xuICAgIGxpbmUtaGVpZ2h0OiA0OHB4O1xuYDtcbnZhciBzdWJ0aXRsZTIgPSBpbXBvcnRfcmVhY3QuY3NzYFxuICAgIGZvbnQtc2l6ZTogMjhweDtcbiAgICBsaW5lLWhlaWdodDogMzJweDtcbmA7XG52YXIgc3VidGl0bGUzID0gaW1wb3J0X3JlYWN0LmNzc2BcbiAgICBmb250LXNpemU6IDI0cHg7ICBcbiAgICBsaW5lLWhlaWdodDogMzZweDtcbmA7XG52YXIgc3VidGl0bGU0ID0gaW1wb3J0X3JlYWN0LmNzc2BcbiAgICBmb250LXNpemU6IDIwcHg7XG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XG5gO1xudmFyIGJvZHkxID0gaW1wb3J0X3JlYWN0LmNzc2BcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDI0cHg7XG5gO1xudmFyIGJvZHkyID0gaW1wb3J0X3JlYWN0LmNzc2BcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG5gO1xudmFyIGJvZHkzID0gaW1wb3J0X3JlYWN0LmNzc2BcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG5gO1xudmFyIGJvdHRvbiA9IGltcG9ydF9yZWFjdC5jc3NgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuYDtcbnZhciBjYXB0aW9uID0gaW1wb3J0X3JlYWN0LmNzc2BcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG5gO1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9wYWNrYWdlcy91aS9zcmMvY29tcG9uZW50cy90eXBvZ3JhcGh5L0Jhc2VUeXBvZ3JhcGh5L2luZGV4LnRzeFxudmFyIGRlZmF1bHRFbGVtZW50ID0ge1xuICBUaXRsZTE6IFwiaDFcIixcbiAgVGl0bGUyOiBcImgyXCIsXG4gIFRpdGxlMzogXCJoM1wiLFxuICBTdWJ0aXRsZTE6IFwiaDRcIixcbiAgU3VidGl0bGUyOiBcImg1XCIsXG4gIFN1YnRpdGxlMzogXCJoNlwiLFxuICBTdWJ0aXRsZTQ6IFwiaDZcIixcbiAgQm9keTE6IFwicFwiLFxuICBCb2R5MjogXCJwXCIsXG4gIEJvZHkzOiBcInBcIixcbiAgQ2FwdGlvbjogXCJkaXZcIixcbiAgQm90dG9uOiBcImRpdlwiXG59O1xudmFyIGRlZmF1bHRXZWlnaHQgPSB7XG4gIFRpdGxlMTogXCJib2xkXCIsXG4gIFRpdGxlMjogXCJib2xkXCIsXG4gIFRpdGxlMzogXCJib2xkXCIsXG4gIFN1YnRpdGxlMTogXCJtZWRpdW1cIixcbiAgU3VidGl0bGUyOiBcIm1lZGl1bVwiLFxuICBTdWJ0aXRsZTM6IFwibWVkaXVtXCIsXG4gIFN1YnRpdGxlNDogXCJtZWRpdW1cIixcbiAgQm9keTE6IFwicmVndWxhclwiLFxuICBCb2R5MjogXCJyZWd1bGFyXCIsXG4gIEJvZHkzOiBcInJlZ3VsYXJcIixcbiAgQ2FwdGlvbjogXCJyZWd1bGFyXCIsXG4gIEJvdHRvbjogXCJyZWd1bGFyXCJcbn07XG52YXIgdHlwb2dyYXBoeUxpc3QgPSB7XG4gIFRpdGxlMTogdGl0bGUxLFxuICBUaXRsZTI6IHRpdGxlMixcbiAgVGl0bGUzOiB0aXRsZTMsXG4gIFN1YnRpdGxlMTogc3VidGl0bGUxLFxuICBTdWJ0aXRsZTI6IHN1YnRpdGxlMixcbiAgU3VidGl0bGUzOiBzdWJ0aXRsZTMsXG4gIFN1YnRpdGxlNDogc3VidGl0bGU0LFxuICBCb2R5MTogYm9keTEsXG4gIEJvZHkyOiBib2R5MixcbiAgQm9keTM6IGJvZHkzLFxuICBDYXB0aW9uOiBjYXB0aW9uLFxuICBCb3R0b246IGJvdHRvblxufTtcbnZhciBUZXh0RWxlbWVudCA9IGltcG9ydF9zdHlsZWQuZGVmYXVsdC5kaXZgXG4gICAgbWFyZ2luOiAwO1xuICAgIGNvbG9yOiAkeyh7IHRoZW1lLCBjb2xvciB9KSA9PiBjb2xvciA/IHRoZW1lLmNvbG9yc1tjb2xvcl0gOiB0aGVtZS5jb2xvcnMuYmxhY2t9O1xuICAgIGZvbnQtd2VpZ2h0OiAkeyh7IGZvbnRXZWlnaHQsIG1kLCB0aGVtZSB9KSA9PiBmb250V2VpZ2h0ID8gdGhlbWUuZm9udHMud2VpZ2h0W2ZvbnRXZWlnaHRdIDogdGhlbWUuZm9udHMud2VpZ2h0W2RlZmF1bHRXZWlnaHRbbWRdXX07XG4gICAgJHsocHJvcHMpID0+IHByb3BzLnRleHRBbGlnbiAmJiBgdGV4dC1hbGlnbjogJHtwcm9wcy50ZXh0QWxpZ259YH07XG4gICAgJHsocHJvcHMpID0+IHR5cG9ncmFwaHlMaXN0W3Byb3BzLm1kXX07XG5gO1xudmFyIEJhc2VUeXBvZ3JhcGh5ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIG1kLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBlbGVtZW50ID0gZGVmYXVsdEVsZW1lbnRbbWRdO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRleHRFbGVtZW50LCB7XG4gICAgbWQsXG4gICAgYXM6IGVsZW1lbnQsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL3R5cG9ncmFwaHkvVGl0bGUxLnRzeFxudmFyIFRpdGxlMSA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJhc2VUeXBvZ3JhcGh5LCB7XG4gICAgbWQ6IFwiVGl0bGUxXCIsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL3R5cG9ncmFwaHkvVGl0bGUyLnRzeFxudmFyIGltcG9ydF9yZWFjdDQgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgVGl0bGUyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0NC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQmFzZVR5cG9ncmFwaHksIHtcbiAgICBtZDogXCJUaXRsZTJcIixcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9UaXRsZTMudHN4XG52YXIgaW1wb3J0X3JlYWN0NSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBUaXRsZTMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3Q1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChCYXNlVHlwb2dyYXBoeSwge1xuICAgIG1kOiBcIlRpdGxlM1wiLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9wYWNrYWdlcy91aS9zcmMvY29tcG9uZW50cy90eXBvZ3JhcGh5L1N1YnRpdGxlMS50c3hcbnZhciBpbXBvcnRfcmVhY3Q2ID0gX190b01vZHVsZShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIFN1YnRpdGxlMSA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDYuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJhc2VUeXBvZ3JhcGh5LCB7XG4gICAgbWQ6IFwiU3VidGl0bGUxXCIsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL3R5cG9ncmFwaHkvU3VidGl0bGUyLnRzeFxudmFyIGltcG9ydF9yZWFjdDcgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgU3VidGl0bGUyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0Ny5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQmFzZVR5cG9ncmFwaHksIHtcbiAgICBtZDogXCJTdWJ0aXRsZTJcIixcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9TdWJ0aXRsZTMudHN4XG52YXIgaW1wb3J0X3JlYWN0OCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBTdWJ0aXRsZTMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3Q4LmRlZmF1bHQuY3JlYXRlRWxlbWVudChCYXNlVHlwb2dyYXBoeSwge1xuICAgIG1kOiBcIlN1YnRpdGxlM1wiLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9wYWNrYWdlcy91aS9zcmMvY29tcG9uZW50cy90eXBvZ3JhcGh5L1N1YnRpdGxlNC50c3hcbnZhciBpbXBvcnRfcmVhY3Q5ID0gX190b01vZHVsZShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIFN1YnRpdGxlNCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJhc2VUeXBvZ3JhcGh5LCB7XG4gICAgbWQ6IFwiU3VidGl0bGU0XCIsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL3R5cG9ncmFwaHkvQm9keTEudHN4XG52YXIgaW1wb3J0X3JlYWN0MTAgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgQm9keTEgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxMC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQmFzZVR5cG9ncmFwaHksIHtcbiAgICBtZDogXCJCb2R5MVwiLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9wYWNrYWdlcy91aS9zcmMvY29tcG9uZW50cy90eXBvZ3JhcGh5L0JvZHkyLnRzeFxudmFyIGltcG9ydF9yZWFjdDExID0gX190b01vZHVsZShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEJvZHkyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJhc2VUeXBvZ3JhcGh5LCB7XG4gICAgbWQ6IFwiQm9keTJcIixcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9Cb2R5My50c3hcbnZhciBpbXBvcnRfcmVhY3QxMiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBCb2R5MyA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDEyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChCYXNlVHlwb2dyYXBoeSwge1xuICAgIG1kOiBcIkJvZHkzXCIsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL3R5cG9ncmFwaHkvQm90dG9uLnRzeFxudmFyIGltcG9ydF9yZWFjdDEzID0gX190b01vZHVsZShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEJvdHRvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDEzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChCYXNlVHlwb2dyYXBoeSwge1xuICAgIG1kOiBcIkJvdHRvblwiLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9wYWNrYWdlcy91aS9zcmMvY29tcG9uZW50cy90eXBvZ3JhcGh5L0NhcHRpb24udHN4XG52YXIgaW1wb3J0X3JlYWN0MTQgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgQ2FwdGlvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDE0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChCYXNlVHlwb2dyYXBoeSwge1xuICAgIG1kOiBcIkNhcHRpb25cIixcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvQnV0dG9uL3R5cGVzLnRzXG52YXIgQ29sb3JzID0ge1xuICBkZWZhdWx0OiBcImdyYXk1MFwiLFxuICBwdXJwbGU6IFwicHVycGxlNDAwXCIsXG4gIHB1cnBsZUxpZ2h0OiBcInB1cnBsZTUwXCIsXG4gIGJvcmRlcjogXCJ3aGl0ZVwiLFxuICBib3JkZXJDb2xvcjogXCJncmF5MzAwXCIsXG4gIGxpbms6IFwid2hpdGVcIixcbiAgYm5EZWZhdWx0OiBcIndoaXRlXCIsXG4gIGJuUHVycGxlOiBcIndoaXRlXCJcbn07XG52YXIgQWN0aXZlQ29sb3JzID0ge1xuICBkZWZhdWx0OiBcImdyYXkyMDBcIixcbiAgcHVycGxlOiBcInB1cnBsZTUwMFwiLFxuICBwdXJwbGVMaWdodDogXCJwdXJwbGUxMDBcIixcbiAgYm9yZGVyOiBcImdyYXk1MFwiLFxuICBsaW5rOiBcIndoaXRlXCIsXG4gIGJuRGVmYXVsdDogXCJncmF5NTBcIixcbiAgYm5QdXJwbGU6IFwicHVycGxlNTBcIlxufTtcbnZhciBGb250Q29sb3JzID0ge1xuICBkZWZhdWx0OiBcImdyYXk3MDBcIixcbiAgcHVycGxlOiBcIndoaXRlXCIsXG4gIHB1cnBsZUxpZ2h0OiBcInB1cnBsZTQwMFwiLFxuICBib3JkZXI6IFwiZ3JheTcwMFwiLFxuICBsaW5rOiBcImJsdWU0MDBcIixcbiAgZnVsbDogXCJncmF5NzAwXCIsXG4gIGJuRGVmYXVsdDogXCJncmF5NzAwXCIsXG4gIGJuUHVycGxlOiBcInB1cnBsZTQwMFwiXG59O1xudmFyIERpc2FibGVkQ29sb3JzID0ge1xuICBkZWZhdWx0OiBcImdyYXk1MFwiLFxuICBwdXJwbGU6IFwicHVycGxlNTBcIixcbiAgcHVycGxlTGlnaHQ6IFwiZ3JheTUwXCIsXG4gIGJvcmRlcjogXCJncmF5NTBcIixcbiAgbGluazogXCJncmF5NTBcIixcbiAgYm5EZWZhdWx0OiBcImdyYXk1MFwiLFxuICBiblB1cnBsZTogXCJncmF5NTBcIlxufTtcbnZhciBEaXNhYmxlZEZvbnRDb2xvcnMgPSB7XG4gIGRlZmF1bHQ6IFwiZ3JheTMwMFwiLFxuICBwdXJwbGU6IFwid2hpdGVcIixcbiAgcHVycGxlTGlnaHQ6IFwiZ3JheTMwMFwiLFxuICBib3JkZXI6IFwiZ3JheTIwMFwiLFxuICBsaW5rOiBcImdyYXkzMDBcIixcbiAgYm5EZWZhdWx0OiBcImdyYXkzMDBcIixcbiAgYm5QdXJwbGU6IFwiZ3JheTMwMFwiXG59O1xuXG4vLyBwbnA6L2hvbWUvcnVubmVyL3dvcmsvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9wYWNrYWdlcy91aS9zcmMvY29tcG9uZW50cy9CdXR0b24vdXRpbHMudHNcbmZ1bmN0aW9uIGNvbG9yT2JqZWN0VG9Db2xvclN0cmluZyhjb2xvciwgYWRkZWRCbikge1xuICBpZiAodHlwZW9mIGNvbG9yID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBjb2xvciB8fCBcImRlZmF1bHRcIjtcbiAgZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiBcImRlZmF1bHRcIjtcbiAgZWxzZSBpZiAoYWRkZWRCbiAmJiBjb2xvci5iYWNrZ3JvdW5kID09PSBmYWxzZSkge1xuICAgIHN3aXRjaCAoY29sb3IuZmlsbFN0eWxlKSB7XG4gICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICByZXR1cm4gZmlyc3RDaGFyVG9UeXBlTWVzc2FnZShjb2xvci5maWxsU3R5bGUpO1xuICAgICAgY2FzZSBcInB1cnBsZVwiOlxuICAgICAgICByZXR1cm4gZmlyc3RDaGFyVG9UeXBlTWVzc2FnZShjb2xvci5maWxsU3R5bGUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNvbG9yLmZpbGxTdHlsZSB8fCBcImRlZmF1bHRcIjtcbiAgICB9XG4gIH0gZWxzZVxuICAgIHJldHVybiBjb2xvci5maWxsU3R5bGUgfHwgXCJkZWZhdWx0XCI7XG59XG5mdW5jdGlvbiBmaXJzdENoYXJUb1R5cGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFwiYm5cIiArIG1lc3NhZ2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtZXNzYWdlLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gaXNCYWNrZ3JvdW5kTm9uZShjb2xvcikge1xuICBpZiAoY29sb3IuaW5kZXhPZihcImJuXCIpICE9PSAtMSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgZWxzZVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbGxTdHlsZVRvQ29sb3JTdHJpbmcoZmlsbFN0eWxlLCBjb2xyb1N0YXRlKSB7XG4gIHN3aXRjaCAoY29scm9TdGF0ZSkge1xuICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICByZXR1cm4gQ29sb3JzW2ZpbGxTdHlsZV07XG4gICAgY2FzZSBcImFjdGl2ZVwiOlxuICAgICAgcmV0dXJuIEFjdGl2ZUNvbG9yc1tmaWxsU3R5bGVdO1xuICAgIGNhc2UgXCJmb250XCI6XG4gICAgICByZXR1cm4gRm9udENvbG9yc1tmaWxsU3R5bGVdO1xuICAgIGNhc2UgXCJkaWFibGVkXCI6XG4gICAgICByZXR1cm4gRGlzYWJsZWRDb2xvcnNbZmlsbFN0eWxlXTtcbiAgICBjYXNlIFwiZGlzYWJsZWRGb250XCI6XG4gICAgICByZXR1cm4gRGlzYWJsZWRGb250Q29sb3JzW2ZpbGxTdHlsZV07XG4gIH1cbn1cblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvQnV0dG9uL3N0eWxlcy50c1xudmFyIGltcG9ydF9yZWFjdDE1ID0gX190b01vZHVsZShyZXF1aXJlKFwiQGVtb3Rpb24vcmVhY3RcIikpO1xudmFyIGZ1bGwgPSAoKSA9PiBpbXBvcnRfcmVhY3QxNS5jc3NgXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGJvcmRlci1yYWRpdXM6IDA7XG5gO1xudmFyIGxpbmsgPSAocHJvcHMpID0+IGltcG9ydF9yZWFjdDE1LmNzc2BcbiAgICAmOmhvdmVyLFxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgMXB4IHNvbGlkICR7cHJvcHMudGhlbWUuY29sb3JzW3Byb3BzLmNvbG9yXX07XG4gICAgfVxuYDtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvQnV0dG9uL2luZGV4LnRzeFxudmFyIEN1cnNvcjtcbihmdW5jdGlvbihDdXJzb3IyKSB7XG4gIEN1cnNvcjJbXCJESVNBQkxFRFwiXSA9IFwibm90LWFsbG93ZWRcIjtcbiAgQ3Vyc29yMltcIkxPQURJTkdcIl0gPSBcInByb2dyZXNzXCI7XG4gIEN1cnNvcjJbXCJERUZBVUxUXCJdID0gXCJwb2ludGVyXCI7XG59KShDdXJzb3IgfHwgKEN1cnNvciA9IHt9KSk7XG52YXIgUGFkZGluZ1ZlcnRpY2FsO1xuKGZ1bmN0aW9uKFBhZGRpbmdWZXJ0aWNhbDIpIHtcbiAgUGFkZGluZ1ZlcnRpY2FsMltQYWRkaW5nVmVydGljYWwyW1wibGdcIl0gPSAxNl0gPSBcImxnXCI7XG4gIFBhZGRpbmdWZXJ0aWNhbDJbUGFkZGluZ1ZlcnRpY2FsMltcIm1kXCJdID0gMTZdID0gXCJtZFwiO1xuICBQYWRkaW5nVmVydGljYWwyW1BhZGRpbmdWZXJ0aWNhbDJbXCJzbVwiXSA9IDhdID0gXCJzbVwiO1xufSkoUGFkZGluZ1ZlcnRpY2FsIHx8IChQYWRkaW5nVmVydGljYWwgPSB7fSkpO1xudmFyIFBhZGRpbmdIb3Jpem9udGFsO1xuKGZ1bmN0aW9uKFBhZGRpbmdIb3Jpem9udGFsMikge1xuICBQYWRkaW5nSG9yaXpvbnRhbDJbUGFkZGluZ0hvcml6b250YWwyW1wibGdcIl0gPSAxNTBdID0gXCJsZ1wiO1xuICBQYWRkaW5nSG9yaXpvbnRhbDJbUGFkZGluZ0hvcml6b250YWwyW1wibWRcIl0gPSA2OF0gPSBcIm1kXCI7XG4gIFBhZGRpbmdIb3Jpem9udGFsMltQYWRkaW5nSG9yaXpvbnRhbDJbXCJzbVwiXSA9IDE2XSA9IFwic21cIjtcbn0pKFBhZGRpbmdIb3Jpem9udGFsIHx8IChQYWRkaW5nSG9yaXpvbnRhbCA9IHt9KSk7XG52YXIgQm9yZGVyUmFkaXVzO1xuKGZ1bmN0aW9uKEJvcmRlclJhZGl1czIpIHtcbiAgQm9yZGVyUmFkaXVzMltCb3JkZXJSYWRpdXMyW1wibGdcIl0gPSAxMl0gPSBcImxnXCI7XG4gIEJvcmRlclJhZGl1czJbQm9yZGVyUmFkaXVzMltcIm1kXCJdID0gMTJdID0gXCJtZFwiO1xuICBCb3JkZXJSYWRpdXMyW0JvcmRlclJhZGl1czJbXCJzbVwiXSA9IDRdID0gXCJzbVwiO1xufSkoQm9yZGVyUmFkaXVzIHx8IChCb3JkZXJSYWRpdXMgPSB7fSkpO1xudmFyIEJ1dHRvbkVsZW1lbnQgPSBpbXBvcnRfc3R5bGVkMi5kZWZhdWx0LmJ1dHRvbmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgY3Vyc29yOiAkeyhwcm9wcykgPT4gcHJvcHMuY3Vyc29yfTtcbiAgICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzW3Byb3BzLmJhY2tncm91bmRdfTtcbiAgICBwYWRkaW5nOiAkeyhwcm9wcykgPT4gYCR7cHJvcHMucGFkZGluZ1ZlcnRpY2FsfXB4ICR7cHJvcHMucGFkZGluZ0hvcml6b250YWx9cHhgfTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gcHJvcHMuYm9yZGVyUmFkaXVzfXB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnNbcHJvcHMuYm9yZGVyQ29sb3JdfTtcblxuICAgICR7KHByb3BzKSA9PiBwcm9wcy5mdWxsV2lkdGggJiYgZnVsbCgpfVxuXG4gICAgJHsocHJvcHMpID0+IHByb3BzLmZpbGxTdHlsZSA9PT0gXCJsaW5rXCIgJiYgbGluayhwcm9wcyl9XG4gICAgQG1lZGlhKGhvdmVyOiBob3Zlcikge1xuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnNbcHJvcHMuYWN0aXZlQmFja2dyb3VuZF19O1xuICAgICAgICB9XG4gICAgfVxuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgJjphY3RpdmUge1xuICAgICAgICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzW3Byb3BzLmFjdGl2ZUJhY2tncm91bmRdfTtcbiAgICB9XG5cbiAgICAmIC5zZW1pY29sb24tYnV0dG9uLXR5cG9ncmFwaHkge1xuICAgICAgICBtYXJnaW4tbGVmdDogJHsocHJvcHMpID0+IHByb3BzLm1hcmdpbkxlZnR9cHg7XG4gICAgICAgIG1hcmdpbi1yaWdodDogJHsocHJvcHMpID0+IHByb3BzLm1hcmdpblJpZ2h0fXB4O1xuICAgIH1cbmA7XG52YXIgQnV0dG9uID0gKHtcbiAgc2l6ZSA9IFwibWRcIixcbiAgZmlsbCA9IFwiZGVmYXVsdFwiLFxuICBsb2FkaW5nID0gZmFsc2UsXG4gIGRpc2FibGVkID0gZmFsc2UsXG4gIGxlZnRJY29uLFxuICByaWdodEljb24sXG4gIG9uQ2xpY2ssXG4gIGNsYXNzTmFtZSxcbiAgY2hpbGRyZW4sXG4gIGZ1bGxXaWR0aFxufSkgPT4ge1xuICBjb25zdCBjdXJzb3JUeXBlID0gZGlzYWJsZWQgPyBcIkRJU0FCTEVEXCIgOiBsb2FkaW5nID8gXCJMT0FESU5HXCIgOiBcIkRFRkFVTFRcIjtcbiAgY29uc3QgY29sb3JTdHJpbmcgPSBjb2xvck9iamVjdFRvQ29sb3JTdHJpbmcoZmlsbCwgdHJ1ZSk7XG4gIGNvbnN0IEJhY2tncm91bmRDb2xvciA9IGRpc2FibGVkID8gZmlsbFN0eWxlVG9Db2xvclN0cmluZyhjb2xvclN0cmluZywgXCJkaWFibGVkXCIpIDogZmlsbFN0eWxlVG9Db2xvclN0cmluZyhjb2xvclN0cmluZywgXCJkZWZhdWx0XCIpO1xuICBjb25zdCBCYWNrZ3JvdW5kQWN0aXZlQ29sb3IgPSBkaXNhYmxlZCA/IGZpbGxTdHlsZVRvQ29sb3JTdHJpbmcoY29sb3JTdHJpbmcsIFwiZGlhYmxlZFwiKSA6IGZpbGxTdHlsZVRvQ29sb3JTdHJpbmcoY29sb3JTdHJpbmcsIFwiYWN0aXZlXCIpO1xuICBjb25zdCBGb250Q29sb3IgPSBkaXNhYmxlZCA/IGZpbGxTdHlsZVRvQ29sb3JTdHJpbmcoY29sb3JTdHJpbmcsIFwiZGlzYWJsZWRGb250XCIpIDogZmlsbFN0eWxlVG9Db2xvclN0cmluZyhjb2xvclN0cmluZywgXCJmb250XCIpO1xuICBjb25zdCBzdHlsZWRQcm9wcyA9IHtcbiAgICBjdXJzb3I6IEN1cnNvcltjdXJzb3JUeXBlXSxcbiAgICBiYWNrZ3JvdW5kOiBCYWNrZ3JvdW5kQ29sb3IsXG4gICAgYWN0aXZlQmFja2dyb3VuZDogbG9hZGluZyAmJiBpc0JhY2tncm91bmROb25lKGNvbG9yU3RyaW5nKSA/IEJhY2tncm91bmRDb2xvciA6IEJhY2tncm91bmRBY3RpdmVDb2xvcixcbiAgICBwYWRkaW5nVmVydGljYWw6IFBhZGRpbmdWZXJ0aWNhbFtzaXplXSxcbiAgICBwYWRkaW5nSG9yaXpvbnRhbDogUGFkZGluZ0hvcml6b250YWxbc2l6ZV0sXG4gICAgYm9yZGVyUmFkaXVzOiBCb3JkZXJSYWRpdXNbc2l6ZV0sXG4gICAgYm9yZGVyQ29sb3I6IGNvbG9yU3RyaW5nID09PSBcImJvcmRlclwiID8gQ29sb3JzW1wiYm9yZGVyQ29sb3JcIl0gOiBCYWNrZ3JvdW5kQ29sb3IsXG4gICAgc2l6ZSxcbiAgICBmaWxsU3R5bGU6IGNvbG9yU3RyaW5nLFxuICAgIGNvbG9yOiBGb250Q29sb3IsXG4gICAgZnVsbFdpZHRoOiBCb29sZWFuKGZ1bGxXaWR0aCksXG4gICAgbWFyZ2luTGVmdDogbGVmdEljb24gPyA2IDogMCxcbiAgICBtYXJnaW5SaWdodDogbG9hZGluZyB8fCByaWdodEljb24gPyA2IDogMFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDE2LmRlZmF1bHQuY3JlYXRlRWxlbWVudChCdXR0b25FbGVtZW50LCB7XG4gICAgY2xhc3NOYW1lLFxuICAgIG9uQ2xpY2ssXG4gICAgZGlzYWJsZWQsXG4gICAgLi4uc3R5bGVkUHJvcHNcbiAgfSwgbGVmdEljb24sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxNi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQm90dG9uLCB7XG4gICAgY2xhc3NOYW1lOiBcInNlbWljb2xvbi1idXR0b24tdHlwb2dyYXBoeVwiLFxuICAgIGNvbG9yOiBGb250Q29sb3JcbiAgfSwgY2hpbGRyZW4pLCByaWdodEljb24pO1xufTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvU3dpdGNoQnV0dG9uLnRzeFxudmFyIGltcG9ydF9yZWFjdDE3ID0gX190b01vZHVsZShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGltcG9ydF9zdHlsZWQzID0gX190b01vZHVsZShyZXF1aXJlKFwiQGVtb3Rpb24vc3R5bGVkXCIpKTtcbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbihQb3NpdGlvbjIpIHtcbiAgUG9zaXRpb24yW1Bvc2l0aW9uMltcImZhbHNlXCJdID0gMV0gPSBcImZhbHNlXCI7XG4gIFBvc2l0aW9uMltQb3NpdGlvbjJbXCJ0cnVlXCJdID0gMjJdID0gXCJ0cnVlXCI7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xudmFyIEJhY2tncm91bmQ7XG4oZnVuY3Rpb24oQmFja2dyb3VuZDMpIHtcbiAgQmFja2dyb3VuZDNbXCJmYWxzZVwiXSA9IFwiZ3JheTEwMFwiO1xuICBCYWNrZ3JvdW5kM1tcInRydWVcIl0gPSBcInB1cnBsZTQwMFwiO1xufSkoQmFja2dyb3VuZCB8fCAoQmFja2dyb3VuZCA9IHt9KSk7XG52YXIgQnV0dG9uV3JhcHBlckVsZW1lbnQgPSBpbXBvcnRfc3R5bGVkMy5kZWZhdWx0LmRpdmBcbiAgICB3aWR0aDogNDBweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogMTFweDtcbiAgICBwYWRkaW5nOiAxcHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzW3Byb3BzLmJhY2tncm91bmRdfTtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMXMgbGluZWFyO1xuYDtcbnZhciBCdXR0b25DaXJjbGUgPSBpbXBvcnRfc3R5bGVkMy5kZWZhdWx0LmRpdmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDE4cHg7XG4gICAgaGVpZ2h0OiAxOHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICB0b3A6IDUwJTtcbiAgICBsZWZ0OiAwO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7KHByb3BzKSA9PiBwcm9wcy5wb3NpdGlvbn1weCwgLTUwJSk7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMDhzIGVhc2UtaW47XG5gO1xudmFyIFN3aXRjaEJ1dHRvbiA9ICh7IHZhbHVlID0gZmFsc2UsIG9uVG9nZ2xlIH0pID0+IHtcbiAgY29uc3QgW2lzQWN0aXZlLCBzZXRJc0FjdGl2ZV0gPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlU3RhdGUpKHZhbHVlKTtcbiAgY29uc3Qgb25DbGljayA9ICgpID0+IHtcbiAgICBzZXRJc0FjdGl2ZSgocHJldlN0YXRlKSA9PiAhcHJldlN0YXRlKTtcbiAgfTtcbiAgKDAsIGltcG9ydF9yZWFjdDE3LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmIChvblRvZ2dsZSlcbiAgICAgIG9uVG9nZ2xlKGlzQWN0aXZlKTtcbiAgfSwgW2lzQWN0aXZlXSk7XG4gIGNvbnN0IHN0eWxlZFByb3BzID0ge1xuICAgIGJhY2tncm91bmQ6IEJhY2tncm91bmRbaXNBY3RpdmUgPyBcInRydWVcIiA6IFwiZmFsc2VcIl0sXG4gICAgcG9zaXRpb246IFBvc2l0aW9uW2lzQWN0aXZlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJdXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTcuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJ1dHRvbldyYXBwZXJFbGVtZW50LCB7XG4gICAgb25DbGljayxcbiAgICBiYWNrZ3JvdW5kOiBzdHlsZWRQcm9wcy5iYWNrZ3JvdW5kXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxNy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uQ2lyY2xlLCB7XG4gICAgcG9zaXRpb246IHN0eWxlZFByb3BzLnBvc2l0aW9uXG4gIH0pKTtcbn07XG5cbi8vIHBucDovaG9tZS9ydW5uZXIvd29yay9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvU2VtaWNvbG9uRGVzaWduX0Zyb250ZW5kL3BhY2thZ2VzL3VpL3NyYy9jb21wb25lbnRzL1RvZ2dsZUJ1dHRvbi50c3hcbnZhciBpbXBvcnRfcmVhY3QxOCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBpbXBvcnRfc3R5bGVkNCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkBlbW90aW9uL3N0eWxlZFwiKSk7XG52YXIgQ29udGFpbmVyID0gaW1wb3J0X3N0eWxlZDQuZGVmYXVsdC5kaXZgXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogNHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm9yZGVyLXJhZGl1czogMjJweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbmA7XG52YXIgQnV0dG9uV3JhcHBlciA9IGltcG9ydF9zdHlsZWQ0LmRlZmF1bHQuZGl2YFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuYDtcbnZhciBCdXR0b24yID0gaW1wb3J0X3N0eWxlZDQuZGVmYXVsdC5idXR0b25gXG4gICAgYm9yZGVyLXJhZGl1czogMjJweDtcbiAgICBwYWRkaW5nOiA4cHggMDtcbiAgICBmbGV4OiAxO1xuICAgIHotaW5kZXg6IDM7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xuYDtcbnZhciBBY3RpdmVCYWNrZ3JvdW5kID0gaW1wb3J0X3N0eWxlZDQuZGVmYXVsdC5kaXZgXG4gICAgd2lkdGg6IGNhbGMoJHsocHJvcHMpID0+IDEwMCAvIHByb3BzLmxlbmd0aH0lKTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYm9yZGVyLXJhZGl1czogMjJweDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgei1pbmRleDogMjtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoJHsocHJvcHMpID0+IChwcm9wcy5hY3RpdmVOdW1iZXIgLSAxKSAqIDEwMH0lKTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBjdWJpYy1iZXppZXIoMC41LCAxLCAwLjg5LCAxKTtcbmA7XG52YXIgQmFja2dyb3VuZDIgPSBpbXBvcnRfc3R5bGVkNC5kZWZhdWx0LmRpdmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQ6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuZ3JheTEwMH07XG4gICAgei1pbmRleDogMTtcbmA7XG52YXIgVG9nZ2xlQnV0dG9uID0gKHsgaXRlbXMsIGNvbnRhaW5TdHlsZSwgZGVmYXVsdFZhbHVlID0gMSB9KSA9PiB7XG4gIGNvbnN0IHJhbmdlVmFsdWUgPSBkZWZhdWx0VmFsdWUgPCAxID8gMSA6IGRlZmF1bHRWYWx1ZSA+IGl0ZW1zLmxlbmd0aCA/IGl0ZW1zLmxlbmd0aCA6IGRlZmF1bHRWYWx1ZTtcbiAgY29uc3QgW2FjdGl2ZU51bWJlciwgc2V0QWN0aXZlTnVtYmVyXSA9ICgwLCBpbXBvcnRfcmVhY3QxOC51c2VTdGF0ZSkocmFuZ2VWYWx1ZSk7XG4gIGNvbnN0IGJ1dHRvbk9uQ2xpY2sgPSAobnVtYmVyLCBlLCBjYWxsYmFjaykgPT4ge1xuICAgIHNldEFjdGl2ZU51bWJlcihudW1iZXIpO1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIGNhbGxiYWNrKGUpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDE4LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb250YWluZXIsIHtcbiAgICBzdHlsZTogY29udGFpblN0eWxlXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxOC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQmFja2dyb3VuZDIsIG51bGwpLCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTguZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJ1dHRvbldyYXBwZXIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxOC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQWN0aXZlQmFja2dyb3VuZCwge1xuICAgIGFjdGl2ZU51bWJlcixcbiAgICBsZW5ndGg6IGl0ZW1zLmxlbmd0aFxuICB9KSwgaXRlbXMubWFwKCh7IHRpdGxlLCBvbkNsaWNrLCBidXR0b25TdHlsZSB9LCBpKSA9PiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTguZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJ1dHRvbjIsIHtcbiAgICBzdHlsZTogYnV0dG9uU3R5bGUsXG4gICAgb25DbGljazogKGUpID0+IGJ1dHRvbk9uQ2xpY2soaSArIDEsIGUsIG9uQ2xpY2spLFxuICAgIGtleTogaVxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTguZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJvdHRvbiwge1xuICAgIGNvbG9yOiBcImdyYXk3MDBcIlxuICB9LCB0aXRsZSkpKSkpO1xufTtcblxuLy8gcG5wOi9ob21lL3J1bm5lci93b3JrL1NlbWljb2xvbkRlc2lnbl9Gcm9udGVuZC9TZW1pY29sb25EZXNpZ25fRnJvbnRlbmQvcGFja2FnZXMvdWkvc3JjL2NvbXBvbmVudHMvU2VsZWN0LnRzeFxudmFyIGltcG9ydF9yZWFjdDE5ID0gX190b01vZHVsZShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGltcG9ydF9zdHlsZWQ1ID0gX190b01vZHVsZShyZXF1aXJlKFwiQGVtb3Rpb24vc3R5bGVkXCIpKTtcbnZhciBpbXBvcnRfcmVhY3Rfb3V0c2lkZV9jbGlja19oYW5kbGVyID0gX190b01vZHVsZShyZXF1aXJlX3JlYWN0X291dHNpZGVfY2xpY2tfaGFuZGxlcigpKTtcbnZhciBkaXJlY3Rpb24gPSB7XG4gIGNlbnRlcjogXCJjZW50ZXJcIixcbiAgbGVmdDogXCJmbGV4LWVuZFwiLFxuICByaWdodDogXCJmbGV4LXN0YXJ0XCJcbn07XG52YXIgU2VsZWN0ID0gKHtcbiAgaXRlbXMsXG4gIHZhbHVlLFxuICBvdmVyZmxvd09wdGlvbkRpcmVjdGlvbiA9IFwicmlnaHRcIixcbiAgb25DaGFuZ2UsXG4gIHBsYWNlaG9sZGVyXG59KSA9PiB7XG4gIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSAoMCwgaW1wb3J0X3JlYWN0MTkudXNlU3RhdGUpKGZhbHNlKTtcbiAgY29uc3QgW3RleHQsIHNldFRleHRdID0gKDAsIGltcG9ydF9yZWFjdDE5LnVzZVN0YXRlKSh2YWx1ZSA/IHZhbHVlIDogcGxhY2Vob2xkZXIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDE5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChpbXBvcnRfcmVhY3Rfb3V0c2lkZV9jbGlja19oYW5kbGVyLmRlZmF1bHQsIHtcbiAgICBvbk91dHNpZGVDbGljazogKCkgPT4gc2V0SXNPcGVuKGZhbHNlKVxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNlbGVjdEJ1dHRvbkJveCwge1xuICAgIG92ZXJmbG93T3B0aW9uRGlyZWN0aW9uLFxuICAgIG9uQ2xpY2s6ICgpID0+IHNldElzT3BlbighaXNPcGVuKVxuICB9LCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNlbGVjdE1haW5Cb3gsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxOS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQm9keTIsIHtcbiAgICBjbGFzc05hbWU6IFwic2VsZWN0LXRpdGxlXCJcbiAgfSwgdGV4dCksIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxOS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRHJvcERvd25JY29uLCBudWxsLCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogXCIxMlwiLFxuICAgIGhlaWdodDogXCI2XCIsXG4gICAgdmlld0JveDogXCIwIDAgMTIgNlwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDE5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTAgMEw2IDZMMTIgMEgwWlwiLFxuICAgIGZpbGw6IFwiIzk4OTU5RVwiXG4gIH0pKSkpLCAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERyb3BEb3duTWVudVdyYXBwZXIsIHtcbiAgICBpc1Zpc2lhYmxlOiBpc09wZW5cbiAgfSwgaXRlbXMubWFwKCh0aXRsZSwgaSkgPT4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDE5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChEcm9wRG93bk9wdGlvbiwge1xuICAgIGtleTogaSxcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBpZiAob25DaGFuZ2UpXG4gICAgICAgIG9uQ2hhbmdlKHRpdGxlKTtcbiAgICAgIHNldFRleHQodGl0bGUpO1xuICAgIH1cbiAgfSwgLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdDE5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChCb2R5Miwge1xuICAgIGNsYXNzTmFtZTogXCJzZWxlY3QtdGl0bGVcIlxuICB9LCB0aXRsZSkpKSkpKTtcbn07XG52YXIgU2VsZWN0TWFpbkJveCA9IGltcG9ydF9zdHlsZWQ1LmRlZmF1bHQuZGl2YFxuICAgIHBhZGRpbmc6IDAgMTJweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgaGVpZ2h0OiAzNnB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBiYWNrZ3JvdW5kOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmNvbG9ycy5ncmF5MTAwfTtcbiAgICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheTcwMH07XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgLnNlbGVjdC10aXRsZSB7XG4gICAgICAgIHdpZHRoOiA2MHB4O1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIDpob3ZlcixcbiAgICA6YWN0aXZlIHtcbiAgICAgICAgYmFja2dyb3VuZDogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheTMwMH07XG4gICAgfVxuYDtcbnZhciBTZWxlY3RCdXR0b25Cb3ggPSBpbXBvcnRfc3R5bGVkNS5kZWZhdWx0LmRpdmBcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgd2lkdGg6IDEwNHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAganVzdGlmeS1jb250ZW50OiAkeyh7IG92ZXJmbG93T3B0aW9uRGlyZWN0aW9uIH0pID0+IGRpcmVjdGlvbltvdmVyZmxvd09wdGlvbkRpcmVjdGlvbl19O1xuYDtcbnZhciBEcm9wRG93bkljb24gPSBpbXBvcnRfc3R5bGVkNS5kZWZhdWx0LmRpdmBcbiAgICB3aWR0aDogMTZweDtcbiAgICBoZWlnaHQ6IDE2cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMTNweDtcbiAgICB0b3A6IDEwcHg7XG5gO1xudmFyIERyb3BEb3duTWVudVdyYXBwZXIgPSBpbXBvcnRfc3R5bGVkNS5kZWZhdWx0LmRpdmBcbiAgICBkaXNwbGF5OiAkeyh7IGlzVmlzaWFibGUgfSkgPT4gaXNWaXNpYWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwifTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbWluLXdpZHRoOiAxMDAlO1xuICAgIHotaW5kZXg6ICR7TWF0aC5wb3coMTAsIDEwKX07XG4gICAgYm9yZGVyOiAxcHggc29saWQgJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheTMwMH07XG4gICAgdG9wOiA0MHB4O1xuICAgIHBhZGRpbmc6IDRweCAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmNvbG9ycy53aGl0ZX07XG5gO1xudmFyIERyb3BEb3duT3B0aW9uID0gaW1wb3J0X3N0eWxlZDUuZGVmYXVsdC5kaXZgXG4gICAgaGVpZ2h0OiAyOHB4O1xuICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZDogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMucHVycGxlNDAwfTtcbiAgICAgICAgLnNlbGVjdC10aXRsZSB7XG4gICAgICAgICAgICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMud2hpdGV9O1xuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG4vKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cbi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@semicolondsm/ui/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fahnyunji%2FDesktop%2FProject%2FPICK2023_FRONT%2Fpackages%2Fadmin%2Fsrc%2Fpages%2Findex.tsx&page=%2F!":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fahnyunji%2FDesktop%2FProject%2FPICK2023_FRONT%2Fpackages%2Fadmin%2Fsrc%2Fpages%2Findex.tsx&page=%2F! ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.tsx */ \"./src/pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmFobnl1bmppJTJGRGVza3RvcCUyRlByb2plY3QlMkZQSUNLMjAyM19GUk9OVCUyRnBhY2thZ2VzJTJGYWRtaW4lMkZzcmMlMkZwYWdlcyUyRmluZGV4LnRzeCZwYWdlPSUyRiEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzA1YmYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3NyYy9wYWdlcy9pbmRleC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fahnyunji%2FDesktop%2FProject%2FPICK2023_FRONT%2Fpackages%2Fadmin%2Fsrc%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./src/assets/login/background.png":
/*!*****************************************!*\
  !*** ./src/assets/login/background.png ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/background.7278cfa7.png\",\"height\":1080,\"width\":1920,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fbackground.7278cfa7.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":5});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL2xvZ2luL2JhY2tncm91bmQucG5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBNQUEwTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2xvZ2luL2JhY2tncm91bmQucG5nPzc2M2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2JhY2tncm91bmQuNzI3OGNmYTcucG5nXCIsXCJoZWlnaHRcIjoxMDgwLFwid2lkdGhcIjoxOTIwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmJhY2tncm91bmQuNzI3OGNmYTcucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjV9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/assets/login/background.png\n"));

/***/ }),

/***/ "./src/assets/login/logo.png":
/*!***********************************!*\
  !*** ./src/assets/login/logo.png ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/logo.ed15b244.png\",\"height\":300,\"width\":300,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flogo.ed15b244.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL2xvZ2luL2xvZ28ucG5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDRMQUE0TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2xvZ2luL2xvZ28ucG5nPzE2YzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2xvZ28uZWQxNWIyNDQucG5nXCIsXCJoZWlnaHRcIjozMDAsXCJ3aWR0aFwiOjMwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsb2dvLmVkMTViMjQ0LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/assets/login/logo.png\n"));

/***/ }),

/***/ "./src/components/common/Input.tsx":
/*!*****************************************!*\
  !*** ./src/components/common/Input.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/src/_tagged_template_literal.mjs */ \"./node_modules/@swc/helpers/src/_tagged_template_literal.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _emotion_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/styled */ \"./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\n        \"\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\n        \"\\n  font-size: 14px;\\n  color: \",\n        \";\\n  font-weight: 400;\\n\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\n        \"\\n  width: 100%;\\n  height: 44px;\\n  border: 1px solid \",\n        \";\\n  border-radius: 12px;\\n  color: \",\n        \";\\n  padding: 10px 16px;\\n  outline: none;\\n  font-size: 16px;\\n  font-weight: 400;\\n\"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\n\n\nconst Input = (param)=>{\n    let { label , type , ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(InputContainer, {\n        children: [\n            label && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(InputLabelBox, {\n                children: label\n            }, void 0, false, {\n                fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/components/common/Input.tsx\",\n                lineNumber: 16,\n                columnNumber: 17\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(InputBox, {\n                type: type,\n                ...props\n            }, void 0, false, {\n                fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/components/common/Input.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/components/common/Input.tsx\",\n        lineNumber: 15,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Input;\nconst InputContainer = _emotion_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"].div(_templateObject());\n_c1 = InputContainer;\nconst InputLabelBox = _emotion_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"].div(_templateObject1(), (param)=>{\n    let { theme  } = param;\n    return theme.colors.gray900;\n});\n_c2 = InputLabelBox;\nconst InputBox = _emotion_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"].input(_templateObject2(), (param)=>{\n    let { theme  } = param;\n    return theme.colors.gray300;\n}, (param)=>{\n    let { theme  } = param;\n    return theme.colors.gray800;\n});\n_c3 = InputBox;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Input);\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Input\");\n$RefreshReg$(_c1, \"InputContainer\");\n$RefreshReg$(_c2, \"InputLabelBox\");\n$RefreshReg$(_c3, \"InputBox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vSW5wdXQudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFZckMsTUFBTUMsUUFBUSxTQUEyQztRQUExQyxFQUFFQyxNQUFLLEVBQUVDLEtBQUksRUFBRSxHQUFHQyxPQUFtQjtJQUNsRCxxQkFDRSw4REFBQ0M7O1lBQ0VILHVCQUFTLDhEQUFDSTswQkFBZUo7Ozs7OzswQkFDMUIsOERBQUNLO2dCQUFTSixNQUFNQTtnQkFBTyxHQUFHQyxLQUFLOzs7Ozs7Ozs7Ozs7QUFHckM7S0FQTUg7QUFRTixNQUFNSSxpQkFBaUJMLDJEQUFVO01BQTNCSztBQU1OLE1BQU1DLGdCQUFnQk4sMkRBQVUscUJBRXJCLFNBQWVTO1FBQWQsRUFBRUEsTUFBSyxFQUFFO1dBQUtBLE1BQU1DLE1BQU0sQ0FBQ0MsT0FBTztBQUFEO01BRnZDTDtBQU1OLE1BQU1DLFdBQVdQLDZEQUFZLHFCQUdQLFNBQWVTO1FBQWQsRUFBRUEsTUFBSyxFQUFFO1dBQUtBLE1BQU1DLE1BQU0sQ0FBQ0csT0FBTztBQUFELEdBRTdDLFNBQWVKO1FBQWQsRUFBRUEsTUFBSyxFQUFFO1dBQUtBLE1BQU1DLE1BQU0sQ0FBQ0ksT0FBTztBQUFEO01BTHZDUDtBQVdOLCtEQUFlTixLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9JbnB1dC50c3g/NjY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJAZW1vdGlvbi9zdHlsZWRcIjtcbmltcG9ydCB7IENoYW5nZUV2ZW50LCBIVE1MQXR0cmlidXRlcyB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgSW5wdXRQcm9wcyBleHRlbmRzIEhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+IHtcbiAgdmFsdWU/OiBzdHJpbmc7XG4gIGxhYmVsPzogc3RyaW5nO1xuICBvbkNoYW5nZT86IChlOiBDaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4gdm9pZDtcbiAgbmFtZT86IHN0cmluZztcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbn1cblxuY29uc3QgSW5wdXQgPSAoeyBsYWJlbCwgdHlwZSwgLi4ucHJvcHMgfTogSW5wdXRQcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxJbnB1dENvbnRhaW5lcj5cbiAgICAgIHtsYWJlbCAmJiA8SW5wdXRMYWJlbEJveD57bGFiZWx9PC9JbnB1dExhYmVsQm94Pn1cbiAgICAgIDxJbnB1dEJveCB0eXBlPXt0eXBlfSB7Li4ucHJvcHN9IC8+XG4gICAgPC9JbnB1dENvbnRhaW5lcj5cbiAgKTtcbn07XG5jb25zdCBJbnB1dENvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGdhcDogOHB4O1xuYDtcblxuY29uc3QgSW5wdXRMYWJlbEJveCA9IHN0eWxlZC5kaXZgXG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgY29sb3I6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuY29sb3JzLmdyYXk5MDB9O1xuICBmb250LXdlaWdodDogNDAwO1xuYDtcblxuY29uc3QgSW5wdXRCb3ggPSBzdHlsZWQuaW5wdXRgXG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDQ0cHg7XG4gIGJvcmRlcjogMXB4IHNvbGlkICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuY29sb3JzLmdyYXkzMDB9O1xuICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheTgwMH07XG4gIHBhZGRpbmc6IDEwcHggMTZweDtcbiAgb3V0bGluZTogbm9uZTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBmb250LXdlaWdodDogNDAwO1xuYDtcbmV4cG9ydCBkZWZhdWx0IElucHV0O1xuIl0sIm5hbWVzIjpbInN0eWxlZCIsIklucHV0IiwibGFiZWwiLCJ0eXBlIiwicHJvcHMiLCJJbnB1dENvbnRhaW5lciIsIklucHV0TGFiZWxCb3giLCJJbnB1dEJveCIsImRpdiIsInRoZW1lIiwiY29sb3JzIiwiZ3JheTkwMCIsImlucHV0IiwiZ3JheTMwMCIsImdyYXk4MDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/common/Input.tsx\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/src/_tagged_template_literal.mjs */ \"./node_modules/@swc/helpers/src/_tagged_template_literal.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _emotion_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/styled */ \"./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js\");\n/* harmony import */ var _assets_login_background_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../assets/login/background.png */ \"./src/assets/login/background.png\");\n/* harmony import */ var _assets_login_logo_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ..//assets/login/logo.png */ \"./src/assets/login/logo.png\");\n/* harmony import */ var _components_common_Input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/common/Input */ \"./src/components/common/Input.tsx\");\n/* harmony import */ var _semicolondsm_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @semicolondsm/ui */ \"./node_modules/@semicolondsm/ui/dist/index.js\");\n/* harmony import */ var _semicolondsm_ui__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_semicolondsm_ui__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _utils_api_login__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/utils/api/login */ \"./src/utils/api/login/index.ts\");\n/* harmony import */ var react_cookies__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-cookies */ \"./node_modules/react-cookies/build/cookie.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\n        \"\\n  display: flex;\\n  align-items: center;\\n  width: 100%;\\n  height: 100%;\\n  justify-content: center;\\n  background-image: url(\",\n        \");\\n  background-size: cover;\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\n        \"\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  padding: 50px 60px;\\n  border-radius: 12px;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 30px;\\n  align-items: center;\\n  box-shadow: 0px 2px 8px rgba(33, 33, 33, 0.25);\\n  background-color: \",\n        \";\\n\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\n        \"\\n  display: flex;\\n  flex-direction: column;\\n  gap: 16px;\\n  width: 300px;\\n\"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    const data = (0,_swc_helpers_src_tagged_template_literal_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\n        \"\\n  border-radius: 12px;\\n\"\n    ]);\n    _templateObject3 = function() {\n        return data;\n    };\n    return data;\n}\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst Home = ()=>{\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_8__.useLayoutEffect)(()=>{\n        const sideBar = document.getElementById(\"sidebar\");\n        const spacer = document.getElementById(\"space\");\n        sideBar && (sideBar.style.display = \"none\");\n        spacer && (spacer.style.display = \"none\");\n        return ()=>{\n            sideBar && (sideBar.style.display = \"block\");\n            spacer && (spacer.style.display = \"block\");\n        };\n    }, []);\n    const { mutate: loginMutate , isLoading  } = (0,_utils_api_login__WEBPACK_IMPORTED_MODULE_9__.userLogin)();\n    const [loginData, setLoginData] = (0,react__WEBPACK_IMPORTED_MODULE_8__.useState)({\n        account_id: \"\",\n        password: \"\"\n    });\n    const onClickLogin = ()=>{\n        react_cookies__WEBPACK_IMPORTED_MODULE_10__[\"default\"].remove(\"accessToken\");\n        react_cookies__WEBPACK_IMPORTED_MODULE_10__[\"default\"].remove(\"refreshToken\");\n        loginMutate(loginData);\n        setLoginData({\n            account_id: \"\",\n            password: \"\"\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(LoginContainer, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(LoginWrapper, {\n            onSubmit: (e)=>{\n                e.preventDefault();\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_7___default()), {\n                    src: _assets_login_logo_png__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n                    width: 50,\n                    height: 50,\n                    alt: \"logo\"\n                }, void 0, false, {\n                    fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/pages/index.tsx\",\n                    lineNumber: 45,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(InputContainer, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_common_Input__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                            placeholder: \"아이디를 입력하세요\",\n                            name: \"account_id\",\n                            value: loginData.account_id,\n                            onChange: (e)=>setLoginData((state)=>({\n                                        ...state,\n                                        [e.target.name]: e.target.value\n                                    })),\n                            type: \"text\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/pages/index.tsx\",\n                            lineNumber: 47,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_common_Input__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                            placeholder: \"비밀번호를 입력하세요\",\n                            name: \"password\",\n                            value: loginData.password,\n                            onChange: (e)=>setLoginData((state)=>({\n                                        ...state,\n                                        [e.target.name]: e.target.value\n                                    })),\n                            type: \"password\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/pages/index.tsx\",\n                            lineNumber: 59,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/pages/index.tsx\",\n                    lineNumber: 46,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(LoginButton, {\n                    loading: isLoading,\n                    fullWidth: true,\n                    fill: \"purple\",\n                    onClick: onClickLogin,\n                    children: \"로그인\"\n                }, void 0, false, {\n                    fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/pages/index.tsx\",\n                    lineNumber: 72,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/pages/index.tsx\",\n            lineNumber: 40,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/ahnyunji/Desktop/Project/PICK2023_FRONT/packages/admin/src/pages/index.tsx\",\n        lineNumber: 39,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Home, \"ISGqn8FwrsADeTAgfo30Sz3sUQ0=\");\n_c = Home;\nconst LoginContainer = _emotion_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"].div(_templateObject(), _assets_login_background_png__WEBPACK_IMPORTED_MODULE_3__[\"default\"].src);\n_c1 = LoginContainer;\nconst LoginWrapper = _emotion_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"].form(_templateObject1(), (param)=>{\n    let { theme  } = param;\n    return theme.colors.white;\n});\n_c2 = LoginWrapper;\nconst InputContainer = _emotion_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"].div(_templateObject2());\n_c3 = InputContainer;\nconst LoginButton = (0,_emotion_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_semicolondsm_ui__WEBPACK_IMPORTED_MODULE_6__.Button)(_templateObject3());\n_c4 = LoginButton;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"Home\");\n$RefreshReg$(_c1, \"LoginContainer\");\n$RefreshReg$(_c2, \"LoginWrapper\");\n$RefreshReg$(_c3, \"InputContainer\");\n$RefreshReg$(_c4, \"LoginButton\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNtQjtBQUNYO0FBQ0U7QUFDTDtBQUNYO0FBQ21CO0FBRUo7QUFDVjtBQUVwQyxNQUFNVSxPQUFpQixJQUFNOztJQUMzQkgsc0RBQWVBLENBQUMsSUFBTTtRQUNwQixNQUFNSSxVQUFVQyxTQUFTQyxjQUFjLENBQUM7UUFDeEMsTUFBTUMsU0FBU0YsU0FBU0MsY0FBYyxDQUFDO1FBQ3ZDRixXQUFZQSxDQUFBQSxRQUFRSSxLQUFLLENBQUNDLE9BQU8sR0FBRyxNQUFLO1FBQ3pDRixVQUFXQSxDQUFBQSxPQUFPQyxLQUFLLENBQUNDLE9BQU8sR0FBRyxNQUFLO1FBQ3ZDLE9BQU8sSUFBTTtZQUNYTCxXQUFZQSxDQUFBQSxRQUFRSSxLQUFLLENBQUNDLE9BQU8sR0FBRyxPQUFNO1lBQzFDRixVQUFXQSxDQUFBQSxPQUFPQyxLQUFLLENBQUNDLE9BQU8sR0FBRyxPQUFNO1FBQzFDO0lBQ0YsR0FBRyxFQUFFO0lBRUwsTUFBTSxFQUFFQyxRQUFRQyxZQUFXLEVBQUVDLFVBQVMsRUFBRSxHQUFHWCwyREFBU0E7SUFFcEQsTUFBTSxDQUFDWSxXQUFXQyxhQUFhLEdBQUdmLCtDQUFRQSxDQUFDO1FBQ3pDZ0IsWUFBWTtRQUNaQyxVQUFVO0lBQ1o7SUFFQSxNQUFNQyxlQUFlLElBQU07UUFDekJmLDZEQUFjLENBQUM7UUFDZkEsNkRBQWMsQ0FBQztRQUNmUyxZQUFZRTtRQUNaQyxhQUFhO1lBQUVDLFlBQVk7WUFBSUMsVUFBVTtRQUFHO0lBQzlDO0lBRUEscUJBQ0UsOERBQUNHO2tCQUNDLDRFQUFDQztZQUNDQyxVQUFVLENBQUNDLElBQU07Z0JBQ2ZBLEVBQUVDLGNBQWM7WUFDbEI7OzhCQUVBLDhEQUFDekIsbURBQUtBO29CQUFDMEIsS0FBSzdCLDhEQUFJQTtvQkFBRThCLE9BQU87b0JBQUlDLFFBQVE7b0JBQUlDLEtBQUk7Ozs7Ozs4QkFDN0MsOERBQUNDOztzQ0FDQyw4REFBQ2hDLGdFQUFLQTs0QkFDSmlDLGFBQVk7NEJBQ1pDLE1BQUs7NEJBQ0xDLE9BQU9sQixVQUFVRSxVQUFVOzRCQUMzQmlCLFVBQVUsQ0FBQ1YsSUFDVFIsYUFBYSxDQUFDbUIsUUFBVzt3Q0FDdkIsR0FBR0EsS0FBSzt3Q0FDUixDQUFDWCxFQUFFWSxNQUFNLENBQUNKLElBQUksQ0FBQyxFQUFFUixFQUFFWSxNQUFNLENBQUNILEtBQUs7b0NBQ2pDOzRCQUVGSSxNQUFNOzs7Ozs7c0NBRVIsOERBQUN2QyxnRUFBS0E7NEJBQ0ppQyxhQUFZOzRCQUNaQyxNQUFLOzRCQUNMQyxPQUFPbEIsVUFBVUcsUUFBUTs0QkFDekJnQixVQUFVLENBQUNWLElBQ1RSLGFBQWEsQ0FBQ21CLFFBQVc7d0NBQ3ZCLEdBQUdBLEtBQUs7d0NBQ1IsQ0FBQ1gsRUFBRVksTUFBTSxDQUFDSixJQUFJLENBQUMsRUFBRVIsRUFBRVksTUFBTSxDQUFDSCxLQUFLO29DQUNqQzs0QkFFRkksTUFBTTs7Ozs7Ozs7Ozs7OzhCQUdWLDhEQUFDQztvQkFDQ0MsU0FBU3pCO29CQUNUMEIsU0FBUztvQkFDVEMsTUFBSztvQkFDTEMsU0FBU3ZCOzhCQUNWOzs7Ozs7Ozs7Ozs7Ozs7OztBQU1UO0dBdkVNZDtLQUFBQTtBQXlFTixNQUFNZ0IsaUJBQWlCMUIsMkRBQVUsb0JBTVBDLHdFQUFjO01BTmxDeUI7QUFVTixNQUFNQyxlQUFlM0IsNERBQVcscUJBWVYsU0FBZWtEO1FBQWQsRUFBRUEsTUFBSyxFQUFFO1dBQUtBLE1BQU1DLE1BQU0sQ0FBQ0MsS0FBSztBQUFEO01BWmhEekI7QUFlTixNQUFNUSxpQkFBaUJuQywyREFBVTtNQUEzQm1DO0FBT04sTUFBTVEsY0FBYzNDLDJEQUFNQSxDQUFDSSxvREFBTUE7TUFBM0J1QztBQUlOLCtEQUFlakMsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvaW5kZXgudHN4PzE5YTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlZCBmcm9tIFwiQGVtb3Rpb24vc3R5bGVkXCI7XG5pbXBvcnQgYmFja2dyb3VuZCBmcm9tIFwiLi4vYXNzZXRzL2xvZ2luL2JhY2tncm91bmQucG5nXCI7XG5pbXBvcnQgbG9nbyBmcm9tIFwiLi4vL2Fzc2V0cy9sb2dpbi9sb2dvLnBuZ1wiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9jb21wb25lbnRzL2NvbW1vbi9JbnB1dFwiO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIkBzZW1pY29sb25kc20vdWlcIjtcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgTmV4dFBhZ2UgfSBmcm9tIFwibmV4dFwiO1xuaW1wb3J0IHsgdXNlckxvZ2luIH0gZnJvbSBcIkAvdXRpbHMvYXBpL2xvZ2luXCI7XG5pbXBvcnQgY29va2llcyBmcm9tIFwicmVhY3QtY29va2llc1wiO1xuXG5jb25zdCBIb21lOiBOZXh0UGFnZSA9ICgpID0+IHtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzaWRlQmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaWRlYmFyXCIpO1xuICAgIGNvbnN0IHNwYWNlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3BhY2VcIik7XG4gICAgc2lkZUJhciAmJiAoc2lkZUJhci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgIHNwYWNlciAmJiAoc3BhY2VyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNpZGVCYXIgJiYgKHNpZGVCYXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIik7XG4gICAgICBzcGFjZXIgJiYgKHNwYWNlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgeyBtdXRhdGU6IGxvZ2luTXV0YXRlLCBpc0xvYWRpbmcgfSA9IHVzZXJMb2dpbigpO1xuXG4gIGNvbnN0IFtsb2dpbkRhdGEsIHNldExvZ2luRGF0YV0gPSB1c2VTdGF0ZSh7XG4gICAgYWNjb3VudF9pZDogXCJcIixcbiAgICBwYXNzd29yZDogXCJcIixcbiAgfSk7XG5cbiAgY29uc3Qgb25DbGlja0xvZ2luID0gKCkgPT4ge1xuICAgIGNvb2tpZXMucmVtb3ZlKFwiYWNjZXNzVG9rZW5cIik7XG4gICAgY29va2llcy5yZW1vdmUoXCJyZWZyZXNoVG9rZW5cIik7XG4gICAgbG9naW5NdXRhdGUobG9naW5EYXRhKTtcbiAgICBzZXRMb2dpbkRhdGEoeyBhY2NvdW50X2lkOiBcIlwiLCBwYXNzd29yZDogXCJcIiB9KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxMb2dpbkNvbnRhaW5lcj5cbiAgICAgIDxMb2dpbldyYXBwZXJcbiAgICAgICAgb25TdWJtaXQ9eyhlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8SW1hZ2Ugc3JjPXtsb2dvfSB3aWR0aD17NTB9IGhlaWdodD17NTB9IGFsdD1cImxvZ29cIiAvPlxuICAgICAgICA8SW5wdXRDb250YWluZXI+XG4gICAgICAgICAgPElucHV0XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIuyVhOydtOuUlOulvCDsnoXroKXtlZjshLjsmpRcIlxuICAgICAgICAgICAgbmFtZT1cImFjY291bnRfaWRcIlxuICAgICAgICAgICAgdmFsdWU9e2xvZ2luRGF0YS5hY2NvdW50X2lkfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxuICAgICAgICAgICAgICBzZXRMb2dpbkRhdGEoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIFtlLnRhcmdldC5uYW1lXTogZS50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZT17XCJ0ZXh0XCJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwi67mE67CA67KI7Zi466W8IOyeheugpe2VmOyEuOyalFwiXG4gICAgICAgICAgICBuYW1lPVwicGFzc3dvcmRcIlxuICAgICAgICAgICAgdmFsdWU9e2xvZ2luRGF0YS5wYXNzd29yZH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cbiAgICAgICAgICAgICAgc2V0TG9naW5EYXRhKChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBbZS50YXJnZXQubmFtZV06IGUudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGU9e1wicGFzc3dvcmRcIn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lucHV0Q29udGFpbmVyPlxuICAgICAgICA8TG9naW5CdXR0b25cbiAgICAgICAgICBsb2FkaW5nPXtpc0xvYWRpbmd9XG4gICAgICAgICAgZnVsbFdpZHRoXG4gICAgICAgICAgZmlsbD1cInB1cnBsZVwiXG4gICAgICAgICAgb25DbGljaz17b25DbGlja0xvZ2lufVxuICAgICAgICA+XG4gICAgICAgICAg66Gc6re47J24XG4gICAgICAgIDwvTG9naW5CdXR0b24+XG4gICAgICA8L0xvZ2luV3JhcHBlcj5cbiAgICA8L0xvZ2luQ29udGFpbmVyPlxuICApO1xufTtcblxuY29uc3QgTG9naW5Db250YWluZXIgPSBzdHlsZWQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7YmFja2dyb3VuZC5zcmN9KTtcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcbmA7XG5cbmNvbnN0IExvZ2luV3JhcHBlciA9IHN0eWxlZC5mb3JtYFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTAlO1xuICBsZWZ0OiA1MCU7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICBwYWRkaW5nOiA1MHB4IDYwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGdhcDogMzBweDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYm94LXNoYWRvdzogMHB4IDJweCA4cHggcmdiYSgzMywgMzMsIDMzLCAwLjI1KTtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMud2hpdGV9O1xuYDtcblxuY29uc3QgSW5wdXRDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBnYXA6IDE2cHg7XG4gIHdpZHRoOiAzMDBweDtcbmA7XG5cbmNvbnN0IExvZ2luQnV0dG9uID0gc3R5bGVkKEJ1dHRvbilgXG4gIGJvcmRlci1yYWRpdXM6IDEycHg7XG5gO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuIl0sIm5hbWVzIjpbInN0eWxlZCIsImJhY2tncm91bmQiLCJsb2dvIiwiSW5wdXQiLCJCdXR0b24iLCJJbWFnZSIsInVzZVN0YXRlIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlckxvZ2luIiwiY29va2llcyIsIkhvbWUiLCJzaWRlQmFyIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNwYWNlciIsInN0eWxlIiwiZGlzcGxheSIsIm11dGF0ZSIsImxvZ2luTXV0YXRlIiwiaXNMb2FkaW5nIiwibG9naW5EYXRhIiwic2V0TG9naW5EYXRhIiwiYWNjb3VudF9pZCIsInBhc3N3b3JkIiwib25DbGlja0xvZ2luIiwicmVtb3ZlIiwiTG9naW5Db250YWluZXIiLCJMb2dpbldyYXBwZXIiLCJvblN1Ym1pdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInNyYyIsIndpZHRoIiwiaGVpZ2h0IiwiYWx0IiwiSW5wdXRDb250YWluZXIiLCJwbGFjZWhvbGRlciIsIm5hbWUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwic3RhdGUiLCJ0YXJnZXQiLCJ0eXBlIiwiTG9naW5CdXR0b24iLCJsb2FkaW5nIiwiZnVsbFdpZHRoIiwiZmlsbCIsIm9uQ2xpY2siLCJkaXYiLCJmb3JtIiwidGhlbWUiLCJjb2xvcnMiLCJ3aGl0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "./src/utils/api/login/index.ts":
/*!**************************************!*\
  !*** ./src/utils/api/login/index.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"userLogin\": function() { return /* binding */ userLogin; }\n/* harmony export */ });\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-query */ \"./node_modules/react-query/es/index.js\");\n/* harmony import */ var _utils_axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/axios */ \"./src/utils/axios/index.ts\");\n/* harmony import */ var _utils_functions_tokenManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/functions/tokenManager */ \"./src/utils/functions/tokenManager.ts\");\n/* harmony import */ var _hooks_useApiError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/hooks/useApiError */ \"./src/hooks/useApiError.ts\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-hot-toast */ \"./node_modules/react-hot-toast/dist/index.mjs\");\n\n\n\n\n\n\nconst userLogin = ()=>{\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n    const { handleError  } = (0,_hooks_useApiError__WEBPACK_IMPORTED_MODULE_4__.useApiError)();\n    return (0,react_query__WEBPACK_IMPORTED_MODULE_1__.useMutation)(async (param)=>_utils_axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"/users/login\", {\n            ...param,\n            device_token: \"web_pick_admin\"\n        }), {\n        onError: handleError,\n        onSuccess: (param)=>{\n            let { data  } = param;\n            if (data.role === \"SCH\") {\n                (0,_utils_functions_tokenManager__WEBPACK_IMPORTED_MODULE_3__.setToken)(data.access_token, data.refresh_token, new Date(data.expire_at));\n                router.push(\"/main\");\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_5__.toast.error(\"권한이 없는 계정입니다.\");\n            }\n        }\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvYXBpL2xvZ2luL2luZGV4LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0U7QUFDTDtBQUNxQjtBQUNSO0FBQ1Y7QUFjakMsTUFBTU0sWUFBWSxJQUFNO0lBQzdCLE1BQU1DLFNBQVNQLHNEQUFTQTtJQUN4QixNQUFNLEVBQUVRLFlBQVcsRUFBRSxHQUFHSiwrREFBV0E7SUFFbkMsT0FBT0gsd0RBQVdBLENBQ2hCLE9BQU9RLFFBQ0xQLHlEQUFhLENBQVksZ0JBQWdCO1lBQ3ZDLEdBQUdPLEtBQUs7WUFDUkUsY0FBYztRQUNoQixJQUNGO1FBQ0VDLFNBQVNKO1FBQ1RLLFdBQVcsU0FBYztnQkFBYixFQUFFQyxLQUFJLEVBQUU7WUFDbEIsSUFBSUEsS0FBS0MsSUFBSSxLQUFLLE9BQU87Z0JBQ3ZCWix1RUFBUUEsQ0FDTlcsS0FBS0UsWUFBWSxFQUNqQkYsS0FBS0csYUFBYSxFQUNsQixJQUFJQyxLQUFLSixLQUFLSyxTQUFTO2dCQUV6QlosT0FBT2EsSUFBSSxDQUFDO1lBQ2QsT0FBTztnQkFDTGYsd0RBQVcsQ0FBQztZQUNkLENBQUM7UUFDSDtJQUNGO0FBRUosRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvYXBpL2xvZ2luL2luZGV4LnRzPzc0NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XG5pbXBvcnQgeyB1c2VNdXRhdGlvbiB9IGZyb20gXCJyZWFjdC1xdWVyeVwiO1xuaW1wb3J0IGluc3RhbmNlIGZyb20gXCJAL3V0aWxzL2F4aW9zXCI7XG5pbXBvcnQgeyBzZXRUb2tlbiB9IGZyb20gXCJAL3V0aWxzL2Z1bmN0aW9ucy90b2tlbk1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUFwaUVycm9yIH0gZnJvbSBcIkAvaG9va3MvdXNlQXBpRXJyb3JcIjtcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSBcInJlYWN0LWhvdC10b2FzdFwiO1xuXG5pbnRlcmZhY2UgVXNlckxvZ2luIHtcbiAgYWNjb3VudF9pZDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVXNlclRva2VuIHtcbiAgYWNjZXNzX3Rva2VuOiBzdHJpbmc7XG4gIHJlZnJlc2hfdG9rZW46IHN0cmluZztcbiAgZXhwaXJlX2F0OiBzdHJpbmc7XG4gIHJvbGU6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IHVzZXJMb2dpbiA9ICgpID0+IHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnN0IHsgaGFuZGxlRXJyb3IgfSA9IHVzZUFwaUVycm9yKCk7XG5cbiAgcmV0dXJuIHVzZU11dGF0aW9uKFxuICAgIGFzeW5jIChwYXJhbTogVXNlckxvZ2luKSA9PlxuICAgICAgaW5zdGFuY2UucG9zdDxVc2VyVG9rZW4+KFwiL3VzZXJzL2xvZ2luXCIsIHtcbiAgICAgICAgLi4ucGFyYW0sXG4gICAgICAgIGRldmljZV90b2tlbjogXCJ3ZWJfcGlja19hZG1pblwiLFxuICAgICAgfSksXG4gICAge1xuICAgICAgb25FcnJvcjogaGFuZGxlRXJyb3IsXG4gICAgICBvblN1Y2Nlc3M6ICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICBpZiAoZGF0YS5yb2xlID09PSBcIlNDSFwiKSB7XG4gICAgICAgICAgc2V0VG9rZW4oXG4gICAgICAgICAgICBkYXRhLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIGRhdGEucmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgIG5ldyBEYXRlKGRhdGEuZXhwaXJlX2F0KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcm91dGVyLnB1c2goXCIvbWFpblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2FzdC5lcnJvcihcIuq2jO2VnOydtCDsl4bripQg6rOE7KCV7J6F64uI64ukLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbInVzZVJvdXRlciIsInVzZU11dGF0aW9uIiwiaW5zdGFuY2UiLCJzZXRUb2tlbiIsInVzZUFwaUVycm9yIiwidG9hc3QiLCJ1c2VyTG9naW4iLCJyb3V0ZXIiLCJoYW5kbGVFcnJvciIsInBhcmFtIiwicG9zdCIsImRldmljZV90b2tlbiIsIm9uRXJyb3IiLCJvblN1Y2Nlc3MiLCJkYXRhIiwicm9sZSIsImFjY2Vzc190b2tlbiIsInJlZnJlc2hfdG9rZW4iLCJEYXRlIiwiZXhwaXJlX2F0IiwicHVzaCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/api/login/index.ts\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fahnyunji%2FDesktop%2FProject%2FPICK2023_FRONT%2Fpackages%2Fadmin%2Fsrc%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);